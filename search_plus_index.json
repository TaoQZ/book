{"./":{"url":"./","title":"前言","keywords":"","body":"前言前言 ​ 该博客主要用于本人记录笔记及在学习过程中遇到的问题,如有幸被您看到并且为您解决了一些问题我将感到很开心。如果您在观看的过程中发现有错误请发送邮件给我,欢迎指正!!! ​ 邮箱:taoqingzhou163@163.com Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 16:02:13 "},"git/Git.html":{"url":"git/Git.html","title":"git安装及简介","keywords":"","body":"Git是什么及为什么使用安装及配置基本概念介绍常用流程冲突TortoiseGit:Idea配置git可能出现的问题1. 解决git clone 克隆慢2. 解决github.com 无法访问连接超时3.删除所有文件Git 是什么及为什么使用 ​ git是一个强大的版本控制工具 ​ 例如在企业团队开发中,需要协同开发,每个人负责不同的模块,但又有可能依赖其他的模块 ​ 使用git可以解决这些问题,同时还可以对版本进行严格的控制与管理 安装及配置 ​ 官网:https://git-scm.com/download ​ 一路点击下一步,取消最后的两个选项,点finish ​ 安装完成后 配置用户名和邮箱 git config --global user.name \"用户名\" git config --global user.email \"邮箱地址\" 配置后的文件在 C:\\用户\\{用户名}\\.gitconfig文件中 ​ 生成ssh 秘钥与 github相关联 1. ssh-keygen -t rsa -C \"邮箱地址\" 默认生成到当前用户 C:\\用户\\{当前用户}\\.ssh\\id_rsa.pub 2. 进入github官网,登陆后 3. Settings --> SSH and GPG keys --> New SSH key 4. 将文件中的秘钥全部复制到 key 中 基本概念介绍 master : 默认开发分支 origin : 默认远程版本库 Index/Stage : 暂存区(工作区和版本库之间) add后的区域 workspace : 工作区 init后的区域 repository : 本地仓库 commit后的区域 remote : 远程仓库 github head : 指针 可以通过指针切换版本 常用流程 git init : 初始化仓库 把这个目录变成Git可以管理的仓库 git add 文件名: 添加文件 直接写符号.将(全部文件) 把文件添加到本地仓库的暂存区 git commit -m \"提交 注释\" 提交到当前分支 git remote add origin 远程仓库地址 ：远程仓库与本地仓库添加关联 有关联后,就不用再写这行 git pull origin master : 在推之前先拉 更新代码 git push -u origin master 将代码推到远程仓库 git log 查看日志 git status 查看当前仓库状态 冲突 ​ 对同一行或者同一块区域的代码进行修改后,导致本地仓库与远程仓库无法合并,因为软件也不知道采用哪一段代码,需要人工解决 这是出现冲突后在推时出现的情况 冲突:不同的人修改了相同位置的代码 ======= 其他人的代码 >>>>>>>版本号(具体的版本号可以在命令行中查询) 手动解决冲突后提交或合并后提交即可 TortoiseGit: ​ 使用git bash 需要很多重复的操作克隆 提交 推送,可以使用视图化工具简化操作 ​ 官网:https://tortoisegit.org/download/ ​ ​ 点击finish后,会进入配置 ​ 填入用户名和邮箱 ​ 安装完成后可能会需要重启 重启完成后点击鼠标右键会出现 ​ TortoiseGit --> settings 选择下方选项进行配置 安装完成后,在任意位置鼠标右键,可以完成快速克隆 提交... Idea配置git ​ Settings --> Version Control ​ 登录 ​ 如果选择上方的Enter token 登录 ​ 需要登录github官网 创建token ​ ​ 可能出现的问题 1. 解决git clone 克隆慢 ​ 开启代理(本人使用的ssr 默认端口是1080): git config --global http.proxy socks5://127.0.0.1:1080 ​ 关闭代理: git config --global http.proxy \"\" ​ 如果代理没有关闭可能也会出现 fatal: unable to access 'https://github.com/xxx/xxx.git/': Failed to connect to 127.0.0.1 port 1080: Connection refused ​ 可以使用命令关闭也可以在 C:\\Users\\{用户名}\\\\.gitconfig 中删除proxy代理 2. 解决github.com 无法访问连接超时 ​ 先在命令行ping官网 github.com ​ 如果ping不通 ​ 在 C:\\Windows\\System32\\drivers\\etc\\hosts 末尾添加 192.30.255.112 github.com git 185.31.16.184 github.global.ssl.fastly.net ​ 3.删除所有文件 git rm * -r Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"git/Idea中使用Git.html":{"url":"git/Idea中使用Git.html","title":"Idea使用Git","keywords":"","body":"配置使用1. 创建项目2. 添加文件3. 提交并推送4. 冲突配置 ​ 在git一章中有写在Idea中如何配置git 使用 1. 创建项目 ​ idea中创建项目 相当于 init 将当前项目变为工作空间 ​ github中创建新的仓库 2. 添加文件 ​ 相当于 add (文件) ​ 3. 提交并推送 ​ 在idea菜单栏VSC选项 相当于 commit ​ 选择需要提交的文件,在Commit Message 中填写信息,选择commit and push ​ 选择commit和push后,在第一次push时会遇到下图,需要将当前工作空间与远程仓库进行关联 ​ 填写完成后便可以进行推送 ​ 4. 冲突 ​ 不同的人在对相同行数的代码进行修改时,一方已经提交,另一方在拉取或者推送时会遇到冲突的问题 案例: ​ 第一次提交的代码 ​ 假设有人修改了代码,并上传成功 ​ 同时修改idea中的代码 ​ 进行commit 提交后进行pull 拉取 ​ 会出现冲突提示 ,点击中间的合并按钮 ​ 进行合并 ​ 合并后重新提交 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"vue/Vue.html":{"url":"vue/Vue.html","title":"Vue基础","keywords":"","body":"VueVue是什么使用Vue使用cdn官网下载入门案例方法生命周期指令计算属性axios路由router-link & router-view配置路由:style scopeexport default路由传参路由跳转嵌套路由Vuex什么是Vuex,为什么要有Vuex在项目中使用vuex访问vuex中的数据及方法mutations传参问题注意事项组件之间传值父传子子传父非父子组件之间传值导航守卫全局的单个路由独享的组件级别的Vue Vue是什么 ​ Vue是一套用于构建用户界面的渐进式框架(可以循序渐进的进行学习),是一个MVVM的框架,功能强大,重要特点双向绑定 ​ MVVM: ​ M:model,数据/模型层 ​ V:view 视图层 ​ VM:核心层,负责连接M和V,这一层已经由Vue实现好了 ​ 双向绑定: ​ 更新view页面的数据同步到data ​ 更新data中的数据同步渲染到页面 使用Vue ​ 以下案例的github地址:https://github.com/TaoQZ/Vue_example.git 使用cdn 官网下载 https://cn.vuejs.org/v2/guide/installation.html 入门案例 Title // 创建vue实例 // el 获取指定id的容器 // data 数据 // methods 方法 var vm = new Vue({ el:'#app', data:{ msg:'测试' }, methods:{ } }) 方法 var vm = new Vue({ methods:{ fun1:function () { console.log('方法1') }, fun2(){ console.log('方法2') }, // 箭头函数 // 1. 没有参数,或多个参数使用 () (a,b) // 2. 一个参数可以省略() 直接写形参 a // 3. 返回值 只有一行代码包括返回值 可以省略{} // 4. 多行代码需要 {} // 5. 注意 使用该箭头函数定义方法时,方法中this的指向不在再是Vue实例 fun3: () => console.log('方法3') } }); vm.fun1(); vm.fun2(); vm.fun3(); 生命周期 var vm = new Vue({ el:'#app', data:{ msg:'+' }, methods:{ show(){ console.log('我是show方法') } }, // 初始化前 数据和方法均为未初始化 beforeCreate(){ // undefined console.log(this.msg) // this.show is not a function this.show() console.log('=======================================') }, // 初始化完成 数据和方法已初始化完成 created(){ // 全部正常打印 console.log(this.msg) this.show() console.log('=======================================') }, // 双向绑定(挂载)前,表示模板已经编译完成,但是未将模板渲染到页面中 beforeMount(){ // 未渲染状态,只是原始字符串 console.log(document.getElementById('app').innerText) console.log('=======================================') }, // 双向绑定(挂载)后,将数据渲染到页面 mounted(){ // + console.log(document.getElementById('app').innerText) console.log('=======================================') }, // 更新钩子函数需要改变数据才会触发 // 更新前 data中的数据已经发生变化 未渲染到页面(页面还没同步) beforeUpdate(){ // + console.log(\"更新前\"+this.msg) // - console.log(\"更新前\"+document.getElementById('app').innerText) }, // 更新后 updated(){ // - console.log(\"更新后\"+this.msg) // - console.log(\"更新后\"+document.getElementById('app').innerText) }, // 销毁Vue实例 beforeDestroy(){ console.log('销毁前'+this) }, destroyed(){ console.log('销毁后'+this) } }) // 销毁Vue实例 vm.$destroy(); 指令 插值表达式 ​ 格式:{{}} ​ 可以直接获取Vue实例中定义的数据或函数 ​ 支持有返回值的函数或表达式 ​ 注意:该方式有缺点,在网速较慢时会出现{{}} 闪烁问题 2 var vm = new Vue({ el:'#app', data:{ msg:'zz' }, methods:{ show(){ return 10 } } }) v-text v-html ​ 为了解决插值闪烁问题提供了解决办法 ​ v-text : 将数据原样输出 ​ v-html : 可以将html的字符串渲染到页面 ​ var vm = new Vue({ el:'#app', data:{ msg:'tao' } }) v-model 加 表单元素 ​ 插值表达式,v-text,v-html : 只是数据的单向绑定 ​ v-model可以使视图和数据进行双向绑定,互相影响 ​ Title hobby: 网球 游泳 跑步 sex: 男 女 单复选框： 下拉列表 请选择 // 注意: 在data中拿到的值是标签的value值 var vm = new Vue({ el:'#app', data:{ num:1, hobby:[], checked: true, sex:'male', items:['河北','天津','北京'], province:'' } }) v-on ​ 例子 涉及事件 ​ click keydown mouseover mouseout ​ 事件处理的指令 var vm = new Vue({ el:'#app', methods:{ show(e){ console.log(e.keyCode) }, inDiv(){ console.log(\"鼠标移入\") }, outDiv(){ console.log(\"鼠标移出\") }, buttonClick(){ console.log('点击事件') }, isEnter(e){ console.log(e.keyCode) } } }) ​ 事件冒泡+vue解决办法_按键修饰符 ​ 事件发生时,触发内层的事件会同时触发外层的事件 ​ 常用按键修饰符 ​ .enter // 表示键盘的enter键 .tab .delete (捕获 \"删除\" 和 \"退格\" 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta 百度 var vm = new Vue({ el:'#app', methods:{ divClick(){ console.log('div') }, buttonClick(e){ // js中冒泡的解决方案 // 阻止事件的传播行为 // e.stopPropagation(); console.log('button') }, jump:()=>{ console.log('点击a标签后没有跳转网页') }, isEnter(e){ console.log(e.keyCode) } } }) v-for --------- var vm = new Vue({ el:'#app', data:{ users:[ {name:\"aa\",age:\"23\",sex:\"男\"}, {name:\"bb\",age:\"21\",sex:\"男\"}, {name:\"cc\",age:\"20\",sex:\"男\"} ] } }) v-if v-else-if v-else ​ v-else 必须紧跟在 v-if 或 v-else-if 后 ​ v-else-if 必须紧跟在v-if 或者 v-else-if 后 ​ A B C 索引 姓名 年龄 性别 20\"> {{index}} {{user.name}} {{user.age}} {{user.sex}} var vm = new Vue({ el:'#app', data:{ char:'A', users:[ {name:\"aa\",age:\"23\",sex:\"男\"}, {name:\"bb\",age:\"21\",sex:\"男\"}, {name:\"cc\",age:\"20\",sex:\"男\"} ] } }) ​ v-show与v-if flag flag var vm = new Vue({ el:'#app', data:{ flag:true }, methods:{ change(){ this.flag = !this.flag } } }) v-bind ​ 将html标签的属性与data中的数据进行绑定,可以简写为 :需要绑定的属性 Title .red{ background-color: red; } .black{ background-color: black; } .green{ background-color: green; } 请选择 var vm = new Vue({ el:'#app', data:{ myclass:'', colors:[ {name:'红',clas:'red'}, {name:'黑',clas:'black'}, {name:'绿',clas:'green'} ] } }) ​ 计算属性 ​ 解决在插值表达式中书写过长或需要长期维护使用的表达式比较麻烦 var vm = new Vue({ el:'#app', data:{ msg:'' }, methods:{ method_num(){ return 1+1; } }, computed:{ computed_num(){ return 2+1; } } }) axios ​ 用于发送http请求 ​ cdn 在使用vue-cli脚手架创建的项目中使用 下载依赖 npm install axios 在项目中引入 全局引入需要在main.js中导入 局部引入需要在export default 上导入: // 导入 axios import axios from 'axios' // 设置请求路径的前缀 axios.defaults.baseURL='http://localhost:8080' // 第一个axios可以当做全局的访问前缀 Vue.prototype.axios(相当于起别名) = axios 示例: 全局 全局需要使用this. 局部不需要 export default { name: \"list\", data(){ return{ users:[] } }, methods:{ findAll(){ this.axios.get('/user') .then(res => this.users = res.data) }, created() { this.findAll(); } } ​ 2.局部 // 局部引入axios 不需要this // import axios from 'axios' // axios.defaults.baseURL='http://localhost:8080' export default { name: \"list\", data(){ return{ users:[] } }, methods:{ findAll(){ axios.get('/user') .then(res => this.users = res.data) } }, created() { this.findAll(); } } ​ git传递对象参数 this.axios.get('url',{ params : 对象 }) ​ delete传递参数 数组 ​ 需要配合qs使用 安装 npm install qs main.js 中配置 import qs from 'qs' Vue.prototype.qs = qs this.axios.delete(\"/book\", { params: { books: arr }, paramsSerializer: params => { // false 用来控制格式 return qs.stringify(params, { indices: false }) } }).then(() => { this.getPageInfo(this.num, this.size); }) 路由 router-link & router-view : : 配置路由: ​ 使用vue-cli创建项目后就已做好的: ​ 在router/index.js文件中 导入 vue-router并使用 // 导入 导入时名字可以随便起,但在use名字时必须相同 import Vue from 'vue' import VueRouter from 'vue-router' // 导入组件 全局引入 import Home from '../views/Home' // 使用 Vue.use(VueRouter) // 创建路由 数组 const routes = [ // path:访问路径 // name:路由名称 // component:要跳转到的组件 需要导入 { // 写路径时记得写 / path: '/', name: 'home', component: Home, // 再使用时引入的方式,可以提高首页显示速度 // component: () => import('../views/Home.vue') } ] ​ main.js import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false; new Vue({ router, // 相当于 router:router store, render: h => h(App) }).$mount('#app'); style scope export default // 就是vue的实例 是es6的语法 和之前写的差别是,data只能按照这种格式(和写时组件一样) export default { name: \"list\", methods:{ to(){ alert(\"list\") } }, data(){ return{ msg:'msg' } } } 路由传参 两种方法的路由配置 { path: '/edit', name: 'edit', component: Edit }, 1.name+params 修改 // 接收 this.$route.params.id 2.path+query 修改 // 在地址栏填写参数也是使用该方式获取 this.$route.query.id; 3.路由传参(地址栏) // 在路由的path后添加 :参数名 { path: '/edit/:id', name: 'edit', component: Edit } 该方法路由跳转的三种方式 修改 修改 this.$router.push({ path: '/edit/111', }) // 接收 this.$route.params.id 路由跳转 this.$router.push(路由的path) 同样适用于传参 方式一:根据路由的name匹配路由 路由配置 { path: '/edit', name: 'edit', component: Edit }, 跳转路由 this.$router.push({ name:'edit', params:{ id : 888 } }) 获取路由中的参数 不会表现在地址栏上 this.$route.params.id 方式二:根据路由的path匹配路由 路由配置 { path: '/edit', name: 'edit', component: Edit }, 跳转路由 this.$router.push({ path:'/edit', query:{ id : 111 } }) 获取参数 this.$route.query.id 表现在地址栏 http://localhost:8080/edit?id=111 嵌套路由 ​ 在一个组件中引入了另一个组件,相当于父与子的关系 我是父页面 去子页面 我是子页面 ​ router/index.js 配置 const routes = [ // path:访问路径 // name:路由名称 // component:要跳转到的组件 需要导入 { path: '/father', name: 'father', component: () => import('../views/father.vue'), children:[ { // 注意子路由不能加 / path: 'son', name: 'son', component: () => import('../views/son.vue'), }, // 子路由path的第二种写法,访问路径加上父组件的路径 // { // path: '/home/son', // name: 'son', // component: () => import('../views/son.vue') // } ] } ] Vuex 什么是Vuex,为什么要有Vuex ​ Vuex是组件之间数据共享的一种机制 ​ 使用父子传值或兄弟传值,太麻烦不好管理,有了Vuex想要共享数据,只需要把数据挂在到vuex就行,想要获取数据,直接从vuex上拿就行,vuex中的数据被修改后其他引用了此数据的组件,也会同步更新 在项目中使用vuex ​ 安装vuex: npm install vuex ​ 使用 在store/index.js文件 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ // 公共区域数据 state: { num : 10, }, mutations: { }, actions: { }, modules: { } }) 在main.js文件中将store挂在到vm实例上 import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false new Vue({ router, store, render: h => h(App) }).$mount('#app') 访问vuex中的数据及方法 state,mutations,getters 官方文档:https://vuex.vuejs.org/zh/guide/getters.html getters是从state中派生的数据,对state中的数据进行过滤修改,并且可以传参返回 在store/index.js中定义变量存储数据 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ // 公共区域数据 state: { num : 10, }, mutations: { // 第一个参数默认是state addNum(state){ state.num++ } }, }) 在components中创建两个组件 --> add: --> add: num: // 解构表达式 import {mapState,mapMutations} from 'vuex' export default { name: \"add\", // 官方推荐的使用方式,进行结构,将公共属性的值作为计算属性 computed:{ ...mapState(['num','msg']) }, methods:{ add(){ this.$store.state.num++ }, ...mapMutations(['addNum']) } } ​ minus.vue // 解构 将vuex中的数据解构成计算属性使用 import {mapState} from 'vuex' export default { name: \"add\", methods:{}, computed:{ ...mapState(['num']) } } ​ router/index.js // 将这两个组件导入 import add from '@/components/add.vue' import minus from '@/components/minus.vue' const routes = [ { path:'/访问路径', name:'home', // 这里是简写方式次里是简写方式 相当于 add:add,minus:minus // 前面是路由名称,后面是组件名称,相同时可以简写 components:{ add, minus } }, ] ​ App.vue:用于显示变量,观察其修改后两个组件中数据是否同步更新 // 这里的name对应路由配置中components中所写即可 ​ actions ​ 登录案例 登录 账号: 密码: --> import {mapActions} from 'vuex' export default { methods:{ login(){ // 官方并不推荐直接调用actions中的方法 this.$store.dispatch('asyncLogin',this.user) }, ...mapActions(['asyncLogin']), }, name: \"Login\", data(){ return{ user:{} } }, } store/index.js mutations: { // 第一个参数默认state login(state,user){ console.log(user) } }, actions: { // 第一个参数默认context asyncLogin(context,user){ // 调用的mutations中的方法,进行封装使之可以提交异步请求 context.commit('login',user) } }, mutations传参问题 ​ 如果在调用mutations中的方法时,方法有多个参数,后面的参数是undefined ​ 将参数封装成对象进行传值 注意事项 ​ 如果想获取有返回值的方法(对state中的数据有所更改后),可以在getters中创建方法,并 返回处理后的结果,使用this.$store.getters.方法名获取 ​ vue推荐使用mutations来对state中的数据进行修改,mutations中的方法第一个参数必 须是state,也就是当前vuex中的state,可以直接调用 ​ actions:包裹mutations中的方法,异步调用 ​ 例子: mutations:{ // 第一个参数必须是state addNumS(state,step){ state.num += step }, }, actions: { // 第一个参数必须是context step:参数 addNumSAysc(context,step){ // 利用context来调用mutations的方法来操作state中的数据 context.commit('addNumS',step) } }, 组件之间传值 父传子 ​ 父组件 我是父组件 // 导入子组件 import son from '@/views/Son' export default { name: \"Parent\", data(){ return{ msg : '我是父组件中的数据' } }, // 注册使用 components:{son} } ​ 子组件 我是子组件: export default { name: \"Son\", // 定义props属性用来接收父组件的数据 props:['sonMsg'] } 子传父 ​ 父组件 我是父组件 我是子组件传递到父组件的数据: // 导入子组件 import son from '@/views/Son' export default { name: \"Parent\", data(){ return{ msg : '我是父组件中的数据', sonMs: '' } }, methods:{ sonSMsg(msg){ this.sonMs = msg } }, // 注册使用 components:{son} } ​ 子组件 我是子组件中的按钮 export default { name: \"Son\", data(){ return{ msg:'我是子组件中的数据' } }, methods : { sendMsgToParent(){ this.$emit('fromSon',this.msg) } } } 非父子组件之间传值 ​ 设立公共数据文件 ​ Bus.js // 导入vue import vue from 'vue' // 创建vue对象 export default new vue() ​ Demo01.vue // 导入 兄弟组件 为了将其显示在同一个页面 import demo02 from '@/views/Demo02' // 导入Bus.js 公共数据文件 import bus from './Bus.js' export default { name: \"Demo01\", data(){ return{ msg : '我是demo01中的数据' } }, methods:{ sendMsgToDemo02(){ // 固定格式 bus.$emit('fromDemo02',this.msg) } }, components:{demo02} } ​ Demo02.vue 我是demo02: 我是传递过来的数据:插值表达式 msg // 导入Bus.js 公共数据文件 import bus from './Bus.js' export default { name: \"Demo02\", data(){ return{ msg : '' } }, created() { // 固定格式 data就是传递过来的数据 bus.$on('fromDemo02',data => { this.msg = data }) } } 导航守卫 导航守卫的主要作用就是为了拦截导航路由,使之可以跳转或者取消,有多种方式注册路由导航钩子 全局的 在 main.js中注册一个全局的路由导航钩子 /** * to : 路由将要跳转的路由的信息 * from : 路径跳转前的路径信息 * next : * next() : 放行 * next(false) : 返回原来的页面 * next('路径') : 改变路由跳转地址 跳转指定路由 */ router.beforeEach((to,from,next)=>{ }) 单个路由独享的 { path: '/login', name: 'login', component: Login, beforeEnter(to,from,next) { } } 组件级别的 export default { name: \"Login\", beforeRouteEnter(to, from, next) { console.log(\"准备进入登录\"); next(); }, beforeRouteUpdate(to,from,next){ console.log('路由发生改变,组件被复用时触发') }, beforeRouteLeave (to, from, next) { console.log(\"准备离开登录\"); next(); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"vue/vue理论知识.html":{"url":"vue/vue理论知识.html","title":"Vue理论知识","keywords":"","body":"1.MVVM中,MVVM分别代表什么?作用是什么2.简述什么是单页,以及单页的优缺点3.Vue项目中的src文件夹一般放置那些文件及文件夹4.简述vue的声明周期及钩子函数5.前后台分离,怎么解决跨域问题6.Vue-router的作用是什么7.Vue中父子组件之间如何传值是怎么实现的8.Vue如何传参9.Vuex怎么实现数据共享10.Vue的全家桶有哪些11.Vue的导航守卫是什么?有什么作用?12.Vuex的五大核心属性13.var let const的区别14.Vue中常用的指令15.Vue中的事件修饰符16.什么是js的冒泡事件17.什么是计算属性,如何理解18.import.export导入和导出1.MVVM中,MVVM分别代表什么?作用是什么 ​ MVVM是model-view-viewModel的简写,是MVC的改进版 ​ 为了分离model(模型)和view(视图),再由viewModel将v和m连接起来 ​ 当model(模型)发生改变时,通过MVVM框架自动更新view视图状态 ​ 当view(视图)发生改变时,通过MVVM框架自动更新model模型数据 2.简述什么是单页,以及单页的优缺点 ​ 总:项目中只有一个html页面,由多个组件构成 ​ 优点:速度快,用户体验好,修改内容不会刷新整个页面,因此,spa对服务器的压力也会变小;前后端分离;页面效果炫酷(比如切换页面时的专场动画) ​ 缺点:初次加载耗时长;提高页面复杂度;不利于seo;导航不可用,如果需要使用需要自行完成后退前进功能 3.Vue项目中的src文件夹一般放置那些文件及文件夹 ​ assets:静态资源目录 ​ components:功能组件 ​ views:页面组件 ​ store:vuex的数据 ​ router:路由文件 ​ App.vue:入口页面 ​ main.js:全局的配置文件 4.简述vue的声明周期及钩子函数 ​ vue的生命周期就是该vue实例从创建到销毁的过程 ​ beforeCreat:创建完成之前,数据未完成初始化 ​ created:创建完成后,数据已完成初始化,一般用于页面渲染 ​ beforeMount:双向绑定前 ​ mounted:双向绑定后 ​ beforeUpdate:更新前 ​ updated:更新后 ​ beforeDestroy:销毁前 ​ destroyed:销毁后 5.前后台分离,怎么解决跨域问题 ​ 1.jsonp:叫古老的方式,利用script标签可跨域的特性,缺点是只能发送get请求 ​ 2.nginx:配置代理服务器,使其可以访问目标服务器,然后再将目标服务器返回的数据返回到我们的客户端,可以发送各种请求 ​ 3.比较常用的cors,需要后端设置Access-control-Allow-Origin头,可以自行配置可跨域的地址,缺点是可能会发生两次请求 6.Vue-router的作用是什么 ​ vue-router是vue.js官方的路由管理器 ​ :完成组件之间的切换 ​ this.$route : 完成组件之间的传参 ​ this.$router.push():完成组件之间的跳转 7.Vue中父子组件之间如何传值是怎么实现的 ​ 1.父传子:在子组件中设置props属性用于接受父组件传递的数据 ​ 2.子传父:子组件触发自身的方法,使用$emit调用父类的监听的方法 ​ 3.非父子组件:需要设立公共的文件 8.Vue如何传参 ​ 1.query+path 传参: 获取值: this.$route.query.参数名 ​ 2.params+name 传参: 获取值: this.$route.params.参数名 ​ 3.路由传参(地址栏) 在路由组件的配置上添加 { path:'/path/:参数名' name: component: } 获取值: this.$route.params.参数名 9.Vuex怎么实现数据共享 ​ vue整合vuex,在main.js中以组件的方式导入store.js文件 ​ 在store.js文件的state区域保存数据,使之可以在任何位置可被访问 ​ 使用store.js文件中的mutations可以更新state区域的数据,通过读写完成数据的共享 10.Vue的全家桶有哪些 ​ Vue的两大核心: ​ 组件化:将一个整体应用,拆分成多个可复用的个体(组件) ​ 数据驱动:在修改数据的前提下,不操作dom,直接影响bom显示 ​ vue-router:路由,组件之间的切换 ​ vue-cli:构建vue单页应用的脚手架工具 ​ vuex:状态数据 ​ axios:vue官方推荐的发送http请求的工具包 11.Vue的导航守卫是什么?有什么作用? ​ vue-rouer提供的导航钩子,主要用来拦截导航,完成跳转或取消,有多种方式可以在路由导航发生时执行路由导航钩子 ​ 全局的: ​ router.beforeEach在全局注册一个before钩子 ​ 单个路由独享的: ​ 在路由配置中直接定义一个beforeEnter路由导航钩子 ​ 组件级别的: ​ beforeRouteEnter,beforeRouteUpate,beforeRouteLeave ​ 直接在路由组件中定义路由导航钩子 12.Vuex的五大核心属性 ​ Vuex是专门为vue.js应用设计的状态管理架构 ​ 1.state:基本数据 ​ 2.getters:从基本数据派生的数据 ​ 3.mutations:更改数据的提交方式,同步 ​ 4.actions:像一个装饰器,用来包裹mutations,使之可以异步 ​ 5.modules:模块化vuex 13.var let const的区别 ​ var是es3提供的创建变量的关键字,定义的变量为全局变量 ​ let是es6新增的定义变量的关键字,定义的变量是局部变量 ​ const定义的变量的常量 14.Vue中常用的指令 ​ v-if:当条件为true时,显示该元素 ​ v-show:修改页面元素的css样式完成显示或隐藏 ​ v-on:为标签添加事件 ​ v-model:双向绑定,用于数据和视图的同步 ​ v-bind:将数据绑定的标签的属性上 ​ v-for:遍历数组 15.Vue中的事件修饰符 ​ .stop:阻止冒泡 ​ .prevent:禁止默认事件 ​ .capture:捕获 ​ .once:只执行一次 ​ .self:只在自身触发 16.什么是js的冒泡事件 ​ 当触发页面中标签的事件时,会同时触发其所有父与子标签的事件,直到跟标签 17.什么是计算属性,如何理解 ​ 计算属性本质是一个有返回值的方法,在页面渲染时,可以将该方法当做一个属性使用,当data中的数据未发生改变时,计算属性直接读取缓存 18.import.export导入和导出 ​ 是es6中,module主要构成的两个命令 ​ export:用于导出模块中的变量的接口 ​ import:用于在一个模块中导入另一个含有export接口的接口 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"frontend/node/node.html":{"url":"frontend/node/node.html","title":"Node的安装","keywords":"","body":"Node.js什么是Node.js安装与配置Node.js 什么是Node.js ​ Node.js是一个服务器端的JavaScript运行环境,可以让前端使用Node.js提供HTML,CSS,JS等资源访问,提供npm插件用于管理所有js资源,和java中的maven类似 安装与配置 最新版本: https://nodejs.org/zh-cn/download/ 历史版本: https://nodejs.org/zh-cn/download/releases/ windows下载msi文件后傻瓜式安装 查看node版本: node -v node -version 10版本方式 切换源工具 安装完node后会自带一个npm,但默认的源在国外,访问会比较慢,切换成国内源 安装nrm npm install -g nrm 查看当前源 nrm ls 切换源 nrm use taobao 安装(下载)包,版本是可选项,下载后在node_modules文件夹里 npm install [@] 全局安装 npm install -g 全局卸载 npm uninstall -g Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"frontend/mock/mock.html":{"url":"frontend/mock/mock.html","title":"Mock","keywords":"","body":"Mock1.什么是mock.js2.入门使用2.1测试2.2全局使用3.使用EasyMock3.1 环境准备3.2 创建接口3.3 在Vue中配合axios使用3.4 可能出现的问题Mock 1.什么是mock.js ​ Mock.js是一款模拟数据生成器,旨在帮助前端工程师独立于后端进行开发,可以拦截ajax请求生成模拟数据进行接口测试,其模拟的数据有随机性,可以自行配置,支持的数据类型丰富,包括不限于文本,邮箱,图片,颜色等 ​ 官方文档很详细 2.入门使用 了解mock.js功能后,还需要结合项目使用,该示例在vue下 2.1测试 安装 npm install mockjs 在script标签中使用 // 使用 Mock var Mock = require('mockjs') var data = Mock.mock({ // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 'list|1-10': [{ // 属性 id 是一个自增数，起始值为 1，每次增 1 'id|+1': 1 }] }) // 输出结果 参数4为数据打印格式,空格 console.log(JSON.stringify(data, null, 4)) 2.2全局使用 需要先安装axios和mockjs npm install axios npm install mockjs 在src下创建mock/mock.js文件 示例 // es6语法引入mock模块 import Mock from 'mockjs'; // 导出接口 export default Mock.mock( '/api/get', { 'list|1-10':[{ 'id|+1': 1, 'age|1-10': 10 }] //还可以自定义其他数据 } ); Mock.mock( '/api/post', { 'list|3':[{ 'number|+1': 1, 'string': '@string(3,5)' }] } ) 在main.js中全局引入 名字随便起,mock会自动拦截ajax请求 import mymock from './mock/mock.js'; 创建vue文件并且使用 : : export default { name: \"MockDemo\", data() { return { list : [], arr : [], } }, methods: { async fun1(){ let {data} = await this.axios.get('/api/get') this.list = data.list }, async fun2(){ let {data} = await this.axios.post('/api/post') this.arr = data.list } }, created() { this.fun1() this.fun2() } } 启动测试 npm run serve 3.使用EasyMock 采用自行搭建的方式 3.1 环境准备 环境准备,其中node版本可能需要使用8(从10降下来的) 克隆EasyMock并且安装依赖 $ git clone https://github.com/easy-mock/easy-mock.git $ cd easy-mock && npm install 运行 npm run dev 默认端口7300,可以在config/default.json中修改配置 3.2 创建接口 访问http://127.0.0.1:7300 注册账号登陆后,创建接口 自定义数据模板 3.3 在Vue中配合axios使用 默认路径配合axios的配置 在main.js指定请求路径前缀 import axios from 'axios' // axios.defaults.baseURL='后端真实接口' // 设置为下图的Base URL即可 axios.defaults.baseURL='http://localhost:7300/mock/5e684a733d64e467945f8c30/example' methods: { async fun(){ let {data} = await this.axios.get('/xxxServie') console.log(data.list) } }, 可以看到模拟数据和使用真实数据,只需要更改main.js中的axios的默认请求路径即可 mockjs会自动拦截请求 3.4 可能出现的问题 node的版本过高,需要使用8的版本 redis和mongo的环境变量设置 注册服务或者开启服务需要使用管理员命令窗口,有两种命令行可用 win+x+a 或者在文件夹中 shift+右键 EasyMock运行后报错,可以尝试修改其config/default.json中的 该错误可能是node8.9.4版本的错误 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"frontend/nuxt/nuxt.html":{"url":"frontend/nuxt/nuxt.html","title":"Nuxt","keywords":"","body":"Nuxt1.安装及创建1.1 环境准备1.2 创建项目1.3 项目结构1.4 编译运行2.路由2.1静态路由2.2动态路由3.布局文件4.结合Axios4.1使用axios4.2使用 @nuxtjs/axios设置baseURL5.异步数据Nuxt Nuxt是一个服务器端渲染技术(SSR server side render),基于Vue之上 官网 : https://zh.nuxtjs.org/guide ​ 之前使用的Vue是客户端渲染,也就是客户端向服务器发送请求,服务端将数据返回给客户端,客户端将数据填充到占位符中,但这种方式不利于SEO ​ SEO:搜索引擎只会采集页面中的静态数据,对网站进行收录,可以让更多人访问到,并不会采取ajax返回的数据,服务器端渲染技术可以处理这个缺点 ​ 服务器端渲染技术,其实在学传统web开发时就已经接触过了,jsp时代便是使用tomcat进行编译,将数据提前填充拼接到HTML中返回给客户端,客户端直接渲染HTML就可以了,以及其他的模板引擎,比如freemark等 ​ Nuxt使用Node作为服务器进行渲染,但也并不是所有代码都运行在Node中,比如alert、localStorage、window、location、document这些客户端特有的代码(当然也有使用运行的时机,在之前单纯的Vue中就是可以的),该方式固然对服务器性能要求高,所以根据业务进行选用即可,比如新闻,博客,资讯等 1.安装及创建 1.1 环境准备 安装node 安装vue-cli，nuxt是基于vue之上的 Vue文档 https://cli.vuejs.org/zh/guide/installation.html npm install -g vue-cli 安装nuxt项目 yarn global add create-nuxt-app 1.2 创建项目 npx create-nuxt-app 创建项目的选项 同时Nuxt也支持热更新,即在修改代码后会自动重新编译,并且影响页面显示 1.3 项目结构 1.4 编译运行 # 安装项目所有依赖 npm run install # 服务在热重载状态下运行在localhost:3000 npm run dev # 编译成上线项目并且启动服务 npm run build npm run start 2.路由 2.1静态路由 没有参数的路由,在Nuxt中页面组件都是放在pages中,并且会根据文件夹及文件名称进行路由,如果vue页面名称为index则默认为当前文件夹的默认访问页面,页面组件名称一般为小写(大写也可访问),并且在浏览器输入地址路由是也可不区分大小写 文件名 URL访问 pages/index.vue / pages/home.vue /home pages/goods/index.vue /goods pages/goods/list.vue /goods/list 2.2动态路由 带有参数的路由地址 2.2.1 /路由地址/参数 页面组件: pages/goods/_id.vue 访问地址: http://localhost:3000/goods/123 获取数据 : this.$route.params.id // 此处的id同样根据组件的名称获取 如果需要获取多个参数如 /pages/路由/参数1/参数2 只需进行文件夹的嵌套,只需在前面加_(下划线)即可,如下 /pages/路由/_文件夹/ _xxx.vue 获取方式和上面一样,根据文件夹名称和组件名称分别获取(去掉下划线)即可 第一个参数: 第二个参数: 可能出现的问题 ERROR [Vue warn]: Invalid component name: \"_id\". Component names should conform to valid custom element name in html5 specification. 解决方法:将组件name中的_去掉 2.2.2 /路由地址?key=value 页面组件: pages/home.vue 访问地址: http://localhost:3000/home?id=123&name=111 获取数据 : id:{{this.$route.query.id}} name:{{this.$route.query.name}} 同样可以使用 this.$router.push的方式跳转路由并且传递参数,同样支持params和query两种方式 3.布局文件 在项目的layouts文件夹中默认有default.vue文件,项目中所有页面默认使用该布局 定义布局在layouts中创建布局文件(.vue) 在head中设置头信息 页头 // 引入该布局的页面组件会在这里显示 页尾 // 添加头信息(添加在布局文件和页面组件都可以),导入css和js export default { name: \"MyLayout\", head:{ title : 'XXX页面', meta:[ {charset:'utf-8'}, {name:'keywords',content:'关键字'}, {name:'description',content:'描述'} ], link:[ {rel:'stylesheet' , href :\"/style/header.css\"}, {rel:'stylesheet' , href :\"/style/footer.css\"} ], script:[ {type:'text/javascript',src:'js/jquery-1.8.3.min.js'} ] }, data() { return {} }, methods: {} } 在需要该布局的页面组件中引用 export default { // 根据布局组件名称引用 layout : 'MyLayout', name: \"home\", } 1.可以在nuxt.config,js中可以使用head设置所有页面公共的head信息(标题、编码、meta等) 2.在每个页面中可以使用head属性设置这个页面的head信息 3.如果页面中的head信息如果添加hid属性,就会把公共的相同的hid属性要盖掉，否则就添加 两次 4.结合Axios 8个生命周期函数,除了以下两个之外,其余6个基本在客户端执行,所以选择在(mounted)挂载前初始化数据 创建前beforeCreated:执行两次,客户端和服务端都会执行一次 创建后created:执行两次,客户端和服务端都会执行一次 4.1使用axios 安装axios npm install axios 该方式需要注意的是如果在多个页面同时引用的话会被打包两次,在nuxt.config.js中配置避免该情况 build: { /* ** You can extend webpack config here */ extend (config, ctx) { }, vendor: ['axios'] } import axios from 'axios' export default { name: \"list\", data(){ return{ persons:[] } }, methods: { async findAll() { let {data} = await axios.get('url') this.persons = data.list }, }, mounted() { this.findAll() } } 4.2使用 @nuxtjs/axios 在项目创建时会有该选项,也可手动安装 npm install @nuxtjs/axios 在nuxt.config.js中进行配置 modules: [ '@nuxtjs/axios', ], axios: { // proxyHeaders: false }, 使用 // import axios from 'axios' export default { name: \"list\", data(){ return{ persons:[] } }, methods: { async findAll() { // 少了axios中的data属性,直接解构数据即可 console.log(this.$axios.$get('url')) let {list} = await this.$axios.$get('url') console.log(list) this.persons = list }, }, mounted() { this.findAll() }, } 设置baseURL 最简单的方式,在nuxt.config.js中修改配置 modules: [ // Doc: https://axios.nuxtjs.org/usage '@nuxtjs/axios', ], /* ** Axios module configuration ** See https://axios.nuxtjs.org/options */ axios: { baseURL: \"http://127.0.0.1:7300/mock/5e702522021bfd53ec2f7309/leyou\" }, 使用 async loginSubmit(){ let {data} = await this.$axios.$post('/auth-service/login',this.loginForm) } 在src下创建SysConfig.js文件 var sysConfig = { apiURL: '', staticURL: '', baseURL: 'http://127.0.0.1:7300/mock/5e702522021bfd53ec2f7309/' }; var person = { name : 'Tao' } export {sysConfig,person} 其他组件中引入使用 import {sysConfig} from \"@/plugins/SysConfig\"; import VerifyCode from '@/components/VerifyCode' export default { name: \"regist\", layout:\"loginAndRegister\", components:{ VerifyCode }, data(){ return{ regForm:{} } }, methods:{ async register(){ let {data} = await this.$axios.$post(sysConfig.baseURL+'/web-service/regist',this.regForm) console.log(data) if (data.errno == 1){ this.$router.push(\"/login\") } }, } } 5.异步数据 ​ 使用 AJAX 获取的数据都属于异步数据，这种数据默认是无法直接写在页面中的，也就是说在页面 的源代码中是看不到 AJAX 的数据的（在网页源代码中并没有）。 ​ AJAX获取的数据并不利于SEO，所以为了解决这个问题，Nuxt中提供了一个 asyncData ，可以让 我们在服务器端获取 AJAX 的数据，返回给客户端一个已经拥有AJAX数据的页面 // 与methods平级 async asyncData({$axios}){ let {list} = await $axios.$get('url') console.log(list) // 特殊的返回数据方式,必须要有返回值 return {persons:list} } 接收参数数据 async asyncData({$axios,params,query}){ console.log(params.id) console.log(query.id) let {list} = await $axios.$get('url') console.log(list) return {persons:list} } 分别使用params和query的方式传递参数 在其他页面组件中添加点击事件 goList(){ this.$router.push({ name : 'list', params: { id : 456 } }) // this.$router.push({ // path : 'list', // query: { // id : 888 // } // }) } 使用地址栏的方式 http://localhost:3000/list?id=888 配合this.$route.query.key获取数据 浏览器展示数据 开发工具控制台打印,使用console.log的方式,但是打印在了开发工具中,并没有在浏览器中,说明在服务器端已经获取到数据了 此时在看网页源代码已经有ajax请求的数据了(使用vue和nuxt比较死数据时,nuxt的网页源代码也会有数据,而普通的vue的网页源代码中并没有) Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"jwt/JWT.html":{"url":"jwt/JWT.html","title":"JWT","keywords":"","body":"JWT为什么使用jwt流程token包含的内容JWT详解使用JWT ​ 官网:https://jwt.io/ ​ JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；它是分布式服务权限控制的标准解决方案！ 为什么使用jwt ​ 在之前的单体项目中,用户登录后将信息存储到session中,从而判断当前用户是否登录限定请求资源,但现在是前后端分离,如果还是用session,后端服务由于要保证高可用使用了集群,此时便需要实现session之间的共享,使用jwt避免这些麻烦的操作 流程 ​ 用户请求登录服务后,请求成功颁发jwt凭证,也就是token,将token保存到客户端中,此后的每次请求客户端都会携带此凭证到独立的验证授权中心进行校验 token包含的内容 JWT的token包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型type，这里是JWT（type=jwt） 加密算法，自定义(rs256/base64/hs256) 我们会对头部进行base64加密（可解密），得到第一部分数据 Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息-userid,username（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64加密，得到第二部分数据 Signature：base64加密，签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret，盐）（不要泄漏，最好周期性更换），通过加密算法生 JWT详解 jwt的一个有规则的token 它有三部分组成：Header.payload.signature,每部分都是通过base64加密而成的 jwt每个部分都是可以解密的 JWT详解 base64编码原理 Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符如下： 这64个字符是各种字符编码（比如ASCII码）所使用字符的子集，并可打印。唯一有点特殊的是最后两个字符。 Base64本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。假设我们对Hello！进行Base64编码，按照ASCII表，其转换过程如下图所示： 可知Hello！的Base64编码结果为SGVsbG8h，原始字符串长度为6个字符串，编码后长度为8个字符，每3个原始字符经编码成4个字符。 但要注意，Base64编码是每3个原始字符编码成4个字符，如果原始字符串长度不能被3整除，怎么办？使用0来补充原始字符串。 以Hello！！为例，其转换过程为： Hello!! Base64编码的结果为 SGVsbG8hIQAA 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 AA 实际不带有效信息，所以需要特殊处理，以免解码错误。 标准Base64编码通常用 = 字符来替换最后的 A，即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。 如果Base64编码字符串不会相互拼接再传输，那么最后的 = 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 = 字符，再解码即可。 解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。 总结： 1、base64的编码/加密原理 答：原理：将键盘输入的字符用base64编码表示 过程：将键盘输入字符的ascii码值，转成的对应8位二进制，将该二进制6个一组拆分，并计算拆分之后的十进制值，找出十进制值在base64编码中对应的字母，即完成base64加密 成。用于验证整个数据完整和可靠性 使用 依赖 0.7.0 2.9.6 io.jsonwebtoken jjwt ${jjwt.version} joda-time joda-time ${joda-time.version} 工具类 import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import org.joda.time.DateTime; import javax.crypto.spec.SecretKeySpec; import javax.xml.bind.DatatypeConverter; import java.security.Key; public class JWTUtil { /** * 获取token中的参数 * * @param token * @return */ public static Claims parseToken(String token,String key) { if (\"\".equals(token)) { return null; } try { return Jwts.parser() .setSigningKey(DatatypeConverter.parseBase64Binary(key)) .parseClaimsJws(token).getBody(); } catch (Exception ex) { return null; } } /** * 生成token * * @param userId * @return */ public static String createToken(Integer userId,String key, int expireMinutes) { SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; long nowMillis = System.currentTimeMillis(); //生成签名密钥 byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(key); Key signingKey = new SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName()); //添加构成JWT的参数 JwtBuilder builder = Jwts.builder() // .setHeaderParam(\"type\", \"JWT\") // .setSubject(userId.toString()) .claim(\"userId\", userId) // 设置载荷信息 .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())// 设置超时时间 .signWith(signatureAlgorithm, signingKey); //生成JWT return builder.compact(); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"java/java8new_feature/默认方法.html":{"url":"java/java8new_feature/默认方法.html","title":"默认方法","keywords":"","body":"默认方法default关键字多个默认方法静态方法默认方法 默认方法就是接口可以有默认已实现方法,而且不需要实现类去实现其方法 default关键字 主要为了解决向接口中添加新功能扩展而不影响之前实现该接口的类 public interface DefaultOne { default void print(){ System.out.println(\"defaultOne\"); } } 创建实现类直接调用即可 多个默认方法 如果一个类实现了多个拥有同名默认方法的接口怎么办 会编译错误,解决办法有两种 第一种自然是实现类对方法进行重写 第二种使用super关键字指定调用哪个接口中的默认方法 public interface DefaultOne { default void print(){ System.out.println(\"defaultOne\"); } } public interface DefaultTwo { default void print(){ System.out.println(\"defaultTwo\"); } } public class MyBase implements DefaultOne,DefaultTwo{ @Override public void print() { // 可同时调用 // DefaultOne.super.print(); DefaultTwo.super.print(); System.out.println(\"新增内容\"); } } 静态方法 public interface DefaultOne { default void print(){ System.out.println(\"defaultOne\"); } static void run(){ System.out.println(\"run\"); } } 可以直接使用接口名调用 @Test public void demo(){ new MyBase().print(); DefaultOne.run(); } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"java/java8new_feature/Lambda.html":{"url":"java/java8new_feature/Lambda.html","title":"Lambda","keywords":"","body":"Lambda表达式函数式接口自定义函数式接口方法引用创建数组内置的函数式接口SupplierConsumerPredicateFunctionComparator比较器Lambda表达式 Lambda 允许把函数作为一个方法的参数(将函数作为参数传递到方法中) 可以使代码变得更加简洁紧凑 重要特征 不需要声明参数的类型,编译器可以进行识别 当函数表达式只有一个参数时可以省略小括号(有多个不可省略) 如果函数表达式的实现主体只有一个语句,不需要大括号 如果函数表达式的主体只有一个返回值,编译器会自动返回(省略大括号及return) 对Lambda的个人理解:本质是一个已经实现了方法主体的对象,减少了实现类和简化了匿名内部类的代码 函数式接口 在Java8中可以写成函数表达式,是因为Java8提供了函数式接口,只有这些函数式接口才可以简写成Lambda表达式,并且Java编译器可以进行类型推断 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 函数式接口可以被隐式转换为 lambda 表达式。 自定义函数式接口 // 接口中只有并且只有一个抽象方法的接口就是一个函数式接口 @FunctionalInterface // 该注解会检查是否符合函数式接口的规范,符合规则不写也可以 public interface MyFunctionalInterface { // 默认public abstract void method(); // void fun(); } public class MyTest { public static void main(String[] args) { fun(() -> System.out.println(\"123\")); } private static void fun(MyFunctionalInterface myFunctionalInterface){ myFunctionalInterface.method(); } } 方法引用 方法引用使用一对::冒号,通过方法的名字来指向一个方法 @Data @NoArgsConstructor @AllArgsConstructor public class Bird { private int age; private String name; public static Bird Birdfactory(Supplier supplier){ return supplier.get(); } public static String getBirdName(Supplier supplier){ return supplier.get(); } public void print(){ System.out.println(name); } public String getName() { // System.out.println(name); return name; } public static void print2(Bird bird){ System.out.println(\"静态方法\"); } } public class MyTest3 { public static void main(String[] args) { // 构造器引用 ClassName::new Bird bird = Bird.Birdfactory(Bird::new); bird.setName(\"啄木鸟\"); bird.setAge(2); // 使用的是Supplier接口 Supplier supplier = Bird::new; Bird bird1 = supplier.get(); // 特定对象的方法引用 Supplier instance::method String birdName = Bird.getBirdName(bird::getName); System.out.println(birdName); // 为了演示其他对象也可以使用该方式进行方法的引用 // String str = \"qwe\"; // String birdName1 = Bird.getBirdName(str::toUpperCase); // System.out.println(birdName1); System.out.println(\"=================\"); List birds = Arrays.asList(bird, new Bird(5,\"八声杜鹃\"), new Bird(6,\"雎鸠\"), new Bird(3,\"沙百灵\") ); // 下面两者本质是一个消费者 Consumer 在forEach中会调用其accept()方法 // 特定类的任意对象的方法的引用 Class:new birds.forEach(Bird::print); System.out.println(\"=============\"); // 静态方法引用 Class::static_method // birds.forEach(Bird::print2); Function fun = Math::ceil; Double apply = fun.apply(100.1); System.out.println(apply); // 在这里的时候遇到了一个问题(理解不到位),使用forEach(Bird::getName)为什么不可以,因为forEach的参数是个Consumer消费者 // 只会调用方法不会对其返回值有操作 // 流操作对最终的集合没有影响 birds.stream().sorted(Comparator.comparing(Bird::getAge)).forEach(System.out::println); /* Bird(age=2, name=啄木鸟) Bird(age=3, name=沙百灵) Bird(age=5, name=八声杜鹃) Bird(age=6, name=雎鸠)*/ // List collect = birds.stream().sorted(Comparator.comparing(Bird::getName)).collect(Collectors.toList()); // System.out.println(collect); System.out.println(birds); // [Bird(age=2, name=啄木鸟), Bird(age=5, name=八声杜鹃), Bird(age=6, name=雎鸠), Bird(age=3, name=沙百灵)] } } 创建数组 // 指定长度 分配空间并初始默认值(不同的类型有不同的默认值) int[] one = new int[10]; // 显示初始化 int[] two = {1,2,3}; // 显示初始化 int[] three = new int[]{1,2,3}; // 数组一旦进行初始化,分配内存空间,其数组长度不可变 // 使用方法引用的方式创建数组 // 因为需要指定数组的长度,java使用了Function接口 利用了其方法的特点 传入第一个泛型类型的参数,返回值一个第二个泛型类型的值 Function functionStringArray = String[]::new; String[] apply = functionStringArray.apply(10); System.out.println(apply.length); System.out.println(apply[0]); 内置的函数式接口 JDK在java.util.function包中提供了大量常用的函数式接口 创建一个bean方便后面使用 @Data @AllArgsConstructor public class Person { private String name; private Integer age; } Supplier 该接口仅包含一个无参的方法,返回值和泛型一致 public class SupplierDemo { // 生产一个数据 返回值便为泛型 private static String getString(Supplier funtion){ return funtion.get(); } @Test public void fun(){ String name = \"java\"; String string = getString(name::toUpperCase); System.out.println(string); } } Consumer 接收一个参数无返回值,类似消费者 public class ConsumerDemo { // 消费一个数据 private static void printString(Consumer function,Person person){ function.accept(person); } // 将数据按照函数表达式的顺序完成操作 private static void consumerString(Consumer one,Consumer two,String zz){ one.andThen(two).accept(zz); } public static void main(String[] args) { Person person = new Person(\"张三\", 123); printString(s -> System.out.println(s.getName()),person); consumerString( s -> System.out.println(s.toLowerCase()+\"==one\"), s -> System.out.println(s.toUpperCase()+\"==two\"),\"cZxy\" ); } } Predicate 接收一个参数,返回一个布尔值结果 public class PredicateDemo { // 提供返回值为布尔类型的函数式接口 // test 判断 // negate 取反 private static boolean stringLength(Predicate funtion,String string){ return funtion.test(string); // return funtion.negate().test(string); } // 完成多个数据之间的逻辑判断 or或者 and并且 private static boolean stringContains(Predicate one,Predicate two,String string){ // or方法的参数也是一个函数表达式 return one.or(two).test(string); // return one.and(two).test(string); } public static void main(String[] args) { // 参数长度是否大于50 System.out.println(stringLength(s -> s.length() > 50,\"Hello World\")); // 参数是否以J开头或者包含W System.out.println(stringContains(one -> one.startsWith(\"J\"), two -> two.contains(\"W\"),\"Hello World \")); // 将字符串切割后 sex为女 名字长度为4的返回做输出打印 String[] array = { \"迪丽热巴,女\",\"古力娜扎,女\",\"马尔扎哈,男\",\"赵丽颖,女\"}; demo( sex -> sex.split(\",\")[1].equals(\"女\"), length -> length.split(\",\")[0].length() == 4,array).forEach(System.out::println); } private static List demo(Predicate sex,Predicate length,String[] string){ ArrayList strings = new ArrayList<>(); for (String s : string) { if (sex.and(length).test(s)){ strings.add(s); } } return strings; } } Function 接收一个参数T,返回一个结果R public class FunctionDemo { // apply参数是第一个泛型的类型,返回值是第二个参数的泛型的类型 // 当然两个泛型可以一样 private static void method(Function funtion,String num){ System.out.println(funtion.apply(num)+1); } public static void main(String[] args) { method(Integer::parseInt,\"50\"); String person = \"赵丽颖,20\"; example( age -> age.split(\",\")[1], Integer::parseInt, add -> add += 100, person ); } // 需求,拿到字符串中的数字转为Integer再进行数学运算 // 第一个参数 拿到字符串中的数字字符串 // 再将数字字符串转为Integer // 对数字进行数学运算 // 其中参数的泛型: 从第二个参数开始,第一个泛型的类型都是前一个参数的返回值类型 // andThen 和consumer中的作用类似,都是先执行什么操作然后在根据结果执行另一个操作 private static void example(Function split,Function parseInt,Function result,String age){ System.out.println(split.andThen(parseInt).andThen(result).apply(age)); } } Comparator比较器 public class ComparatorDemo { // java8之后改为函数表达式 // 返回值是一个函数表达式 private static Comparator myComparator(){ return (a, b) -> b.length() - a.length() ; } public static void main(String[] args) { String[] array = {\"asd\",\"qwer\",\"zz\"}; // java8之前的写法 // o1代表当前元素 o2代表其后的元素 返回值为1 o1向右放 -1 o1向左放 0相等 不动 // Arrays.sort(array, new Comparator() { // @Override // public int compare(String o1, String o2) { // return o2.length() - o1.length(); // } // }); Arrays.sort(array,myComparator()); System.out.println(Arrays.toString(array)); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"java/java8new_feature/Lambda访问外部变量.html":{"url":"java/java8new_feature/Lambda访问外部变量.html","title":"Lambda访问外部变量","keywords":"","body":"Lambda访问外部变量局部变量成员变量及静态变量访问接口的默认方法Lambda访问外部变量 局部变量 可以访问num变量和进行final修饰后的num变量,那么区别在哪里 可以看到如果变量在lambda表达式后进行修改会报错,也就是num变量必须是final的 在不进行修改的情况下为什么第一个注释掉的num也可用,是因为此时的num是隐式的final,也就是后续没有进行修改 public static void main(String[] args) { // Integer num = 123; final Integer num = 123; Function function = (param) -> Integer.parseInt(param)+num; Integer apply = function.apply(\"12\"); System.out.println(apply); // Error:(14, 80) java: 从lambda 表达式引用的本地变量必须是最终变量或实际上的最终变量 // num = 11; } 在lambda表达式中修改变量也是不可用的 public static void main(String[] args) { Integer num = 123; Function function = (param) -> { Integer result =Integer.parseInt(param)+num; // Variable used in lambda expression should be final or effectively final num = 1; return result; }; Integer apply = function.apply(\"12\"); System.out.println(apply); } 不允许声明一个与局部变量同名的参数或者局部变量 public static void main(String[] args) { Integer num = 123; // Variable 'num' is already defined in the scope Function function = (num) -> Integer.parseInt(num)+num; Integer apply = function.apply(\"12\"); System.out.println(apply); } 成员变量及静态变量 public class MyLambda { // 非包装类的基本数据类型,静态和非静态都是有默认值的 static int num; int number; public void print(){ // 静态变量 Function function1 = param -> { num = 1; return Integer.parseInt(param)+num; }; System.out.println(function1.apply(\"123\")); // 成员变量 Function function2 = param -> { number = 2; return Integer.parseInt(param)+number; }; System.out.println(function2.apply(\"456\")); } @Test public void fun(){ new MyLambda().print(); } } 访问接口的默认方法 // method方法和converter 都是将字符串转为Integer,为了演示Lambda是否可以直接调用默认方法 @FunctionalInterface public interface MyFunction { Integer method(String string); default Integer converter(String string){ return Integer.parseInt(string); } } @Test public void fun(){ MyFunction myFunction = param -> Integer.parseInt(param); Integer result1 = myFunction.method(\"123\"); System.out.println(result1); // 使用匿名对象的方式可以访问接口中的默认方法 MyFunction myFunction2 = new MyFunction(){ @Override public Integer method(String string) { return converter(string); } }; Integer result2 = myFunction2.method(\"456\"); System.out.println(result2); // lambda不能访问接口中的默认方法 // MyFunction myFunction3 = param -> converter(param); } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"java/java8new_feature/日期时间API.html":{"url":"java/java8new_feature/日期时间API.html","title":"新的日期时间API","keywords":"","body":"Java 8 日期时间 APILocalDateLocalTimeLocalDateTimeDateTimeFormatterTemporalAdjustersZonedDateTime、Instant时间戳、时区Java 8 日期时间 API ​ 在旧版的Java中,日期时间API主要在java.util包下,但其存在许多问题,比如java.util.Date是非线程安全的,所有的日期类都是可变的。从Java8开始,Java API中已经能够提供高质量的日期和时间支持,java.time包,并且日期时间都是不可变和线程安全的 LocalDate 该类是一个不可变的和线程安全的;表示日期,通常被视为年月日,该类不存储或表示时区 public class LocalDateDemo { public static void main(String[] args) { // LocalDate 不可变,线程安全的日期类 年月日 // 获取当前日期 默认格式:yyyy-MM-dd 根据系统的时钟和时区获取日期 LocalDate date = LocalDate.now(); // 年 int year = date.getYear(); // 月 int monthValue = date.getMonthValue(); // 日(号) int dayOfMonth = date.getDayOfMonth(); System.out.println(date); System.out.println(year+\"年/\"+monthValue+\"(\"+date.getMonth()+\")月/\"+dayOfMonth+\"日\"); // 星期 int week = date.getDayOfWeek().getValue(); System.out.println(\"星期:\"+week+\"===\"+date.getDayOfWeek()); // 当年中的第几天 int dayOfYear = date.getDayOfYear(); // 当月的总天数 int monthLength = date.lengthOfMonth(); // 当年的总天数 int yearLength = date.lengthOfYear(); System.out.println(\"几天是本年的第\"+dayOfYear+\"天\"); System.out.println(\"本月的总天数为:\"+monthLength); System.out.println(\"当年的总天数为:\"+yearLength); System.out.println(date.isLeapYear() ? \"闰年\" : \"平年\"); } @Test public void fun(){ // 在创建LocalDate时会对日期进行校验,如果任何字段的值超出范围，或者如果月的日期对于月份无效将抛出异常 // java.time.DateTimeException: Invalid date 'February 29' as '2019' is not a leap year // 2019年不是闰年,所以2月没有29号 // LocalDate of = LocalDate.of(2019, 2, 29); // 虽然2020年时闰年,但是2月份最多只有29天 // java.time.DateTimeException: Invalid date 'FEBRUARY 30' // LocalDate of = LocalDate.of(2020, 2, 30); LocalDate of = LocalDate.of(2020, 2, 29); System.out.println(of); // 根据一年中的第一天创建对象 LocalDate date = LocalDate.ofYearDay(2020, 32); System.out.println(date); // 参数需要一个正确的日期格式 年-月-日 // 严格按照yyyy-MM-dd的格式验证 需补0 // LocalDate parse = LocalDate.parse(\"1999-10-9\"); LocalDate parse = LocalDate.parse(\"1999-10-09\"); System.out.println(parse); // 查看指定日期是否在参数日期之前, 其他还有 之后,相等方法来比较日期 boolean after = parse.isBefore(LocalDate.now()); System.out.println(after); } } LocalTime 该类是一个不可变的和线程安全的;表示时间,通常被视为时分秒,该类不存储或表示时区 public class LocalTimeDemo { public static void main(String[] args) { // LocalTime 不可变线程安全的时间类 // 默认格式 时:分:秒:纳秒(nanosecond) LocalTime now = LocalTime.now(); System.out.println(now); // 指定时分秒创建对象 LocalTime of = LocalTime.of(18, 30,48); System.out.println(of); System.out.println(of.getHour()+\"时\"+of.getMinute()+\"分\"+of.getSecond()+\"秒\"); // 减去指定的Hour并返回对象 同样可减去分秒纳秒 LocalTime minusHours = of.minusHours(2); System.out.println(minusHours); // 增加指定的Minute 同样可增加时秒纳秒 LocalTime plusMinutes = of.plusMinutes(29); // of.plusNanos(12); System.out.println(plusMinutes); // 根据文本解析为LocalTime对象 // 严格按照HH:mm:ss的格式验证 需补0 // LocalTime parse = LocalTime.parse(\"09:20:6\"); LocalTime parse = LocalTime.parse(\"09:20:06\"); System.out.println(parse); boolean after = of.isAfter(now); System.out.println(\"是否在当前时间之后:\"+after); } @Test public void demo(){ LocalTime of = LocalTime.of(18, 30,38,199); // java.time.DateTimeException: Invalid value for HourOfDay (valid values 0 - 23): 24 // 从0-23来表示时间 // 将时间改为指定参数值,相当于进行set LocalTime localTime = of.withHour(6).withMinute(10); System.out.println(localTime); // 获取当前时间总秒数 int i = localTime.toSecondOfDay(); System.out.println(i); // 将秒数转为LocalTime对象 LocalTime ofSecondOfDay = LocalTime.ofSecondOfDay(i); System.out.println(ofSecondOfDay); // System.out.println(of); // System.out.println(of.getNano()); } } LocalDateTime 上面的两个类一个表示日期,一个表示时间,而该类更像是将两者结合起来,通过观看源码得知,它确实也是这么做的 构造是个私有的,一个参数是LocalDate另一个则是LocalTime public class LocalDateTimeDemo { public static void main(String[] args) { // 获取当前日期加时间 // 效果是其LocalDate和LocalTime的合体,同时代表了日期和时间 使用系统时区 LocalDateTime now = LocalDateTime.now(); // 打印格式 2020-03-16T20:49:02.450 System.out.println(now); // 同样可以根据字符串解析为对象 其中T是必须的表示时间的开始 // 并且严格按照yyyy-MM-ddTHH:mm:ss的格式进行验证,需补0 // LocalDateTime parse = LocalDateTime.parse(\"2001-12-9T10:22:36\"); LocalDateTime parse = LocalDateTime.parse(\"2001-12-09T10:22:36\"); System.out.println(parse); // 根据指定的日期和时间创建对象 LocalDateTime of = LocalDateTime.of(2020, 2, 20, 15, 30,36); System.out.println(of); // 通过查看其 of 方法的实现发现其实使用了之前两个日期时间类的构造 // 上面创建方式和本方式创建对象一致 LocalDate localDate = LocalDate.of(2020, 2, 20); LocalTime localTime = LocalTime.of(15, 30, 36); // 该类的构造方法的是私有的,该方式是因为该类提供了静态的of方法,在方法内部使用其构造方法new的方式创建对象 LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime); // true System.out.println(of.isEqual(localDateTime)); // 同样LocalDate和LocalTime可以使用自身的 atXXXX 来进行组合返回一个完整的LocalTime对象 LocalDateTime localDateTime1 = localDate.atTime(localTime); LocalDateTime localDateTime2 = localTime.atDate(localDate); // 并且可以灵活转换 // LocalDate date = localDateTime1.toLocalDate(); // LocalTime time = localDateTime1.toLocalTime(); // 比较日期时间是否一致 System.out.println(localDateTime1.isEqual(localDateTime2)); } @Test public void demo(){ LocalDateTime now = LocalDateTime.now(); System.out.println(now); // withXXXX 用于修改为指定的日期或时间 // plusXXXX 用于将日期或时间和参数相加 // minusXXXX 用于将日期或时间减去相应的参数值 LocalDateTime withHour = now.withHour(2).plusMinutes(20).minusSeconds(5); System.out.println(withHour); } } DateTimeFormatter 在java8之前使用的SimpleDateFormat可能会出现线程安全的问题,而在Java8中新提供的DateTimeFormatter可以解决这个问题,该类也主用于日期时间的解析和格式化。这个类是不可变的和线程安全的。 public class DateTimeFormatterDemo { public static void main(String[] args) { // 按照格式进行相互转换 LocalDateTime now = LocalDateTime.of(2020,03,16,22,59,23); System.out.println(now); String format = now.format(DateTimeFormatter.BASIC_ISO_DATE); // 20200316 System.out.println(format); // 22:59:23 format = now.format(DateTimeFormatter.ISO_LOCAL_TIME); // 2020-03-16 System.out.println(format); LocalDate localDateParse = LocalDate.parse(\"20200316\", DateTimeFormatter.BASIC_ISO_DATE); // 2020-03-16 System.out.println(localDateParse); LocalTime localTimeParse = LocalTime.parse(\"22:59:23.017\", DateTimeFormatter.ISO_LOCAL_TIME); // 22:59:23.017 System.out.println(localTimeParse); } /** * 自定义格式 */ @Test public void demo(){ // 从模式创建的格式化程序可以根据需要多次使用，它是不可变的并且是线程安全的。 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\"); // 按照指定格式将日期格式化 String format = LocalDateTime.now().format(dateTimeFormatter); // 2020/03/16 System.out.println(format); // 根据指定的格式将字符串再转为对象 LocalDate parse = LocalDate.parse(format, dateTimeFormatter); // 2020-03-16 System.out.println(parse); // 根据给定字符串,创建匹配规则并转为时间对象 String time = \"18时12分40秒\"; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"HH时mm分ss秒\"); LocalTime localTime = LocalTime.parse(time, formatter); System.out.println(localTime); } } TemporalAdjusters java8之前的java.util包中的Date类,它提供了公开的修改时间的方法,因此可以轻松的修改时间 而在Java8中新的时间API,表示时间的类都是不可变的,类本身和变量都被final修饰,所以是不可变的,因此又提供了该类用于进行日期时间的复杂操作,但也正因为这些类都是不可变的所以使用该类产出的对象都是一个新的日期或时间对象 虽然没有直观的setXxxx方法,但是也提供了对应的withXxxx方法,和set方法功能一致,只不过同样是产出新的对象 import static java.time.temporal.TemporalAdjusters.*; public class TemporalAdjusterDemo { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); System.out.println(now); LocalDateTime with; // 根据ordinal的值 进行计算将日期调整为计算后的week with = now.with(dayOfWeekInMonth(-6,DayOfWeek.SUNDAY)); // 创建一个新的日期,将日期调整为该月份的第一天 with = now.with(firstDayOfMonth()); // 创建一个新的日期,将日期调整为下个月的第一天 with = now.with(firstDayOfNextMonth()); // 创建一个新的日期,将日期调整为当年的第一天 with = now.with(firstDayOfYear()); // 创建一个新的日期,将日期调整为下一年的第一天 with = now.with(firstDayOfNextYear()); // 创建一个新的日期,将日期调整为第一个指定的星期 with = now.with(firstInMonth(DayOfWeek.SUNDAY)); // 创建一个新的日期,将日期调整为当月的最后一天 with = now.with(lastDayOfMonth()); // 创建一个新的日期,将日期调整为当年的最后一天 with = now.with(lastDayOfYear()); // 创建一个新的日期,将日期调整为当月的最后一个指定的星期 with = now.with(lastInMonth(DayOfWeek.THURSDAY)); // 创建一个新的日期,将日期调整为下一周指定的星期 with = now.with(next(DayOfWeek.MONDAY)); // 创建一个新的日期,将日期调整为下一个指定的星期,如果当前星期和参数一致则直接返回 with = now.with(nextOrSame(DayOfWeek.THURSDAY)); // 创建一个新的日期,将日起调整为上一个指定的星期 with = now.with(previous(DayOfWeek.FRIDAY)); // 创建一个新的日期,将日期调整为上一个指定的星期,如果该日期的星期和参数一致则直接返回 with = now.with(previousOrSame(DayOfWeek.WEDNESDAY)); System.out.println(with); // false // 因为java.time中的日期时间类的成员变量都是final的也就是不可变的 // 所以with方法并不是修改而是创建新的对象 System.out.println(with == now); // 可以看到java.util包中中的日期类,提供了public公共的修改访问方法,在并发量大的情况下可能会出现问题 // Date date = new Date(); // date.setTime(); } @Test public void demo(){ LocalDateTime now = LocalDateTime.now(); // Period可以对日期进行操作 LocalDateTime with = now.with(t -> t.plus(Period.ofWeeks(1))); System.out.println(with); } } ZonedDateTime、Instant 前面的日期时间对象都是本地时间但没有时区信息 Instant是世界标准时间且不含时区信息 ZonedDateTime则可以配合ZoneId处理时区,本质是用Instant存储时间,在根据时区进行处理 public class ZoneRulesDemo { public static void main(String[] args) { // 获取内置的所有时区信息 value为 区域/城市 比如 Asia/Shanghai 亚洲/上海 ZoneId.SHORT_IDS.forEach((key,value) -> System.out.println(key+\"===\"+value)); // TimeZone是java8之前的时区对象,将其转为最新的时区对象并获取当前系统的时区 ZoneId aDefault = TimeZone.getDefault().toZoneId(); System.out.println(aDefault); LocalDateTime now = LocalDateTime.now(); // 将当前时区转为指定时区 ZoneId of = ZoneId.of(\"America/Chicago\"); System.out.println(LocalDateTime.ofInstant(now.atZone(ZoneId.systemDefault()).toInstant(),of)); System.out.println(LocalDateTime.ofInstant(Instant.now(),of)); } /** * https://blog.csdn.net/u012107143/article/details/78790378 * 表示时间的主要类: String LocalDateTime Instant ZonedDateTime */ @Test public void demo(){ // 2020-03-16T16:05:59.793Z T代表时间的开始 Z表示这是一个世界标准时间 +00:00 System.out.println(Instant.now()); // 2020-03-17T00:07:08.203 本地时间,不含时区信息的时间 System.out.println(LocalDateTime.now()); System.out.println(LocalDateTime.now(ZoneId.of(\"+00:00\"))); // 2020-03-17T00:07:08.203+08:00[Asia/Shanghai] 本地时间并且显示时区信息 System.out.println(ZonedDateTime.now()); System.out.println(ZonedDateTime.now(ZoneId.of(\"+00:00\"))); // 三个类构造对象的不同方式 // 使用毫秒从1970-01-01T00开始获得的一个实例 Instant 世界标准时间 Instant instant = Instant.ofEpochMilli(System.currentTimeMillis()); System.out.println(instant); LocalDateTime localDateTime = LocalDateTime.of(2020, 02, 20, 18, 30, 16); System.out.println(localDateTime); // 根据指定时区创建对象 ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.of(\"Africa/Cairo\")); // ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.systemDefault()); System.out.println(zonedDateTime); } /** * 其中String和LocalDateTime是等价的,两者可以通过DateTimeFormatter进行相互转换 */ @Test public void stringLocalDateTimeDemo(){ String dateTime = \"2020/02/20 18:30:36\"; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\"); LocalDateTime parse = LocalDateTime.parse(dateTime, formatter); System.out.println(parse); String format = parse.format(formatter); System.out.println(format); } /** * Instant和ZonedDateTime是等价的 */ @Test public void instantZonedDateTime(){ ZonedDateTime zonedDateTime1 = Instant.now().atZone(ZoneId.systemDefault()); ZonedDateTime zonedDateTime2 = Instant.now().atZone(ZoneId.of(\"America/Chicago\")); System.out.println(zonedDateTime1); System.out.println(zonedDateTime1.toInstant()); System.out.println(zonedDateTime1.toLocalDate()); System.out.println(Instant.now().atZone(ZoneId.of(\"+00:00\"))); System.out.println(zonedDateTime2); System.out.println(zonedDateTime2.toInstant()); System.out.println(zonedDateTime2.toLocalDate()); // 通过结果可以看出 根据系统时区和根据其他时区创建的ZonedDateTime对象内部的时间戳Instant和标准时间都是一致的 // 只不过加了时区之后,对时区进行了处理 // 相当于对Instant做了增强 /* 2020-03-17T01:02:56.253+08:00[Asia/Shanghai] 2020-03-16T17:02:56.253Z 2020-03-17 2020-03-16T17:02:56.334Z 2020-03-16T12:02:56.317-05:00[America/Chicago] 2020-03-16T17:02:56.317Z 2020-03-16 */ } @Test public void exchange(){ Instant instant = Instant.now(); LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault()); // 系统默认的时区就是该时区,另一种写法 ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, ZoneId.of(\"Asia/Shanghai\")); // LocalDateTime转为ZonedDateTime ZonedDateTime of = ZonedDateTime.of(localDateTime, ZoneId.systemDefault()); // ZonedDateTime转为LocalDateTime LocalDate localDate = zonedDateTime.toLocalDate(); Instant instant1 = zonedDateTime.toInstant(); System.out.println(instant1); // LocalDateTime转换Instant时需要指定时区,时区必须是时区对应的时间 Instant instant2 = localDateTime.toInstant(ZoneOffset.of(\"+08:00\")); System.out.println(instant2); } } 时间戳、时区 理解时间戳和时区 时间戳:指的是Unix时间戳,是一种时间的表示方式,在地球的每一个角落都是相同的,从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数 可以使用网站查询时间戳:http://tool.chinaz.com/Tools/unixtime.aspx 使用时间戳获取总秒数 @Test public void demo3(){ long epochSecond = Instant.now().getEpochSecond(); System.out.println(epochSecond); } 时区:时间戳在地球的任何位置都是相同的,但是相同的时间点会有不同的表达方式,就是时区的概念。比如我们在中国是白天,而在美国正是夜晚,但是我们过的时间都是一样的,这时便需要使用时区来相互转换获取对方时区的具体时间 @Test public void fun(){ // 获取所有jdk内置的时区信息 ZoneId.SHORT_IDS.forEach((e1,e2) -> System.out.println(e1+\"==\"+e2)); // 根据本地时区获取信息的时间 ZonedDateTime asiaShangha = ZonedDateTime.now(); // 根据指定的时区获取时间 这里使用的是美国纽约 ZonedDateTime americaNewYork = ZonedDateTime.ofInstant(Instant.now(), ZoneId.of(\"America/New_York\")); // 分别打印对方所在时区的具体时间 System.out.println(asiaShangha); System.out.println(americaNewYork); // 获取时间戳总秒数,可以看到是相同的 System.out.println(asiaShangha.toInstant().getEpochSecond()); System.out.println(americaNewYork.toInstant().getEpochSecond()); } 控制台打印信息 CTT==Asia/Shanghai ART==Africa/Cairo CNT==America/St_Johns PRT==America/Puerto_Rico PNT==America/Phoenix PLT==Asia/Karachi AST==America/Anchorage BST==Asia/Dhaka CST==America/Chicago EST==-05:00 HST==-10:00 JST==Asia/Tokyo IST==Asia/Kolkata AGT==America/Argentina/Buenos_Aires NST==Pacific/Auckland MST==-07:00 AET==Australia/Sydney BET==America/Sao_Paulo PST==America/Los_Angeles ACT==Australia/Darwin SST==Pacific/Guadalcanal VST==Asia/Ho_Chi_Minh CAT==Africa/Harare ECT==Europe/Paris EAT==Africa/Addis_Ababa IET==America/Indiana/Indianapolis MIT==Pacific/Apia NET==Asia/Yerevan 2020-03-18T11:15:09.033+08:00[Asia/Shanghai] 2020-03-17T23:15:09.034-04:00[America/New_York] 1584501309 1584501309 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"java/pattern/singleton.html":{"url":"java/pattern/singleton.html","title":"单例模式","keywords":"","body":"单例模式饿汉式懒汉式线程不安全线程安全双重校验锁单例模式 单例设计模式:属于创建型模式,提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类,该类负责创建自己的对象,同时确保只有单个对象被创建。主要解决一个全局使用的类进行频繁的创建于销毁,耗费大量内存的问题。 注意事项:单例类只能有一个实例,单例类必须自己创建自己的实例并可以提供给其他对象使用 饿汉式 这种方式的优点是其为线程安全的,没有加锁,执行效率稍高一些 缺点则是类加载时就初始化,浪费内存(比如有很多类使用的是单例模式,程序在启动时就会创建这些对象,而不管你是否用到了这些类,从而导致程序启动较慢) public class Singleton1 { // 将构造函数私有化,让外部无法轻易的创建其对象(new的方式) private Singleton1(){} // static修饰的变量属于类,随着类的加载而加载,只加载一次 private static Singleton1 instance = new Singleton1(); // 提供一个公开的访问接口,可以提供给其他对象使用 // 由于构造函数是私有化的,所以只能使用static关键字,可以被类直接调用 public static Singleton1 getInstance(){ return instance; } } 懒汉式 懒汉式则是为了解决饿汉式,较为浪费内存的情况,只有在需要的时候才会创建对象,但懒汉式也有其缺点,可能会出现线程安全问题 线程不安全 public class Singleton2 { // 单例模式私有构造函数是必须的 private Singleton2(){} // 同样提供一个类变量 private static Singleton2 instance; // 提供一个公开的访问方法,但其是会出现线程安全问题的 public static Singleton2 getInstance(){ // 假如有两条线程t1和t2,此时t1抢到了执行权,进行判断并且判断实例为null,准备创建对象赋值时,被t2抢断 // t2拿到执行权后顺利的创建完对象,此时t1又抢到了执行权,也去做创建对象并赋值的操作,便出现了创建出不同实例的情况 if (instance == null){ instance = new Singleton2(); } return instance; } } 线程安全 为了解决上面的问题,想到了使用synchronized关键字,将其改造为同步方法 public class Singleton3 { private Singleton3(){} private static Singleton3 instance; // 我们在方法上添加synchronized关键字,使其变为静态同步方法 // synchronized需要一个锁对象,在静态方法上的锁对象是类对象(在非静态方法上的锁对象是this,谁调用这个方法this就指向谁),一个类的类对象也只有一个,符合做锁对象的要求 // 为什么可以确定是类对象,还是因为static关键字,static修饰的方法和变量初始化在创建对象之前,此时还没有this public static synchronized Singleton3 getInstance(){ if (instance == null){ instance = new Singleton3(); } return instance; } } 双重校验锁 上面加了同步方法的懒汉式虽然是线程安全的,但是其执行效率会变慢,因为每次调用该方法都会等待上一个线程的锁,为了解决这个问题,我们可以使用同步代码块 public class Singleton4 { private Singleton4(){} private static Singleton4 instance; public static Singleton4 getInstance(){ // 在第一个懒汉式中得知,在此处可能会出现线程安全问题,所以我们把同步代码块加在这里 // 锁对象也就是当前的类对象,这样虽然是线程安全的,并且比上一个线程安全的懒汉式看起来执行效率会更高 // 但是每一条线程进来都会等待锁进行判断实例的存在,可以再做优化 synchronized (Singleton4.class){ if (instance == null){ instance = new Singleton4(); } } return instance; } } public class Singleton4 { private Singleton4(){} private static Singleton4 instance; public static Singleton4 getInstance(){ // 可以再同步代码块外面再加一层校验,这样其他线程不必等待锁进行判断,也保证了创建对象的安全性 if (instance == null){ synchronized (Singleton4.class){ if (instance == null){ instance = new Singleton4(); } } } return instance; } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-23 13:36:48 "},"java/pattern/proxy.html":{"url":"java/pattern/proxy.html","title":"代理模式","keywords":"","body":"代理模式静态代理JDK代理CGLIB动态代理总结资料代理模式 我们在学习Spring框架时,了解了其两个最大的优点就是IOC和AOP,其中的AOP用到的就是代理模式(动态代理)。在代理模式中一个类代表另一个类的功能,这种类型的设计模型属于结构型模式。 主要使用场景,当我们需要对对象中的方法进行增强时,为了不侵入原有的代码进行功能扩展,使方法的功能或者说职责更加清晰。 静态代理 该方式需要目标对象和代理对象要实现同一类接口,可以实现在不修改原有代码的基础上进行功能的扩展,但是如果有多个需要代理的类的对象或者接口中有大量方法需要实现,这就会需要创建很多的代理类并且进行实现,代码过于冗余。 // 需要被目标类和代理类实现的接口 public interface UserService { void update(); } // 目标类 public class UserServiceImpl implements UserService{ @Override public void update() { System.out.println(\"update\"); int i = 1/0; } } // 代理类 public class UserServiceProxy implements UserService{ // 在代理类的内部维护一个目标类的对象 private UserService target; public UserServiceProxy(UserService target){ this.target = target; } // 代理类和目标类实现了同一接口,并对方法实现重写 // 在代理类对象的方法中调用目标类对象的方法,从而对其进行增强 // 该方法模仿了一个事务的过程 @Override public void update() { System.out.println(\"start transaction\"); try { target.update(); } catch (Exception e) { System.out.println(\"rollback\"); return; } System.out.println(\"commit\"); } } // console start transaction update rollback JDK代理 jdk动态代理利用了java中的反射(主要涉及的类java.lang.reflect.Proxy),在运行时动态生成交由jvm进行处理,编译完成后不修改配置的话没有实际的class文件。目标类(被代理类)必须需要实现接口。 // 需要被目标类实现的接口 public interface UserService { void save(); void remove(); } // 目标类 public class UserServiceImpl implements UserService{ @Override public void save() { System.out.println(\"save\"); int i = 1/0; } @Override public void remove() { System.out.println(\"remove\"); } } // 创建一个类实现InvocationHandler接口,主要实现其invoke方法 public class MyProxy implements InvocationHandler { private Object target; public MyProxy(Object target){ this.target = target; } /** * @param proxy 方法被调用的代理实例 * @param method 被代理对象的方法 * @param args 方法的参数 * @return 运行结果 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"start transaction\"); Object result; try { result = method.invoke(target, args); } catch (Exception e) { System.out.println(\"rollback\"); return null; } System.out.println(\"commit\"); return result; } } @Test public void demo() throws Throwable { UserService target = new UserServiceImpl(); MyProxy myProxy = new MyProxy(target); // 使用Proxy和自实现的InvocationHandler接口,返回代理类对象 UserService proxyInstance = (UserService) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), myProxy); proxyInstance.save(); } CGLIB动态代理 cglib采用了非常底层的字节码技术为一个类创建子类,并在子类中对父类方法进行拦截。由于cglib是通过继承来实现代理的所以目标类不能是final的(被final修饰的类不能被继承),并且不会对类中的final方法进行代理(被final修饰的方法不能被重写) 需要导包 cglib cglib 3.2.5 // 可以不实现接口 public class UserService { public void save(){ System.out.println(\"save\"); } public void remove(){ System.out.println(\"remove\"); } } // 自定义方法拦截类 public class MyMethodInterceptor implements MethodInterceptor { /** * @param o 表示要进行增强的对象 * @param method 表示拦截的方法 * @param objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int-->Integer、long-Long、double-->Double * @param methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用 * @return 执行结果 * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\"before\"); // 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法 Object result = methodProxy.invokeSuper(o, objects); System.out.println(\"after\"); return result; } } public class MyTest { public static void main(String[] args) { MyMethodInterceptor myMethodInterceptor = new MyMethodInterceptor(); Enhancer enhancer = new Enhancer(); // 设置超类,即指目标类,cglib是通过继承实现的 enhancer.setSuperclass(UserService.class); // 传入自实现的方法拦截类 enhancer.setCallback(myMethodInterceptor); // 创建对象 UserService proxy = (UserService) enhancer.create(); proxy.save(); } } 还可以创建多个MethodInterceptor实现类结合CallbackFilter,进行选择性(不同的)增强 public class MyMethodInterceptor2 implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\"我是经过过滤器到达的增强\"); methodProxy.invokeSuper(o,objects); return null; } } public class UserServiceFilter implements CallbackFilter { @Override public int accept(Method method) { if (method.getName().equals(\"remove\")){ // 根据setCallbacks方法中传入的MethodInterceptor的实现类数组的索引 return 1; } return 0; } } public class MyTest { public static void main(String[] args) { MyMethodInterceptor myMethodInterceptor = new MyMethodInterceptor(); MyMethodInterceptor2 myMethodInterceptor2 = new MyMethodInterceptor2(); Enhancer enhancer = new Enhancer(); // 设置超类,即指目标类,cglib是通过继承实现的 enhancer.setSuperclass(UserService.class); // 传入自实现的方法拦截类 enhancer.setCallbacks(new Callback[]{myMethodInterceptor,myMethodInterceptor2}); enhancer.setCallbackFilter(new UserServiceFilter()); // 创建对象 UserService proxy = (UserService) enhancer.create(); proxy.save(); proxy.remove(); } } 总结 静态代理:实现较简单,目标类和代理类需要实现一致的接口(其实就是进行包装一下),有多个目标类需要增强就要创建多个代理类。 jdk动态代理:代理类只需要实现InvocationHandler接口,实现其invoke方法,在其内部对目标类进行调用和增强,目标类必须要实现一个接口。 cglib:解决了jdk动态代理目标类必须实现一个接口的问题,并且cglib更加强大。同时目标类和代理类无需实现接口,但是目标类不能是final的,需要被增强的方法不能是final的。 资料 https://juejin.im/post/5c1ca8df6fb9a049b347f55c#heading-8 https://segmentfault.com/a/1190000011291179 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-23 21:41:26 "},"java/thread/多线程入门.html":{"url":"java/thread/多线程入门.html","title":"多线程入门","keywords":"","body":"多线程进程与线程并行和并发jvm是不是多线程的入门案例创建多线程的几种方式继承Thread类实现Runnable接口实现Callable接口结合FutureTask类三种方式的比较线程名称多线程中的异常处理机制线程休眠守护线程线程优先级线程让步线程插入线程中断线程状态图多线程 进程与线程 进程:像QQ、微信、网易云音乐这些软件运行后就是一个进程。进程可以独立运行,进程有自己独立的内存空间,不与其他进程共享数据。一个进程可以包含1~N个线程 线程:线程是进程中的一个单元,一个子任务执行者,线程不能独立运行,必须依赖进程而运行,同一个进程中的线程可以共享数据。 并行和并发 并发:指在同一时间段内多个任务高速频繁切换执行 并行:指在同一时刻(间)内多个任务同时执行 jvm是不是多线程的 public class JvmThread { public static void main(String[] args) { for (int i = 0; i 从结果可以看出jvm至少启动了两个线程,一个是main一个是垃圾回收 入门案例 public class TestQuick { public static void main(String[] args) { // 使用匿名内部类的方式 new Thread(new Runnable() { @Override public void run() { for (int i = 0; i // 部分console main...0 Thread-0...0 main...1 Thread-0...1 Thread-0...2 Thread-0...3 Thread-0...4 Thread-0...5 Thread-0...6 Thread-0...7 main...2 Thread-0...8 main...3 Thread-0...9 创建多线程的几种方式 继承Thread类 public class MyThread extends Thread{ @Override public void run() { System.out.println(\"我是继承Thread类开启线程后执行的任务\"); } public static void main(String[] args) { MyThread myThread = new MyThread(); // 开启一个线程,并不是调用run方法 // 如果调用run方法就是交由main函数去调用,依次执行 myThread.start(); System.out.println(Thread.currentThread().getName()); } } 实现Runnable接口 public class MyRunnable implements Runnable{ @Override public void run() { System.out.println(\"我是实现Runnable接口开启线程后执行的任务\"); } public static void main(String[] args) { // 创建线程任务类 MyRunnable myRunnable = new MyRunnable(); // 将任务类对象传递到Thread的构造中并开启线程 Thread thread = new Thread(myRunnable); thread.start(); System.out.println(Thread.currentThread().getName()); } } 实现Callable接口结合FutureTask类 以上两种方式,开启线程后只能执行任务,拿不到执行任务的返回值,这种方式解决了这个问题 /** * 实现Callable接口,返回代表返回值的类型 */ public class MyCallable implements Callable { @Override public Integer call() throws Exception { System.out.println(\"我是实现Callable接口结合FutureTask开启线程后执行的任务\"); return 666; } public static void main(String[] args) throws Exception { // 创建任务类添加到FutureTask的构造中 MyCallable myCallable = new MyCallable(); FutureTask result = new FutureTask<>(myCallable); // 再将FutureTask添加到Thread的构造中开启线程 Thread thread = new Thread(result); thread.start(); // 打印主线程的名称 System.out.println(Thread.currentThread().getName()); // 获取自定义线程的返回值 System.out.println(result.get()); } } 三种方式的比较 首先这三种方式最后都需要通过Thread来间接或直接开启线程执行线程任务 继承Thread类(也实现了Runnable接口)的方式最简单,并且可以直接调用start()开启线程,但这种方式不宜扩展(也就是java中类的单继承多实现),实现Runnable接口和Callable接口可以解决这个问题 虽然实现Runnable接口可以解决日后有继承类的需求,但是如果我们需要拿到线程执行的任务的返回值,Runnable接口中run方法同样不支持,也便是实现Callable接口的好处,其提供了带返回值的call()方法 线程名称 设置获取线程名称 public class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"===执行任务\"); } public static void main(String[] args) { MyThread myThread = new MyThread(); // 使用构造设置名称 Thread thread = new Thread(myThread,\"自定义线程名称\"); // 使用方法设置名称 // thread.setName(\"123\"); thread.start(); // 获取当前线程的名称 System.out.println(Thread.currentThread().getName()+\"===主线程的名称\"); } } 多线程中的异常处理机制 public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i 从打印结果看,main线程出异常并不会影响自定义线程的执行。 同样自定义中如果有异常也不会影响main线程,可以得出jvm只会终止出异常的线程,并不会影响其他线程的执行 Exception in thread \"main\" 自定义线程==0 自定义线程==1 自定义线程==2 自定义线程==3 自定义线程==4 java.lang.ArithmeticException: / by zero at xyz.taoqz.threadexception.MyThread.main(MyThread.java:21) 线程休眠 调用Thread类的静态方法sleep(毫秒值),休眠只会让出CPU资源但不会让出锁资源 public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i 守护线程 setDaemon(boolean)设置一个线程为守护线程,该线程不会单独执行,当其他非守护线程都执行结束后,自动退出(相当于下象棋,老帅如果死了就结束了,守护线程就是守护老帅的) 效果:其他非守护线程执行结束后,守护线程并不会立即停止,会有一个缓冲期 public class MyDaemonThread { public static void main(String[] args) { Thread t1 = new Thread(){ @Override public void run() { for (int i = 0; i 线程优先级 效果不明显,默认优先级是5 t1.setPriority(1); // t1.setPriority(Thread.MAX_PRIORITY); 10 // t2.setPriority(10); // t2.setPriority(Thread.MIN_PRIORITY); 1 // t2.setPriority(Thread.NORM_PRIORITY); 5 线程让步 yield()让出cpu资源,也就是回到就绪状态(效果不明显,因为让步的线程还有可能被线程调度程序再次选中) Thread.yield(); 线程插入 join(),当前线程暂停,等待指定的线程执行结束后,当前线程再继续 join(int),等待指定的毫秒后继续 public class MyThreadJoin { public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 线程中断 interrupt():可以在t2线程中使用t1线程对象调用该方法,通知t1停止,t1可以调用isInterrupted()判断状态,如果为true,便接到了通知,可以选择中断或者继续执行。如果该线程处于终止状态或者被中断过,那么调用isInterrupted()依然返回false。 当t2通知t1终止,但t1本身调用wait、join、sleep等阻塞方法的时候,就会抛出一个异常,同时会清除被标记的死亡状态(也就是isInterrupted的值改为false),继续执行,当然也可以选择捕捉后终止运行 java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at xyz.taoqz.threadinterrupt.MyInterrupt2$1.run(MyInterrupt2.java:17) at java.lang.Thread.run(Thread.java:748) public class MyThreadInterrupt { public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 线程状态图 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-25 01:19:11 "},"java/thread/线程同步和通信.html":{"url":"java/thread/线程同步和通信.html","title":"线程同步和通信","keywords":"","body":"线程同步正在更新....案例定时器线程同步 进程之间不能共享数据,但是线程可以 如果多个线程操作同一个变量会引发安全问题,使用经典的卖票案例 正在更新.... 案例 定时器 public class MyTimer extends Thread{ // 获得输入的字符串转换后的时间,设置为成员变量供run()使用 private LocalDateTime dateTime; public MyTimer(LocalDateTime parse) { this.dateTime = parse; } // 主要执行的任务类,循环判断当前时间是否与输入时间相等 @Override public synchronized void run() { while (true){ // 如果输入时间在当前时间之后 if (dateTime.isAfter(LocalDateTime.now())){ // 相等 if (LocalDateTime.now().equals(dateTime)){ System.out.println(LocalDateTime.now()+\"该起床了!!!\"); return; } }else { System.out.println(\"您输入的时间不合法\"); return; } } } // 封装为 public static void timer(String time) { // 将输入的时间字符串按照指定的格式进行转换 LocalDateTime parse = LocalDateTime.parse(time, DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")); // 创建对象开启线程(定时器) MyTimer myTimer = new MyTimer(parse); myTimer.start(); } public static void main(String[] args) { MyTimer.timer(\"2020-03-24 18:24:30\"); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-25 01:25:02 "},"mysql/mysql基础.html":{"url":"mysql/mysql基础.html","title":"mysql基础","keywords":"","body":"数据库什么是数据库?什么是表、行、列?以及它们的关系?简单了解mysqlmysql中sql分类什么是SQL?DDL:数据库定义语言DML:数据库操作语言DQL:数据库查询语言DCL:数据库控制语言MySQL数据类型整数类型日期类型字符串、二进制文本类型使用数据处理函数数据库三范式数据库 什么是数据库? 数据库就是存储数据的仓库,数据库按照特定的格式将数据存储在磁盘文件中,用户可以对数据库中的数据进行增删改查操作 什么是表、行、列?以及它们的关系? 表是某种特定数据类型的结构化清单,如果把这张表想象为一张网格,网格中垂直的列为表列,水平则为表行。假如现在有一张顾客表,每一行则是一个顾客的信息,比如手机号,住址等,而列则是所有顾客的某种信息,比如所有的名称 简单了解mysql mysql也是一种DBMS(数据库管理系统),数据库软件。同时mysql拥有最多的使用者,这得益于它的许多优点,开源,性能好,支持事务,可信赖,简单使用等。 mysql在使用时默认是不分大小写的 登录 # 这几个参数分别为用户名 密码 ip 端口 mysql -uroot -p123 -hlocalhost -P3306 在输入sql命令时必须以;(分号)或者\\g作为结束 # 切换到指定库 use databaseName; #查看该库下所有表 show tables; # 查看表结构 show columns from tableName; # 查看表结构 describe book; # 更改字符集 set names 字符编码; 虽然在安装时指定了数据的编码为utf-8,但是windows默认编码为gbk,使用 set names gbk;便可看中文数据 set names gbk; --等同于下面三条,,将client,connection,result的编码一致 set character_set_client=gbk; set character_set_connection=gbk; set character_set_results=gbk; 查看mysql内部设置的编码 show variables like 'character%'; 通过查看表结构得到 Field:字段名称 Type:数据类型 Null:是否允许为null Key:键信息 Default:默认值 Extra:其他信息(auto_increment自增) 前面说到表中应该至少有一个主键保证每行数据的唯一性,但是如果我们手动给主键值,太麻烦也不太显示,auto_increment自增则可以解决这个问题,每新添加一行数据都会自动分配一个可用编号 mysql中sql分类 什么是SQL? sql是专门用来和数据通信的语言,也就是说可以用sql来操纵数据,但是sql并不是某个特定厂商专有的语言,不过大部分的关系型数据库都支持sql,不过不完全相同 DDL:数据库定义语言 用来定义数据库对象,也就是创建、修改、删除,数据库、表、列等 关键字:create alter drop truncate等 操作对象:数据库,表 特点:负责\"骨架\"操作,不操作数据 DDL之数据库常用操作 # 创建数据库,使用安装时指定的默认编码 create database name; # 指定字符编码创建 create database name character set utf-8(字符) # 查看所有数据库 show database; # 查看数据库的定义信息 show create database name; # 切换使用指定数据库 use databaseName; # 删除数据库 drop database name; DDL之表操作 常用数据类型 类型 用途 int 表示整数 float/double 表示小数 date/datetime 表示时间 char/varchar 表示字符串 # 创建表 create table 表名( 字段名 类型(长度) [约束], 字段名 类型(长度) [约束] ... ) # 查看数据库中所有表 show tables; # 查看表结构 desc 表名; # 修改表结构 # 添加列 alter table 表名 add 列名 类型(长度); # 修改表列类型长度及约束 alter table 表名 modify 表名 类型(长度); # 修改列名 alter table 表名 change 旧列名 新列名 类型(长度) [约束]; # 删除列 alter table 表名 drop 列名; # 修改表名 alter table 表名 rename to 新表名; # 修改表的字符集 alter table 表名 character set 字符集; # 删除表 drop table 表名; DML:数据库操作语言 用来对数据库中表的记录进行更新(插入/修改/删除数据也会涉及到DQL) 关键字:insert update delete等 操作对象:行数据 常用操作 插入 注意事项 值与字段必须对应,个数相同,类型相同 值的数据大小必须在字段的长度范围内 除了数值类型外,其他的字段类型的值必须使用引号括起(建议单引号) 如果插入空值,可以不写字段,或者插入null #向表中插入某些字段 insert into 表(字段1,字段2,字段3...) values(值1,值2,值3); #向表中插入所有字段,字段的顺序为创建表时的顺序 insert into 表 values(值1,值2,值3...) 更新 注意事项 列名的类型与修改的值要一致 修改值的时候不能超过最大长度 除了数值类型类型外,其他的字段类型的值必须使用引号括起 -- 更新所有记录的指定字段 update 表名 set 字段名=值,字段名=值,...; -- 更新符号条件记录的指定字段 update 表名 set 字段名=值,字段名=值,...where 条件; 删除 delete from 表名 [where 条件]; truncate table 表名; 两者的区别 两种方式都可删除表中所有记录 delete一条一条删除,不清空auto_increment记录数,效率低,可回滚; truncate直接将表删除,重新创建表,会重置auto_increment的值,重新开始,效率高,不可回滚 DQL:数据库查询语言 用来查询数据库中表的记录 关键字:select from where等 select [distinct] *| 列名,列名 from 表 where 条件 别名查询 使用关键字as,可省略 表别名:select * from 表名 [as] 别名; 列别名:select 列名 [as] 别名 from 表名; 排序 通过order by语句可以将查询后的结果进行排序,放置在select语句的最后 select * from 表名 order by 排序字段 asc|desc; asc 升序(默认) desc 降序 聚合 之前做的查询都是横向的,都是根据条件进行一行一行的判断,而是用聚合函数查询是纵向查询,对一列值的计算,然后返回一个单一的值,聚合函数会忽略空值 count(字段):统计指定列不为null的记录行数 sum(字段):计算指定列的数值和,如果指定列类型不是数值类型,那么计算结果为0 max(字段):计算指定列的最大值,如果指定列是字符串类型,那么使用字符串排序运算 min(字段):计算指定列的最小值,如果指定列是字符串类型,那么使用字符串排序运算 max(avg):计算指定列平均值,如果指定列不是数值类型,那么计算结果为0 分组 使用group by字句对查询信息进行分组,其中分组字段可写多个 select 字段1,字段2... from 表名 group by 分组字段 having 分组条件; having用于对分组后的数据进行过滤,与where类似 having与where的区别 where是在分组前对数据进行过滤,主要针对行,where后面不可使用分组函数(统计函数) having是在分组后对数据进行过滤,主要针对列,having后面可以使用分组函数 分页 在数据量大的情况下,需要对数据进行分页显示 select 字段1,字段2... from 表名 limit m,n; m:整数,代表从第几条索引!索引!索引!(0)开始,计算方式(当前页-1)*每页显示条数 n:整数,代表查询多少条数据 例如 select 子段1 from 表名 limit 0,5; 代表第一页,一页5条 条件查询 执行顺序 书写顺序 select 字段 from 表名 where 条件 group by 字段 having 条件 order by 字段 执行顺序 1.from 表名 2.where 条件 3.group by 字段 字段值相同的数据会划分成一组 4.having 条件 将每组分别进行一次运算 5.select 字段 把每组中的第一条数据取出来,合并成一张新伪表,展示指定字段 6.order by 字段 对新伪表进行最后的排序 DCL:数据库控制语言 用来进行用户管理、权限管理 MySQL数据类型 整数类型 在涉及金额时建议使用decimal(9,2)类型,前面的9代表整数的长度(9-2),后面的2代表小数的长度,,不够两位补0,超出小数点的范围进行四舍五入 日期类型 TIMESTAMP:时间戳,可以在java8新日期时间API中了解 字符串、二进制文本类型 使用数据处理函数 文本处理函数 日期时间处理函数 数值处理函数 重要的加减日期函数 select subdate(now(),interval '3 5' day_hour ); # 30天内的信息 select * from Student where bir >= now() and bir # 根据指定日期格式化 select date_format(now(),'%Y/%m/%d %H:%i:%s'); 格式 描述 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 数据库三范式 什么是范式 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 第一范式：数据库表中不能出现重复记录,每一列都是不可分割的原子数据项,同一列不能有多个值 例如：电话号码 - > 手机号 座机号 第二范式：一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。只要数据列中出现数据重复，就要把表拆分开来。(要求所有非主键字段完全依赖主键,不能产生部分依赖) 比如: 根据第一范式,表中记录不能重复,且需要主键,所以设置了联合主键有如下一张表 ,但是其中学生姓名依赖学生编号,教师姓名依赖教师编号,产生了部分依赖,所以需要将其拆分成两张表,另外还需新建一张表用来存储对应关系,经典的多对多关系 第三范式：在2NF基础上,非主键字段不能传递依赖于主键字段 例如这张表中确定主键学生编号,学生姓名依赖学生编号,班级名称依赖于班级编号,而班级编号依赖与学生编号,此时便产生了传递依赖的情况 需要将其拆分成两张表,一张学生表,一张班级表,在学生表中创建外键指向班级表中的主键班级编号,一对多 https://www.jianshu.com/p/3e97c2a1687b Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"mysql/mysql进阶.html":{"url":"mysql/mysql进阶.html","title":"mysql进阶","keywords":"","body":"约束主键约束主键的规则添加主键自动增长列注意事项联合主键非空约束唯一约束默认约束外键约束多表关系关联查询备份还原数据库约束 添加表约束的作用,是为了保证表中记录的有效以及完整性 约束分类 实体完整性:数据行约束,主键约束,唯一约束 域完整性:数据类型,默认约束,非空约束 引用完整性:外键约束 主键约束 表中的每行数据都应该有可以标识自己唯一的列。假如没有唯一的列或者说主键,更新或删除表中的特定行会很困难,没有安全的办法保证只涉及相关的行 主键的规则 primary key 每行都必须具有一个主键值 主键列不能为null,主键值必须唯一 添加主键 方式一:在创建表时,在字段后声明指定字段为主键 create table person( id int primary key , name varchar(5) ) 方式二:创建表时,在约束区域,声明指定字段为主键 create table person( id int , name varchar(5), primary key (id) ) 方式三:创建表后,修改表结构,指定字段为主键 create table person( id int , name varchar(5) ); alter table person add primary key (id); 删除主键:使用修改表结构的语句删除主键 alter table person drop primary key; 自动增长列 前面说主键的值在每一行都不能重复,从而保障数据的唯一性,如果我们手动去维护这个值将会很困难,也不现实。所以mysql为我们实现了这一点。 自增长列类型必须是整数型,并且一般为主键 添加自增长列 create table person( id int primary key auto_increment, name varchar(5) ); 设置自增后,在插入数据时,可以不为该列添加值,或者设置为null值 auto_increment默认从1开始,也可以修改起始值 alter table person auto_increment = 100; 注意事项 不更新主键列的值,不重复用主键列的值,不要使用可能会修改的值作为主键,虽然不是必须,但是尽量遵守 联合主键 联合主键也仅是一个主键 在复杂的情况下可以使用多个列作为主键,同样要求其字段值不能为null,而且不能重复(联合主键的多个列的值都相同) create table person( id int , name varchar(5), idCard varchar(50), primary key (id,name) ); 非空约束 非空约束not null强制列不接受null值,也就意味着使用非空约束的列始终包含值 create table person( id int not null , name varchar(5) not null , idCard varchar(50) ); 修改表结构 alter table person modify name varchar(5) not null ; 删除非空约束 alter table person modify name varchar(5); 唯一约束 unique约束唯一标识数据库表中的每条记录 unique和primary key约束都保证了列值的唯一性,primary key自动拥有unique约束 unique和primary key的区别,每个表中可以有多个唯一约束,但是主键只能有一个,唯一约束允许值为null(多个),而primary key则较为严格不允许值为null 添加唯一约束 方式一 create table person( id int , name varchar(5) unique , idCard varchar(50) ); 方式二 create table person( id int , name varchar(5) , idCard varchar(50), unique (name,idCard) ); 方式三 alter table person add unique (name); 默认约束 默认约束的作用是在添加数据时如果不指定值使用默认值 create table person( id int , name varchar(5) default 'zs', idCard varchar(50) ); alter table person modify name varchar(5) default 'zz'; 删除默认约束 alter table person modify name varchar(5); 外键约束 根据数据库的三范式中的第二范式,一张表中只能存储一种数据,如果有多种类型的数据需要拆分表 拆分表后需要建立关系,所以就有了外键,又分为主表和从表,在从表中建立外键指向主表的主键,从表外键的数据类型和长度必须和主表中一致 可以进行手动维护外键,不必建立强一致性的外键 多表关系 一对多:比如员工表和部门表,一个部门中有多个员工,而一个员工只属于一个部门,此时的部门便是一方,员工便是多方 多对多:比如学生表和课程表,一个学生可以选修多门课程,一门课程下又有多名学生,此时变为多对多的关系,需要建立一张中间表用来存储之前的关系 一对一:使用较少,因为一对一其实也可合成一张表 关联查询 两张表一张员工表,一张部门表,员工表中手动维护部门id CREATE TABLE `emp` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `age` int(11) DEFAULT NULL, `sex` varchar(255) DEFAULT NULL, `birthday` date DEFAULT NULL, `email` varchar(50) DEFAULT NULL, `phone` varchar(50) DEFAULT NULL, `dept_id` int(11) DEFAULT NULL, `position_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 CREATE TABLE `dept` ( `id` int(11) NOT NULL AUTO_INCREMENT, `dept_name` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 笛卡尔积 也叫交叉连接 # 会产生笛卡尔积,将所有的记录全部匹配一遍(也就是两张记录的乘积) select * from emp,dept; #符合条件的 select * from emp,dept where emp.dept_id = dept.id; 内连接 inner join # 两张表中同时符合条件的记录,才会显示内容 select * from emp,dept where emp.dept_id = dept.id; # 显示内连接 可以使用where和on进行条件筛选 select * from emp inner join dept where emp.dept_id = dept.id; select * from emp inner join dept on emp.dept_id = dept.id; select * from emp join dept on emp.dept_id = dept.id; 外连接 左外连接 left outer join = left join 左连接的结果集包括左表中的所有行,并且如果在匹配条件中左表的某行在右表中没有匹配行,则相关右表的列值都为null # 这条sql语句会报错,不能使用where进行条件过滤 select * from emp e left join dept d where e.dept_id = d.id; # 以下两条sql的执行结果是一致的 as name 是为表起别名(当关联查询时,表多的情况下可以选择使用),也可以省略as 关键字和outer关键字 select * from emp as e left outer join dept as d on e.dept_id = d.id; select * from emp e left join dept d on e.dept_id = d.id; 右外连接 right outer join = right join 右连接的结果集包括右表中所有的行,并且如果在匹配条件中右表的某行在左表中没有匹配行,则相关左表的列值都为null # 这条sql语句会报错,不能使用where进行条件过滤 select * from emp e right join dept d where e.dept_id = d.id; # 以下两条sql的执行结果是一致的 as name 是为表起别名(当关联查询时,表多的情况下可以选择使用),也可以省略as 关键字和outer关键字 select * from emp as e right outer join dept as d on e.dept_id = d.id; select * from emp e right join dept d on e.dept_id = d.id; union,union all 将多个select语句的结果组合到一个结果集中 # 效果是左连接和右连接的组合 select * from emp left join dept on emp.dept_id = dept.id union all select * from emp right join dept on emp.dept_id = dept.id; # 效果是先将两张表进行内连接,然后剩下的结果集分别是两张表中没有匹配的行 # 也就是达到了union all 去重的效果 select * from emp left join dept on emp.dept_id = dept.id union select * from emp right join dept on emp.dept_id = dept.id; 备份还原数据库 # 备份单个库 mysqldump -uroot -p --databases 数据库名 > d:\\pms.sql(文件保存位置) # 备份整个库 mysqldump -h 127.0.0.1 -P 3306 -u root --default-character-set=gbk -p --all-databases > d:\\dumpfile.sql # 还原数据库 mysql -uroot -p yuan Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"mysql/mysql事务.html":{"url":"mysql/mysql事务.html","title":"mysql事务","keywords":"","body":"事务ACIDmysql事务操作并发访问问题事务隔离级别示例读未提交读已提交不可重复读串行化事务 事务指的是逻辑上的一组操作,组成这组操作的各个单元要么全部成功,要么全部失败 事务的作用:保证一个事务在多次操作中,要么全部成功,要么全部失败(当程序出现异常时,可以将所在事务中的数据恢复到原来的状态) mysql中并非所有的存储引擎都支持事务,其中MyISAM和InnoDB是最为常用的两种引擎,而前者不支持事务后者支持,同时这也是mysql将其定为默认的存储引擎的重要原因 ACID InnoDB存储引擎中的事务完全支持ACID特性 原子性(Atomicity):原子性是指事务是一个不可分割的工作单位,事务中的操作,要么全部发生,要么不发生 一致性(consistency):事务前后的数据必须保持一致 隔离性(isolation):指在多个用户访问数据库时,一个用户的事务不能被其他用户的事务所干扰,多个并发事务之间数据要相互 隔离(即该事务提交前对其他事务都不可见,通常使用锁来实现) 持久性(durability):事务一旦提交,其结果就是永久性的,即使数据库发生故障崩溃而需要恢复时,也能保证提交后的数据都不会丢失(保证了应用的高可靠性,而并非高可用) mysql事务操作 sql语句 描述 start transaction; 开启事务 commit; 提交事务 rollback; 回滚事务 创建一张表 CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `money` double DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 insert into account(id,name,money) values (null,'张三',1000); insert into account(id,name,money) values (null,'李四',1000); mysql中有两种方式进行事务的管理 ​ 自动提交:mysql默认是自动提交的,及执行一条sql语句提交一次事务 ​ 手动提交:先开启事务,再提交 # 查看当前的提交方法,是否自动提交 0=OFF(否) 1=ON(是) show variables like '%commit%'; # 设置自动提交的参数为OFF set autocommit = 0; 假如现在有一个转账的需求 此时设置的是自动提交,将两条sql执行后会持久化到数据库中 update account set money = money - 100 where name = '张三'; update account set money = money + 100 where name = '李四'; 现在把自动提交改为手动提交 show variables like '%commit%'; set autocommit = 0; show variables like '%commit%'; # 开启事务并进行转账 start transaction ; update account set money = money - 100 where name = '张三'; update account set money = money + 100 where name = '李四'; 你会发现在数据库中没有做任何的改变,因为数据库还没有得到指令是提交还是回滚 # 回滚 rollback ; # 提交 commit ; 需要注意的是,在提交后是无法进行回滚的,因为数据已经磁盘中做了持久化,同样的回滚后,再次提交也是没有意义的,可以把这两条语句当做是事务的结束语句 并发访问问题 如果不考虑隔离性,事务存在几种并发访问问题 1.脏读:一个事务读到了另一个事务中未提交的数据。 例如: 当一个事务访问数据库并对数据进行了修改,但该事务还没有结束,也就是还没有完成提交。此时另一个事务中读取到了这条并未提交的数据,这条数据便是脏数据,依据脏数据所做的操作可能是不正确的 2.丢失数据:指在一个事务读取一个数据时,另外一个事务也访问了这个数据,第一个事务中修改了这个数据后,第二个事务也修改了这个数据,这样第一个事务的修改结果就被丢失 例如: 事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 3.不可重复读:一个事务读到了另一个事务已经提交(update)的数据。引发另一个事务中多次查询结果不一致。 例如: 第一个事务读取到了一条数据,但并未结束事务。此时第二个事务对该条数据进行了修改并提交。当第一个事务再次读取这条数据时,发现可能和第一次读取的数据不一致,因此被称为不可重复读。 4.虚读/幻读:一个事务读取到了另一个事务已经提交(insert)的数据。导致另一个事务,在事务中多次查询的结果不一致。 例如: 幻读和不可重复读类似。一个事务读取了几行数据,接着另一个事务插入了一些数据并进行了提交,此时第一个事务会发现多了一些原本不存在的数据,就好像发生了幻觉一样,所以被称为幻读。 不可重复读和幻读的区别: 不可重复读的重点在修改,幻读的重点在与新增或者删除 事务隔离级别 读未提交(READ-UNCOMMITTED):最低的隔离级别,允许读取没有提交的数据,可能会导致脏读,幻读和不可重复读 读已提交(READ-COMMITTED):允许事务读取已经提交的数据,可以防止脏读,但是幻读和不可重复读仍有可能发生 可重复读(REPEATABLE-READ):对同一字段的读取结果是一致的,除非事务本身对数据进行修改,可以阻止脏读和不可重复读,但幻度仍有可能发生。 串行化(SERIALIZABLE):最高的隔离级别,完全服从ACID的隔离级别,所有事务依次执行,可以防止脏读,幻读和不可重复读 安全和性能对比 隔离级别的安全和性能成反比,越安全的性能越低 安全性:serializable > repeatable read > read committed > read uncommitted 性能:serializable MySQL InnoDB存储引擎默认支持的隔离级别是可重复读(repeatable-read) 示例 # 两条命令都适用于查看当前的事务隔离级别 show variables like '%isolation%'; select @@tx_isolation; 可更改设置事务的隔离级别 # 其中session可替换为global session代表当前连接 global代表全局 # 设置全局的隔离级别后需要重新连接 set session transaction isolation level read uncommitted; set session transaction isolation level read committed ; set session transaction isolation level repeatable read ; set session transaction isolation level serializable ; 创建一张表 CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `money` double DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 # 示例每次演示开始的时候都将数据恢复到这个状态 insert into account(id,name,money) values (null,'张三',1000); insert into account(id,name,money) values (null,'李四',1000); 读未提交 开启两个连接(窗口),将隔离级别设置为读未提交(read uncommitted) 读已提交 将左右的隔离级别都设置为读已提交(read committed) 不可重复读 左右设置隔离级别为可重复读(repeatable read) 保证了一个事务中读取同一条数据是一致的 前面我们说可重复读可能会出现幻读,也就是一个事务中会读到另一个事务插入并提交的数据,我们从上图看到并未发生这种情况,这不是和串行化没啥区别了吗,上网查资料 https://juejin.im/post/5c9040e95188252d92095a9e 进行验证 总结:从这两张图中的执行结果来看,可重复读其实并未完全解决了幻读的问题,只是解决了读数据情况下的幻读问题,对于修改依旧会出现幻读问题。 串行化 串行化:可以看到串行化对事务的要求很高,即使是进行了一次查询的操作,也必须提交,否则其他事务只能在等待状态,等待其他事务结束后再执行 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"mysql/varchar和char.html":{"url":"mysql/varchar和char.html","title":"varchar和char","keywords":"","body":"varchar最多能存储多少个字符?char和varchar的区别? https://learn.blog.csdn.net/article/details/103341778 https://zhuanlan.zhihu.com/p/86259276 首先char最多可以存储255个字符,而不是255个字节,可以使用例子做验证 首先创建一个表,指定字符长度为256 CREATE TABLE 'luck' ( 'content' char(256) ); # Column length too big for column 'content' (max = 255); use BLOB or TEXT instead # 报错提示最大为255,那我们把它修改为255并可以创建成功 # 接下来验证255是最大字节数还是最大字符数 # 首先测试用的mysql使用的utf-8编码,英文字符占一个字节,中文占3个字节 # 在分别插入255个英文字符和中文字符后都没有报错并添加成功,两者再多添加一个都会报错,可以得知255为char存储的最大字符数 进一步验证 再使用命令查看插入255个字符后所占字节的长度 select content,char_length(content),length(content) from luck; 分别是插入255个中文和255个英文字符所得的字符长度和字节长度,可以看到中文的使用了765个字节,是因为使用的是 utf-8编码,一个中文字符会占用3个字节(gbk中中文占用2个字节) 通过搜索在查看mysql技术内幕一书后看到,在mysql4.1版本开始,char(n)中的n指的是字符的长度,而不是之前版本的字节长度,在不同的字符集下,char类型列内部存储的可能不是定长的数据 也就是说在InnoDB存储引擎下使用多字节的字符编码,会把char类型视为变长字符类型,因此可以认为在多字节字符集的情况下,char和varchar的实际行存储基本是没有区别的 那varchar呢,首先可以根据上图了解到varchar最多存储65535个字节,那在创建一个表测试一下 CREATE TABLE luck ( content varchar(65535) ); # Column length too big for column 'content' (max = 21845); use BLOB or TEXT instead # 他会提示最大可存储21845个字符,可以确定varchar中填写的参数也是字符数量,只不过有总字节数的限制 # 那我们把varchar中的字符数改为varchar(21845) CREATE TABLE luck ( content varchar(21845) ); # Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs 运行后,可以看到还是提示过大,这是为什么,我们先把varchar的字符数调到varchar(21844),会发现表创建成功了,这是为什么 因为varchar类型(可变长字段)在计算可存储的字符数有一些条件 在mysql5.1中默认将记录保存为Compact行格式 # 查看表所用的行格式 SHOW TABLE STATUS LIKE 'luck' 可以看到Compact行格式下,不仅会记录真实的数据,还会记录一些记录的信息 计算可用字符数有一个公式:(最大行大小(65535) - null标识列占用字节数 - 长度标识字节数) / 单个字符所在字符集占用字节数 其中的null标识列便是null值列表,每8个允许为null的列会占用一个字节,每行共享 其中的长度标识则是变长字段长度列表,如果该可变字段允许存储的最大字节数(字符数量x指定编码下一个字符占用的字节数)超过255字节并且真实存储的字节数超过127字节,则使用2个字节,否则使用1个字节 有了这些条件,我们来算一下为什么提示说的21845也不行,首先我们使用的是utf-8编码,也就是一个字符会占用1~3个字节,假如存储的全是中文则为21845x3=65535,正好等于65535,前面我们说到一条记录不止有真实的数据,还有记录的额外信息,如果加上这些额外信息占用的字节65535就不够用了,所以也就超出了范围 有了这些前提条件,我们可以通过公式得知,假设该可变字段存储的最大字节数超过了255,并且真实存储的字节数也超过了127个字节,因为要把情况想到最极端长度标识字节数为2个字节,则得出最大的字符数为 (65535-1(默认创建的列是允许为空的,只有一个字段)-2(长度标识字节数))/3(utf8编码) = 21844 尝试着创建表 CREATE TABLE luck ( content varchar(21844) ); # completed in 12 ms # 创建成功 前面说到的最大行大小65535又是什么意思呢 指的是表中所有的字段加起来的总字节数不能超过65536 CREATE TABLE luck ( content varchar(21843), name varchar(1) ); # Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs 我们使用21844可以成功创建一张表,但现在分开创建却又创建不了表是什么原因呢,再套一下公式 (21843+1)x3+1+2+1=65536 我们来解析一下为什么是这样 首先(21843+1)x3表示了最多可以存储的字节数,这个我们可以从上面使用21844成功创建表得知 +1则表示记录的null列值列表,由于是行字段共享的空间,所以还是占一个字节 +2则表示列varchar(21843)的长度标识字节数 +1则是varchar(1)的长度标识字节数 所以加起来超过了总行大小,我们再来验证一下null值列表记录所占的空间是否共享 把这两个字段都设置为非空 CREATE TABLE luck( content varchar(21843) not null , name varchar(1) not null ); # completed in 16 ms 运行成功 所以我们可以得知null值列表所占的字节数是所有列共享的,同时也就证明了每条记录的长度标识字节数并不共享空间 有遗留的问题(未解决),char如果采⽤变⻓字符集时,该列占⽤的字节数也会被加到变⻓字段⻓度列表,按照这个说法name char(1)应该执行失败 # 运行失败 create table luck( content varchar(21843), name varchar(1) ); # 运行成功 create table luck( content varchar(21843), name char(1) ); 2020.03.20查看官方文档解决 char和varchar的区别 官方资料 https://dev.mysql.com/doc/refman/5.7/en/char.html https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html https://dev.mysql.com/doc/refman/5.7/en/string-type-syntax.html https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html 其他非官方资料 https://blog.csdn.net/Gane_Cheng/article/details/52316408 总结: 在mysql5.0版本以上char和varchar中的参数都是字符数,但是char有固定长度限制0-255,在创建表时可以不指定,默认为1,char在存储值时会用空格填充到指定的长度,当char的值被检索到时,删除那些用来填充的空格 而varchar列中的值是可变长度的字符串,创建表时必须指定长度,长度可以指定到0-65535(其中65535字节是最大行大小,所有列共享),其最多可以存储的字符数和其所在编码有关 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"linux/Linux环境下安装jdk和maven.html":{"url":"linux/Linux环境下安装jdk和maven.html","title":"安装jdk及maven","keywords":"","body":"环境: Ubuntu18.04 jdk1.8 maven3.6.0 将jdk和maven的linux版本的压缩包上传或下载到服务器中 首先进入root: sudo -i 解压: tar zxvf ****.tar.gz 如果需要移动到另一个文件夹中: mv 需要移动的文件文件名 要移动到的文件夹地址 解压后删除原压缩包: rm -rf 文件名 配置环境变量: vi /etc/profile 输入i进入编辑模式即insert添加以下代码 export JAVA_HOME=/usr/local/java/jdk1.8.0_141 为具体的安装位置 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH export M2_HOME=/usr/local/maven/apache-maven-3.6.0 为具体的安装位置 export PATH=${M2_HOME}/bin:$PATH 编辑完成后 按 esc 退出编辑模式再输入 :wq 保存后退出 使修改后的配置文件生效 source /etc/profile 检验是否安装成功 java -version 查看java版本 mvn -v 查看maven版本 可能出现的问题: vi ll 等命令不能使用可能是环境变量编辑有问题,输入以下命令解决 export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"linux/Linux远程管理.html":{"url":"linux/Linux远程管理.html","title":"Linux远程管理","keywords":"","body":"使用SSH连接工具XShll连接服务器 ​ 环境:谷歌云服务器,CentOS 7或者Ubuntu Server 18.04 LTS ​ 使用账号密码的方式 ​ 步骤: 1.切换到root角色 sudo -i 2.修改SSH配置文件 vi /etc/ssh/sshd_config 3.给root用户设置密码 passwd root 4.重启SSH服务 service sshd restart ​ Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring","keywords":"","body":"Springspring使用事务自定义配置Spring ​ context包提供了IOC容器功能 ​ IOC就是一个大的Map集合,key就是name,value就是对象 XML方式 public class XmlTest { @Test public void demo(){ ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = classPathXmlApplicationContext.getBean(\"user\"); System.out.println(user); } } 注解方式 // 使用注解方式的配置类 @Configuration public class SpringConfig { // 可以自定义name,默认是方法名 @Bean public User getUser(){ return new User(); } } public class AnnoTest { @Test public void demo(){ AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); User user = (User) app.getBean(\"getUser\"); System.out.println(user); // 根据类获取该类在容器中的name String[] beanNamesForType = app.getBeanNamesForType(User.class); // 获取容器中所有的name String[] names = app.getBeanDefinitionNames(); } } @ComponentScan ​ 该注解写在配置类用于扫描其他其他包中的组件@Controller @Service @Repository 这三个组件最顶层是@Component ​ 默认的name是类名首字母小写 ​ 通过该注解扫描得到的Bean和在配置类中使用@Bean注解得到的Bean是一个级别的 // 扫描时进行包含过滤,过滤类型默认为注解,classes的值则是最后包含的组件 // 需要将默认的过滤方式禁用 false // FilterType 常用类型还有自定义 也就是指定哪些类 ASSIGNABLE_TYPE // useDefaultFilters的作用是 是否开启扫描其他组件默认为true 包含时设置为false,排除某个类型时为true @Configuration @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}) },useDefaultFilters = false) // public class SpringConfig { } 主要属性 value：指定要扫描的package； includeFilters=Filter[]：指定只包含的组件 excludeFilters=Filter[]：指定需要排除的组件； useDefaultFilters=true/false：指定是否需要使用Spring默认的扫描规则：被@Component, @Repository, @Service, @Controller或者已经声明过@Component自定义注解标记的组件； 在过滤规则Filter中： FilterType：指定过滤规则，支持的过滤规则有 ANNOTATION：按照注解规则，过滤被指定注解标记的类； ASSIGNABLE_TYPE：按照给定的类型； ASPECTJ：按照ASPECTJ表达式； REGEX：按照正则表达式 CUSTOM：自定义规则； value：指定在该规则下过滤的表达式； 自定义一个扫描过滤类TypeFilter 过滤类: public class CustomTypeFilter implements TypeFilter { /** * 读取到当前正在扫描类的信息 * @param metadataReader * 可以获取到其他任何类的信息 * @param metadataReaderFactory * @return * @throws IOException */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { // 获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); // 获取当前正在扫描的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); // 获取当前类路径 Resource resource = metadataReader.getResource(); System.out.println(classMetadata.getClassName()); // 可以在此处进行判断,根据类信息进行过滤 return false; } } 配置类: @Configuration @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { // 将过滤类型改为CUSTOM自定义,classes的值为自定义的过滤类 @ComponentScan.Filter(type = FilterType.CUSTOM,classes ={CustomTypeFilter.class}) },useDefaultFilters = false) public class SpringConfig { } ​ @ComponentScans // (可以声明多个@ComponentScan) @ComponentScans({@ComponentScan(\"xyz.taoqz\"), @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {CustomTypeFilter.class}) },useDefaultFilters = false) }) public class SpringConfig { } @Scope作用域 @Configuration public class SpringConfig { // 无论是使用@Bean还是其他组件的注解,默认都是单例的 @Bean /** * 更改作用域 * singleton: 单实例,IOC容器启动时会调用方法创建对象并放到IOC容器中,以后获取时拿的是同一个对象 * prototype: 多实例,IOC容器启动时并不会调用方法创建对象,而是每次使用时用方法创建对象 * request: 一个请求一个实例 * session: 同一个会话一个实例 */ @Scope(\"PROTOTYPE\") public User getUser(){ return new User(); } } @Lazy懒加载 ​ 懒加载:主要针对单例Bean在容器启动时创建对象,设置懒加载后,容器启动后不再创建对象,但是可以在容器中获取其beanname,在第一次使用时才会创建对象初始化 ​ 如何使用懒加载? ​ 在@Bean注解或者其他组件上添加@Lazy注解 ​ 代码示例: @Configuration public class SpringConfig { @Bean @Lazy public User getUser(){ System.out.println(\"向容器中添加对象\"); return new User(); } } public class LazyTest { @Test public void fun(){ AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); System.out.println(\"容器创建完成\"); app.getBean(\"getUser\"); } } console: 容器创建完成 向容器中添加对象 使用懒加载后,会先创建容器,然后在获取Bean时才会向容器中添加对象并获得 @Conditional条件注册Bean ​ @Conditional(Class [] value()) ​ 写在类上表示该类或者该配置类下所有Bean必须符合条件才会注册,和@Bean一起写在方法上表示该方法返回值能否注册 ​ 该注解的参数是一个Condition的实现类,实现其方法,可以判断Bean满足需求时进行注册 public class MyCondition implements Condition { /** * 判断条件可以使用的上下文(环境0 * @param context * 注解的信息 * @param metadata * @return */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 可以在此处进行逻辑判断 返回true时Bean实例才会注入到容器中 return false; } } @Import注册Bean ​ @Import(Class [] value()) : 参数时要注册的Bean的class数组 回顾注册Bean的几种常用的方式 ​ 1.在配置中使用@Bean的方式将方法的返回值注册到容器中,通常是使用第三方类库时使用使用组件加包扫描的方式,一般用于自定义 ​ 2.组件注解:@Component @Controller @Service @Repository ​ 包扫描:@ComponentScan(组件注解所在的包) ​ 此方法优先级高于Import方式使用@Import注解 ​ 3.使用@Import方式注册的Bean其name是类全路径(包名+类名) ​ 回顾使用其他方式时的name(没有指定名称的情况下) ​ @Bean : 方法名 ​ 组件 : 类首字母小写 ​ 4.使用FactoryBean 下方有解释 ImportSelector自定义注册Bean // 在配置类中添加 @Import(value = {MyImportSelector.class}) public class MyImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { // 返回需要注册到容器中的Bean的全类名数组 return new String[0]; } } ImportBeanDefinitionRegistrar手动注册Bean // 在配置类中添加 // @Import(value = {MyImportBeanDefinitionRegistrar.class}) public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { /** * 当前类的注解信息 * @param importingClassMetadata * BeanDefinition注册类 * 把所有需要添加到容器中的Bean加入 * @param registry */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // 该方法可以判断容器中是否有指定name的Bean registry.containsBeanDefinition(\"\"); // 使用该方式注册Bean时,需要手动给出Bean的信息 Spring提供了RootBeanDefinition类 // 调用注册Bean的方法手动将Bean的name 和 信息注册到容器中 // IDEA中双击Shift键 搜索DefaultListableBeanFactory 类 会调用该类中的registerBeanDefinition将Bean注册到容器中 RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Animal.class); registry.registerBeanDefinition(\"animal\",rootBeanDefinition); } } FactoryBean ​ 如果想创建一个工厂类,用来灵活的创建对象并且想要交由Spring管理,可以使用该类 ​ 需要注意的是getBean时获取的对象并不是Factory本身,而是其getObject()方法的返回值返回的具体类型 ​ 想要获取该类对象在getBean()中的beanname参数前加&,底层在获取对象时会先判断beanname是否以&开头 ​ 使用方式:实现改接口,并且重写方法,将该类注入到容器中 Object getObject() : 该方法则为实际返回的对象 Class getObjectType() : 对象的类型 boolean isSingleton() : 表示对象注入容器时是否单例 ​ Bean的声明周期 ​ 创建 : 构造方法 ​ 初始化 : 指定的初始化方法 ​ 销毁 : 指定的销毁方法 ​ 会在容器关闭或移除对象时执行 ​ 创建和初始化会在容器创建完成前 自定义初始化销毁方法 ​ xml方式 ​ 注解方式1 @Bean(initMethod = \"初始化方法名\",destroyMethod = \"销毁方法名\") public Person person(){ return new Person(); } ​ 注解方式2 ​ 属于JDK的注解 ​ @PostConstruct : 初始化方法 ​ @PreDestroy : 销毁方法 @Component public class Person { public Person() { System.out.println(\"创建Person\"); } // 对象创建并赋值后调用 @PostConstruct public void init(){ System.out.println(\"Person 初始化\"); } // 容器移除对象调用 @PreDestroy public void destory(){ System.out.println(\"Person销毁\"); } } ​ spring 提供的接口 ​ InitializingBean, DisposableBean : 实现该接口完成init和destroy ​ 注意:只有单实例在容器创建时才会执行Bean的创建和初始化,并添加到容器中 ​ 多实例只有在获取Bean时才会执行 BeanPostProcessor接口 ​ 实现该接口可以在对象创建完成后的初始化方法前后进行增强 ​ spring底层有很多实现该接口的类(处理器),功能包括bean的赋值,注入其他组件,生命周期注解功能等 @Value 赋值 ​ 1.普通赋值,直接在组件的成员变量上声明该注解并且赋值(字符串),同时支持springEL表达式完成计算 ​ 例如 @Value(\"#{1*3}\") 在获取时便可得到该表达式的结果 ​ 2.使用.properties文件+@PropertySource(文件名数组)注解 ​ @Value(\"${属性名在文件中的key}\") ​ 在配置类上声明@PropertySource(value = {\"文件名\"}) AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); // 获取环境 ConfigurableEnvironment environment = app.getEnvironment(); // 获取所有配置文件 MutablePropertySources propertySources = environment.getPropertySources(); for (PropertySource propertySource : propertySources) { System.out.println(\"获取每一个配置文件名称\"+propertySource.getName()); System.out.println(\"获取每一个文件中的所有的属性及属性值\"+propertySource.getSource()); System.out.println(\"获取指定属性名称的属性值 没有则为null\"+propertySource.getProperty(\"name\")); } 关于自动装配 @Autowired ​ @Autowired默认根据变量名作为beanname获取,如果没有则根据类型查找,@Autowired本身不能根据beanname指定 获取容器中的实例对象,需要配合使用@Qualifier(beanname) ​ required属性 ​ 属性值为true表示注入的时候，容器中该bean必须存在，否则就会注入失败。 ​ 属性值为false：表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错 @Resource ​ jdk提供的@Resource(name = beanname)注解可以指定名称,默认根据变量名作为beanname获取,如果没有则根据类型查找,不支持required,不支持优先级 @Primary ​ 设置获取bean时的优先级,可以在类上添加,也可以配合@Bean使用 ​ 使用@Autowired注解进行依赖注入时便会使用声明该注解的实例,@Resource不会起作用 ​ 比如一个接口有两个实现类,都会被扫描进容器,但是在使用接口进行注入时会报错,如果给 其中一个实现类添加优先级,会解决该问题并且优先使用该实现类 ​ @Inject ​ 是Java JSR330的规范,和@Autowired功能类似,支持@Primary优先级,区别是没有required属性 javax.inject javax.inject 1 ​ 如果@Bean的方法名或者name相同于类首字母小写或者注解中的beanname会优先使用 @Bean产生的实例此效果三种注解相同 如果同时声明了@Qualifier(beanname1)+@Autowired和@Primary+@Bean(beanname2):会使用beanname1 注入顺序 **@Qualifier > 优先级 > 变量名(同名@Bean优先) > 类型** AOP ​ 面向切面编程(底层使用动态代理) ​ 在程序运行期间动态,在不修改源码的基础上，对已有方法进行增强。 ​ 使用aop需要的依赖 org.springframework spring-aspects 5.1.8.RELEASE ​ 相关术语: ​ Target(目标对象):被增强方法的所属对象 ​ Joinpoint(连接点):目标方法可增强的位置 ​ Pointcut(切入点):实际被增强的方法 ​ Advice(通知/增强):对切入点增强的位置及方法 ​ Aspect(切面):切入点的通知的结合() ​ Proxy(代理):一个类被AOP织入增强后,会产生一个结果代理类 相关注解: 注解 描述 @Aspect 把当前类声明成切面类 @Before 把当前方法看成是前置通知 @AfterReturning 把当前方法看成是返回通知,需要方法正常返回。 @AfterThrowing 把当前方法看成是异常通知,方法参数可以拿到 @After 把当前方法看成是后置(最终)通知,,无论是否出现异常都会执行 @Around 把当前方法看成是环绕通知 @Pointcut 定义方法声明该注解添加切入点表达式,可以直接引用该方法作为表达式,相当于提取 切入点表达式: //切入点表达式：execution后小括号中寻找要增强方法的表达式 // @Before(\"execution(public void com.czxy.demo03.*.save())\") //某个包下的所有类用* // @Before(\"execution(void com.czxy.demo03.*.save())\") //访问权限可以省略 // @Before(\"execution(* com.czxy.demo03.*.save())\") //任意返回值 // @Before(\"execution(* *.*.*.*.save())\") //任意包 // @Before(\"execution(* com..*.save())\") //当前包下的任意包 // @Before(\"execution(* com..*.*())\") //任意方法名称 // @Before(\"execution(* com..*.*(*))\") //任意方法参数必须有 // @Before(\"execution(* com..*.*(..))\") //任意方法任意参数均可 // @Before(\"execution(* *..*.*(..))\") //项目中所有方法 ​ 基本使用步骤: ​ 1.导入spring aop 的相关依赖 ​ 2.声明一个切面类 添加@Aspect @Component 注解 ​ 3.在切面类中编写增强方法,并添加相关通知注解以及所需切入点 ​ 4.在配置类中添加@EnableAspectJAutoProxy 注解开启切面 注意事项: ​ 关于@Around 注解的使用 ​ 声明该注解后方法会默认有一个JoinPoint/ProceedingJoinPoint形参 ​ 将joinpoint强转为proceedingJoinPoint,并调用其pjp.proceed();方法 ​ 在该方法调用前执行的就是前置通知,之后则是后置通知 ​ 可以使用ty{}catch()finally{}做出异常通知和最终通知的效果 @Around(\"execution(public void com.czxy.demo03.OrderDao.save())\") public void myAround(JoinPoint joinPoint,ProceedingJoinPoint proceedingJoinPoint) { //获取目标对象 Object target = joinPoint.getTarget(); System.out.println(target); //获取切点方法 Signature signature = joinPoint.getSignature(); System.out.println(signature); //将joinpoint强转为proceedingJoinPoint ProceedingJoinPoint pjp = (ProceedingJoinPoint)joinPoint; try { System.out.println(\"之前？\"); pjp.proceed(); System.out.println(\"之后？\"); } catch (Throwable throwable) { System.out.println(\"异常出现啦！\"); throwable.printStackTrace(); } finally { System.out.println(\"最终执行的！\"); } } ​ 关于@Pointcut的使用 //设置公共切点，可以方便其他增强使用，这里bf方法与ar方法使用了该公共切点 @Pointcut(需要提取的切入点的表达式) private void myPointcut(){ } @Before(\"切面类.myPointcut()\") // @AfterReturning(\"myPointcut()\") public void bf() { System.out.println(\"增强\"); } 切面类示例代码 //日志切面类 @Aspect public class LogAspects { @Pointcut(\"execution(public int com.enjoy.cap10.aop.Calculator.*(..))\") public void pointCut(){}; //@before代表在目标方法执行前切入, 并指定在哪个方法前切入 @Before(\"pointCut()\") public void logStart(JoinPoint joinPoint){ System.out.println(joinPoint.getSignature().getName()+\"除法运行....参数列表是:{\"+ Arrays.asList(joinPoint.getArgs())+\"}\"); } @After(\"pointCut()\") public void logEnd(JoinPoint joinPoint){ System.out.println(joinPoint.getSignature().getName()+\"除法结束......\"); } @AfterReturning(value=\"pointCut()\",returning=\"result\") public void logReturn(Object result){ System.out.println(\"除法正常返回......运行结果是:{\"+result+\"}\"); } // @AfterThrowing(value=\"pointCut()\",throwing=\"exception\") public void logException(Exception exception){ System.out.println(\"运行异常......异常信息是:{\"+exception+\"}\"); } @Around(\"pointCut()\") public Object Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{ System.out.println(\"@Arount:执行目标方法之前...\"); Object obj = proceedingJoinPoint.proceed();//相当于开始调div地 System.out.println(\"@Arount:执行目标方法之后...\"); return obj; } } 执行顺序 ​ @Around之前 > @Before > 切入点(目标方法) > @Around之后(如抛出异常不执行) > @After > @AfterThrowing(程序抛出异常) > @AfterReturning(成功返回,如抛出异常不执行) ​ 什么是声明式事务? ​ 以方法为单位,进行事务控制,抛出异常,事务回滚 ​ 最小的执行单位为方法,决定执行成败通过是否抛出异常来判断,抛出异常即执行失败 spring使用事务 ​ 导入相关依赖: mysql mysql-connector-java 5.1.47 com.alibaba druid 1.1.10 org.springframework spring-jdbc 5.1.8.RELEASE ​ 配置类 package xyz.taoqz.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; /** * @author :almostTao * @date :Created in 2019/9/7 15:13 */ @Configuration @ComponentScan(\"xyz.taoqz\") // 开启事务 配合@Transactional注解以及事务管理器使用 @EnableTransactionManagement public class SpringConfig { /** * 配置数据源 * @return */ @Bean public DataSource dataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUsername(\"root\"); druidDataSource.setPassword(\"123\"); druidDataSource.setUrl(\"jdbc:mysql:///spring_day08_shiwu\"); druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); return druidDataSource; } /** * 实现简单的增删改查 * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ return new JdbcTemplate(dataSource); } /** * 事务管理器 * @param dataSource * @return */ @Bean public DataSourceTransactionManager txManager(DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } } ​ dao依赖注入 @Autowired private JdbcTemplate jdbcTemplate; ​ @Transactional ​ 添加在方法上,表示该方法有事务效果 ​ 添加在类上,表示该类中所有方法都有事务 自定义配置 应该实现WebMvcConfigurer接口还是继承WebMvcConfigurerAdapter类,该类是接口的一个实现类.为了解决需要单独配置其 中一项而需要实现接口中的所有方法而产生,但在spring5之后该接口中的方法定义为default,可以选择重写方法,因此推荐使用实 现WebMvcConfigurer接口+@EnableWebMvc的方式 https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-config-enable ​ FactoryBean和BeanFactory的区别 ​ FactoryBean:将java实例注入到容器中 ​ BeanFactroy:从容器中获取实例化后的Bean Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"spring/SpringMVC.html":{"url":"spring/SpringMVC.html","title":"SpringMVC","keywords":"","body":"1.SpringMVC是什么:2.视图解析器:3.参数绑定:3.1.注意事项(重要)3.2.@RequestParam3.3.数组绑定3.4.集合类型:4.多路径映射/请求方法限定/窄化路径:4.1多路径映射:4.2请求方法限定(也是该注解的一个参数)4.3窄化路径:5. @PathVaraible注解的使用:6.Controller方法返回值以及跳转方式:7.异常处理器:8.图片上传:9.JSON数据交互:10.拦截器:11.序列化12.@RequestBody注意事项1.SpringMVC是什么: ​ Spring web mvc是表现层的框架,它是Spring框架的一部分 ​ 执行流程:客户端发送请求,springMVC的前端控制器DispatcherServlet接收并分配请求到对应的Controller执行对应的 方法,方法会返回视图,DispatherServlet解析视图,返回客户端进行渲染 2.视图解析器: ​ 视图:简单理解为浏览器向用户展示的界面 ​ 为什么使用? ​ 浏览器想要展示页面需要有一个请求的地址,拿到路径,但路径通常会在一个文件夹中,而文件夹可能会有多层,所 以SpringMVC中的视图解析器,可以帮我们减少一些重复的代码,把绝对路径可以写成我们的逻辑路径 ​ 需要在配置类中添加:用户在返回视图时,会经过该解析器,帮我们拼接字符串 ​ 配置类继承WebMvcConfigurerAdapter,注意spring5后一律推荐使用实现WebMvcConfigurer接口 @Bean public InternalResourceViewResolver viewResolver(){ InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); // 这是视图的前缀 viewResolver.setPrefix(\"/\"); // 这是视图的后缀 viewResolver.setSuffix(\".jsp\"); return viewResolver; } // properties 方式配置 spring.mvc.view.prefix= spring.mvc.view.suffix= 3.参数绑定: 3.1.注意事项(重要) ​ 其中前台的name必须和属性值名称一致,使用set方法赋值 ​ 其中方法的参数类型如果是基本数据类型推荐使用包装类型,因为基本数据类型不能为null,如果请求中没有改参数,会抛异常 3.2.@RequestParam ​ 作用:当请求参数的名称与方法参数名称不一致时,可以使用该注解标记对应关系 ​ 该注解中的参数: ​ name = \"对应的在前台的name名称\":与方法中的参数名对应 ​ required:表示是否必须有该参数有两个值,,默认为false ​ defaultValue:表示如果前台没有传递该参数时的默认值 ​ 引用数据类型的映射(POJO): ​ 在方法参数声明一个对象变量,请求时如果name和对象中的属性值一致,会自动注入到该对象中 ​ 简单说就是在对象中又有其他对象: ​ 在前台传递参数时,参数名称为该对象的名称再点属性 ​ 例子: 两个javaBean @Data public class CartItem { private Item item; private Integer number; private Double price; } @Data public class Item { private String name; private Double price; } 前台要提交的表单 Controller层处理,及控制台输出 3.3.数组绑定 ​ 前台表单传递一个相同name的一组数据,在方法的参数中写一个数组类型进行赋值,其中数组的名称 也要和前台name的名称相同 ​ 示例: // 数据:[\"1\",\"2\"] @PostMapping(\"/deleteMore\") public ResponseEntity deleteMore(@RequestBody String[] ids){} ​ // 请求路径 http://localhost:8080/emp/demo?arr=1&arr=2 @GetMapping(\"/demo\") public void fun(String[] arr){System.out.println(Arrays.toString(arr));} 3.4.集合类型: ​ 如果在方法参数中直接写集合类型是赋值不了的,需要使用数组或者在Bean中添加一个集合属性进行赋 值,如果需要给指定索引赋值,在name中指定索引即可 ​ 例子:前台传递表单方式 在上面的基础之上CartItem类中添加了一个集合属性 ​ ​ 前台数据传递的方式以及后台打印结果 4.多路径映射/请求方法限定/窄化路径: 4.1多路径映射: ​ @RequestMapping:请求路径映射 ​ 常用的参数: ​ value:\"指定访问的路径\"可以多个{\"路径1\",\"路径2\"} ​ headers :指定请求头中的参数 **params** :你可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。也就是 请求时的不同参数,调用的方法也会不同 @RequestMapping(value = \"/hello.action\",params = {\"id=10\"}) public String fun(String id){ System.out.println(id); return \"index\"; } @RequestMapping(value = \"/hello.action\",params = {\"id=20\"}) public String fun2(String id){ System.out.println(id); return \"index\"; } 4.2请求方法限定(也是该注解的一个参数) ​ method:指定请求的类型,也可以是数组 ​ method = {RequestMethod.GET,RequestMethod.POST} 4.3窄化路径: ​ 在类上添加相当于设置请求的前缀 ​ 在方法上添加,设置方法对应的请求路径 5. @PathVaraible注解的使用: ​ @RequestMapping 注解可以同 @PathVaraible 注解一起使用，用来处理动态的 URI ​ 将 @PathVaraible注解写到方法的参数前,对应方法中的参数,可以将URL中的对应的位置的值赋值到变量中,还可以使用正则表达式 @RequestMapping(value = \"/fetch/{id}.action\", method = RequestMethod.GET) public String getDynamicUriValue(HttpServletRequest request, @PathVariable(\"id\") String id) { System.out.println(\"ID is \" + id); return \"index\"; } ​ 如果设置参数不是必须的,需要有对应的路径映射 // required 设置参数为非必须项 @GetMapping({\"/path/{id}\",\"/path\"}) public void fun(@PathVariable(required = false) Integer id){ System.out.println(id); } 6.Controller方法返回值以及跳转方式: ​ 返回值为ModelAndView:创建ModelAndView对象,或者在方法形参中给出,可以在构造方法中直接给(返回的页面,存在域中的名称,存在域中的数据),或者分别使用addObject(name,value),setViewName(地址),会经过视图解析器 ​ 返回值为String:在方法的形参上添加Model,使用addAttribute()存储数据,返回值写地址 ​ 还可以使用 return \"redirect:tao.jsp\"; ​ return \"forward:tao.jsp\"; ​ 这两种方法存储的域都是request(想要存储到别的域中,可以使用原生) ​ 返回值为void使用方式和BaseServlet时一样,并且不会经过SpringMVC中的视图解析器 ​ 想要重定向或请求转发,在字符串中分别拼接redirect:和forward:,MVC会帮我们解析返回值,并在底层调用不同的方法 7.异常处理器: ​ SpringMVC异常处理机制: ​ 系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由 异常处理器进行异常处理。springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。 具体代码实现: ​ 创建一个自己的异常类,继承Exception ​ 定义统一异常处理器类:实现HandlerExceptionResolver接口并交由spring管理,重写方法 ​ @Component public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) { //统一处理异常 CustomException customException = null; // 如果是自定义异常直接类型转换赋值,并显示错误信息 // 如果不是创建自定义异常,提示未知错误 if(ex instanceof CustomException){ customException = (CustomException) ex; } else { customException = new CustomException(\"系统错误，请与系统管理 员联系！\"); } //设置数据 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"message\", customException.getMessage()); modelAndView.setViewName(\"WEB-INF/error\"); return modelAndView; } } 8.图片上传: ​ 在写具体代码时,先了解一下表单的一个属性 ​ enctype:该属性有三个属性值 ​ application/x-www-form-urlencoded:默认值,请求方式为get时,会将表单中的数据以键值对的方式加到url后面中间用?分隔,为post时,浏览器把form数据封装到http body中，然后发送到服务器 ​ text/plain：表单以纯文本形式进行编码 ​ multipart/form-data：当上传的含有非文本数据时,设置为该属性值,将表单数据变成二进制数据进行上传,这时使用request是获取不到表单响应的值的 ​ 在了解这点后,看具体上传图片的代码: ​ 在配置类中添加文件上传解析器: ​ 需要导入commons-io和commons-fileupload依赖 ​ @Bean public CommonsMultipartResolver multipartResolver[1] (){ CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(); // 设置所有的上传文件的总大小 10M multipartResolver.setMaxInMemorySize(10*1024*1024); // 设置单个文件上传的大小 4M multipartResolver.setMaxUploadSize(4*1024*1024); multipartResolver.setDefaultEncoding(\"utf-8\"); return multipartResolver; } 注解方式: spring.servlet.multipart.max-file-size= 文件大小 spring.servlet.multipart.max-request-size= 请求大小 Controller中写方法接受表单数据,需要设置一个参数MultipartFile表示文件上传对象,其他参数可以正常获取 ​ 该类常用方法: 方法名 描述 String getOriginalFilename() 获得原始上传文件名 transferTo(File file) 将上传文件转换到一个指定的文件中 String getContentType() 获取文件MIME类型，如image/pjpeg、text/plain等 String getName() 获取表单中文件组件的名字 ​ 直接写一个数组(没试过) ​ 如果是多文件上传,可以写一个VO类,里面添加一个成员变量List MultipartFiles 9.JSON数据交互: ​ 需要导入的依赖: com.fasterxml.jackson.core jackson-databind 2.9.7 ​ 前端发送json格式的数据,如果对应的Controller方法中的对象或者变量名相同可以直接封装赋值 ​ 后台想要把数据返回到前台页面显示,需要在配置类上添加@EnableWebMvc开启配置 ​ 有两种方式: ​ 1.在类上添加@Controller在方法返回值前加@ResponseBody ​ 2.直接在类上添加@RestController,因为该注解包含上面两个注解 10.拦截器: ​ 自定义拦截器需要实现HandlerInterceptor接口重写其方法 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 afterCompletion方法是在JSP执行后执行 request或者response不能再跳转页面了 使用配置类配置拦截器: ​ 配置类继承WebMvcConfigurerAdapter ​ 重写方法: @Override public void addInterceptors(InterceptorRegistry registry) { // 添加拦截器 InterceptorRegistration interceptorRegistration1 = registry.addInterceptor(myInterceptor1); InterceptorRegistration interceptorRegistration2 = registry.addInterceptor(myInterceptor2); interceptorRegistration1.addPathPatterns(\"/**\"); interceptorRegistration2.addPathPatterns(\"/**\"); } ​ 多个拦截器执行流程: ​ 会先按顺序执行preHandle方法,在Controller方法执行完成并且在jsp视图执行前反顺序执行postHandle方法,然后 在返回视图,在返回视图完成后在反顺序执行afterCompletion方法 11.序列化 @JsonInclude注解的使用 有时前台获取数据时,数据中有为null或者\"\"空字符串的字段,为了解决不必要的麻烦,可以在实体类的字段上添加该注解 @JsonInclude(JsonInclude.Include.NON_NULL) // 字段的值为空时跳过序列化 @JsonInclude(JsonInclude.Include.NON_EMPTY)// 包含上面注解,同时字段值为空字符时跳过序列化 12.@RequestBody 配合post请求使用 该注解主要作用用于解析请求体中的数据 如果不添加该注解,那么获取形参的数据为null // 不添加注解 @PostMapping public void fun(String student){ System.out.println(student); } // 请求体中的数据 {\"sname\":\"taoqz\"} // 控制台输出 console : null // 添加注解 @PostMapping public void fun(@RequestBody String student){ System.out.println(student); } // 请求体中的数据 {\"sname\":\"taoqz\"} // 控制台输出 会将数据当做字符串解析赋值 console : {\"sname\":\"taoqz\"} ​ 传递对象 ​ 只需将参数设置为需要的对象,mvc会将请求中的数据自动封装到对象中,前提是请求体中的字段与实体类中的属性名称一致 @PostMapping public void fun(@RequestBody Student student){ System.out.println(student); } // 请求体中数据 { \"sname\":\"taoqz\", \"address\":\"北京\" } // 控制台输出 Student(sid=null, sname=taoqz, address=北京, teachers=null) ​ 结合@RequestParam使用 ​ @RequestBody注解只能使用一次,如果有特殊需要可以结合@RequestParam使用 @PostMapping(\"/test\") public void add(@RequestBody Student student, @RequestParam(\"arr\") String[] arr){ System.out.println(student); System.out.println(Arrays.toString(arr)); } // 请求路径 mvc会将路径中相同名称的参数封装到数组中 http://localhost:8080/test/zz?arr=1&arr=2 // 请求体 自动封装到对象中 { \"sname\": \"zs\", \"address\": \"江苏省南京市\" } // 控制台输出 student: Student(sid=null, sname=zs, address=江苏省南京市, teachers=null) arr : [1, 2] 注意事项 ​ 请求: http://localhost:8090/user?ids=1&ids=2 ​ 接收数组参数 @DeleteMapping public void fun(Integer[] ids){ System.out.println(Arrays.toString(ids)); } ​ 将参数转为集合 // 也可以使用请求: http://localhost:8090/user?ids=1,2 @DeleteMapping public void fun(@RequestParam List ids){ ids.forEach(System.out::println); } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"spring/SpringBoot.html":{"url":"spring/SpringBoot.html","title":"SpringBoot","keywords":"","body":"什么是SpringBoot?项目结构:创建webapp目录,以及使用jsp热部署webjars读取配置文件数据日期格式转换静态文件mysql驱动包 8.x 修改时区使用hikari连接池设置虚拟路径什么是SpringBoot? ​ 简化了Spring项目的搭建和开发过程,可以整合其他框架,简单,快速,快变 项目结构: ​ springboot项目启动后会自动扫描与其在同一目录下的文件夹 创建webapp目录,以及使用jsp ​ 需要添加依赖 javax.servlet jstl org.apache.tomcat.embed tomcat-embed-jasper provided ​ 创建webapp目录应该与Java和resources目录同级 ​ 标记为web目录:Modules --> 点击项目下的Web,将webapp路径添加到下图 热部署 ​ 需要的依赖: org.springframework.boot spring-boot-devtools ​ properties: #开启热部署 spring.devtools.restart.enabled=true #设置重启文件目录 spring.devtools.restart.additional-paths=src/main/java #页面不加载缓存，修改即时生效 spring.thymeleaf.cache=false ​ idea需要的配置: webjars ​ WebJars可以让大家 以Jar 包的形式来使用前端的各种框架、组件。 ​ WebJars 是将客户端（浏览器）资源（JavaScript，Css等）打成 Jar 包文件，以对资源进行统一依赖管理。WebJars 的 Jar 包部署在 Maven 中央仓库上,可以让我们对前端资源也以jar包的方式进行依赖管理 ​ 通过查看mvc的自动配置类可以看到前端资源配置的虚拟路径和映射路径 ​ 引入时,在src创建与pom文件中组件名称相同的空文件夹 webjars/artifactId/version ​ 例如 : src/webjars/jquery/3.3.1 ​ 官网:https://www.webjars.org/ ​ 所需依赖: org.webjars webjars-locator-core org.webjars jquery 3.3.1 ​ 测试访问路径:http://localhost:8080/webjars/jquery/3.3.1/jquery.js ​ 对应在jsp中引用: 读取配置文件数据 ​ @propertySource : 指定配置文件 ​ @ConfigurationProperties : 指定配置文件中属性的前缀 ​ @Value(\"${配置文件中的属性}\") 配置文件 application.properties server.port=8080 user.username=zzz @Component @ConfigurationProperties(prefix = \"user\") @PropertySource(value = \"classpath:application.properties\") public class User { private String username; public String getUsername() { return username; } public void setUsername(String username) { System.out.println(\"通过set方法赋值\"); this.username = username; } @RestController @RequestMapping(\"/hello\") public class HelloController { @Autowired private User user; @Value(\"user.username\") private String username; @GetMapping(\"/user\") public User getUser(){ return user; } @GetMapping(\"/username\") public String getUserName(){ return user.getUsername(); } } 日期格式转换 ​ 前台传递后台按照指定格式接收: ​ 方式一:在bean属性上添加注解 ​ @DateTimeFormat(pattern = \"\") ​ 方式二:在application.properties文件中添加 ​ spring.mvc.date-format=yyyy-MM-dd HH:mm:ss ​ 后台返回给前台json时的data自定义格式字符串: ​ 方式一:在bean属性上添加注解 ​ @JsonFormat(pattern=\"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\") ​ 方式二:在application.properties文件中添加 ​ spring.jackson.time-zone=GMT+8 ​ spring.jackson.date-format=yyyy-MM-dd HH:mm:ss 静态文件 ​ 阅读源码可以看到WebMvcAutoConfiguration 类中addResourceHandlers方法 去读ResourceProperties类中的属性 其中将默认的值赋值给了它,共有四个默认值,其优先级跟下图声明顺序一样 这几个文件夹都是在resources文件夹下的 classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ mvc添加该路径方便我们创建webapp目录 还可以添加webapp,在idea中添加该目录需要在project settings -- > models 选中项目的web 有两栏添加第一个提那家web.xml路径,第二个添加webapp路径,如果jsp访问不到 如下配置,别忘记添加依赖 自定义方式: ​ 使用配置文件: ​ 配置文件第一行代表添加一个静态资源文件夹路径,如果没有把默认的配置加上会覆盖默认的设置 ​ 同时使用自定义和默认的,用英文逗号隔开即可,前面的优先级高 ​ 使用java配置类: ​ 实现WebMvcConfigurer接口重写addResourceHandlers,可以达到相同效果 ​ 映射resources下的文件夹或文件以classpath:开头 classpath:/ 代表resources根目录 ​ 映射磁盘下的文件以file:开头 ,其中盘符写绝对路径,盘符后的 冒号 可写可不写 ​ 例如 : file:D:/temp/upload/ ​ file:D/temp/upload/ ​ 使用webapp目录,把js文件放在其根目录下,在webapp根目录和WEB-INF的jsp都可以从所在包直接引用 ​ 注意事项:这两种方式都会覆盖其默认配置,也就是说只配置了自己想要的路径,其默认的便会失效 ​ 关于前端引入可以在webjars中查看 ​ 参考博客 ​ https://www.jianshu.com/p/d40ee98b84b5 ​ https://www.cnblogs.com/sxdcgaq8080/p/7833400.html ​ 江南一点雨 mysql驱动包 8.x 修改时区 spring.datasource.url=jdbc:mysql://localhost:3306/study?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC 使用hikari连接池 导入该启动器,如果不配置其他连接池默认使用hikariCP作为连接池 org.springframework.boot spring-boot-starter-jdbc application.properties 关于该连接池的配置 #数据源配置 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/数据库?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC spring.datasource.username=账号 spring.datasource.password=密码 #连接池配置 #最小空闲连接数 spring.datasource.hikari.minimum-idle=5 #池中最大连接数,包括闲置和使用的连接 spring.datasource.hikari.maximum-pool-size=15 #自动提交从池中返回的连接 spring.datasource.hikari.auto-commit=true #连接允许在池中闲置的最长时间 spring.datasource.hikari.idle-timeout=30000 #连接池的用户定义名称，主要出现在日志记录 spring.datasource.hikari.pool-name=hikariCP #此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟 spring.datasource.hikari.max-lifetime=1800000 # 数据库连接超时时间,默认30秒，即30000 spring.datasource.hikari.connection-timeout=30000 spring.datasource.hikari.connection-test-query=SELECT 1 #打印sql日志 #mybatis.mapper-locations=classpath:mapper/*.xml #将数据转换为指定格式+时区返回 #spring.jackson.time-zone=GMT+8 #spring.jackson.date-format=yyyy-MM-dd #将接收的数据以指定格式存储 #spring.mvc.date-format=yyyy-MM-dd #开启热部署 spring.devtools.restart.enabled=true #设置重启文件目录 spring.devtools.restart.additional-paths=src/main/java #页面热部署 #spring.thymeleaf.cache=false 设置虚拟路径 添加配置类 @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { // 前面是访问路径 后面是文件实际存在的路径 registry.addResourceHandler(\"/z/**\").addResourceLocations(\"file:F://code/\"); } } 或者在配置文件中添加 #url访问的请求路径 spring.mvc.static-path-pattern=/zz/** #真实路径 spring.resources.static-locations=file:F://code/ Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"microservice/微服务概述.html":{"url":"microservice/微服务概述.html","title":"微服务阶段","keywords":"","body":"SpringCloud微服务的特点优点缺点SpringCloud SpringCloud是微服务的一种实现,属于Spring旗下的项目之一,集成了很多其他优秀的流行框架,由于其团队的可靠性以及功能的强大,SpringCloud成为最火的微服务的实现方式 ​ 其中SpringCloud又有两种解决方案 ​ Spring Cloud Netflix ​ 该项目进入维护期,意味着没有新功能的添加,只进行bug修复 ​ Spring Cloud Alibaba: learning..... maven坐标 com.alibaba.cloud spring-cloud-alibaba-dependencies 2.1.0.RELEASE pom import 微服务的特点 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 独立：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 Docker部署服务 简单理解就是之前的每一个单体应用都可以称之为服务,举个例子,一个刚上线的小型商城项目,起初的用户量访问量很少,使用单体架构完全可以应对,但一旦用户访问量增多时,服务器或者数据库承受不了那么多的访问量,服务器会出现宕机,为了解决很多类似的情况,便有了微服务这种思想,将项目改造成微服务架构,针对访问量较多的模块可以让其占用更大的资源 优点 解决了复杂问题,可以将一个庞大的单体应用程序拆解成一套服务,虽然功能数量不变,但应用程序已经被拆解成可管理的块或者服务,每个服务提供相对单一的功能,更容易理解和维护 每个服务可以进行单独部署,并且可以根据该服务的所需来调配资源,避免资源浪费 缺点 使项目整体变得更加复杂,服务间的通信也变得麻烦 由于服务有自己独立的数据库,需要解决数据间的同步 测试会变得相对麻烦,一个服务或者模块会依赖其他的模块,进行相互调用,所以必须还要启动其依赖的服务 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"microservice/netflix/Zuul.html":{"url":"microservice/netflix/Zuul.html","title":"Zuul","keywords":"","body":"Zuul什么是Zuul为什么使用依赖注解配置路径映射规则过滤器跨域其他Zuul 什么是Zuul Zuul是从设备和网站到Netflix流应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul旨在实现动态路由，监视，弹性和安全性。它还可以根据需要将请求路由到多个Amazon Auto Scaling组。 为什么使用 Netflix API流量的数量和多样性有时会导致生产问题迅速出现而没有警告。我们需要一个允许我们快速改变行为以对这些情况做出反应的系统。 Zuul使用了各种不同类型的过滤器，这使我们能够快速灵活地将功能应用于边缘服务。这些过滤器帮助我们执行以下功能： 身份验证和安全性-识别每个资源的身份验证要求，并拒绝不满足要求的请求。 见解和监控-在边缘跟踪有意义的数据和统计信息，以便为我们提供准确的生产视图。 动态路由-根据需要将请求动态路由到不同的后端群集。 压力测试-逐渐增加到群集的流量以评估性能。 减载-为每种类型的请求分配容量，并丢弃超出限制的请求。 静态响应处理-直接在边缘构建一些响应，而不是将其转发到内部集群 多区域弹性-在AWS区域之间路由请求，以多样化我们的ELB使用并将我们的优势拉近我们的成员 依赖 org.springframework.cloud spring-cloud-starter-netflix-zuul org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import 注解 @EnableZuulProxy // 开启网关功能 @EnableEurekaClient // 开启eureka客户端服务 配置 # 将服务注册到Eureka,并且拉取其他服务 eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:8083/eureka fetch-registry: true # 是否拉取其他服务,默认true instance: prefer-ip-address: true ip-address: 127.0.0.1 路径映射规则 指定url访问 zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 # 访问/user-service/**时会请求 http://127.0.0.1:8081/ url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 指定服务名 zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 # 使用Eureka,通过服务名访问,并且会利用Ribbon的负载均衡 service-id: user-service # 指定服务名称 简化 路由名称往往和服务名一样,因此可以简化成如下,或者直接选择不配置,也会默认根据此规则发送请求,路由名称对应服务名称 zuul: prefix: /api # 添加路由前缀,可选项 routes: user-service: /user-service/** # 这里是映射路径 过滤器 ​ 和之前在servlet时学的过滤器功能类似 ​ 自定义过滤器 ​ 自定义需要实现类ZuulFilter,以下是其最重要的四个方法 public abstract class ZuulFilter implements IZuulFilter{ abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter } shouldFilter：返回一个Boolean`值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 示例 import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import com.netflix.zuul.exception.ZuulException; import io.jsonwebtoken.Claims; import org.springframework.stereotype.Component; import xyz.taoqz.utils.JWTUtil; import javax.servlet.http.HttpServletRequest; /** * 鉴权 */ @Component public class JWTFilter extends ZuulFilter { @Override public String filterType() { return \"pre\"; } @Override public int filterOrder() { return 1; } @Override public boolean shouldFilter() { return true; } /** * 编写权限过滤的核心业务： * 主要任务：确认是否放行 * 根据URL确认是否放行 * 有些URL是需要登陆之后才能访问，有些URL不需要登陆就可以访问 * 如果需要登陆的URL，需要获取token，并且解析token，成功了，就放行，不成功，就拦截 */ @Override public Object run() throws ZuulException { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); if (request.getRequestURI().contains(\"/login\")){ return null; } String token = request.getHeader(\"authorization\"); // 结合了JWT使用 if (token != null && !(\"\").equals(token.trim())){ Claims example0102 = JWTUtil.parseToken(token.trim(), \"example0102\"); if (example0102 != null){ ctx.addZuulRequestHeader(\"authorization\",token); return null; } } // 拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); ctx.setResponseBody(\"{'msg':'校验失败'}\"); ctx.getResponse().setContentType(\"text/html;charset=utf-8\");// 不设置的话，中文乱码 return null; } } 跨域 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; /** 全局跨域配置类 */ @Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //放行哪些原始域 config.addAllowedOrigin(\"*\"); //是否发送Cookie信息 config.setAllowCredentials(true); //放行哪些原始域(请求方式) config.addAllowedMethod(\"OPTIONS\"); config.addAllowedMethod(\"HEAD\"); config.addAllowedMethod(\"GET\"); //get config.addAllowedMethod(\"PUT\"); //put config.addAllowedMethod(\"POST\"); //post config.addAllowedMethod(\"DELETE\"); //delete config.addAllowedMethod(\"PATCH\"); config.addAllowedHeader(\"*\"); //2.添加映射路径 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\"/**\", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); } } zuul: sensitive-headers: Access-Control-Allow-Origin ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken 其他 ​ 解決请求头丢失问题,zuul会默认过滤掉部分请求头 zuul: sensitive-headers: Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"microservice/netflix/eureka/eureka.html":{"url":"microservice/netflix/eureka/eureka.html","title":"Eureka","keywords":"","body":"Eureka作用为什么要使用入门案例服务端客户端负载均衡高可用EurekaEureka ​ 服务发现与注册中心 ​ 由Netflix开发的服务发现框架,本身是一个基于REST的服务 ​ 主要组件 ​ Eureka Serve:服务端,提供服务注册和发现的功能 ​ Eureka Client:客户端,与Eureka Serve的交互,客户端启动后会自动注册到其启动时配置的地址的服务端 作用 ​ 对服务进行统一管理 ​ 提供服务的注册于发现,将所有的服务进行统一管理,不需要开发人员手动维护,需要使用哪个服务,直接在服务中心中获取就行 ​ 实现对服务的状态管理,如果某个服务下线,会有通知,专业术语是心跳,服务提供者会定期通过http方式向Eureka刷新自身的状态,同时Eureka会将所有提供者的地址发送给消费者,并定期更新 ​ 结合其他技术(Ribbon)实现了负载均衡 为什么要使用 ​ 微服务的基础还是服务,将一个单体应用拆分为微服务架构的应用,其中服务之间需要相互依赖,相互调用,但是服务被部署在不同的服务器上,如果服务一旦过多,那么会出现访问的地址(接口)难以进行管理,如果有集群,还需要自行实现负载均衡,并且其中有某个服务停掉也不会接到通知,为了解决等等之类的问题,便诞生了服务发现与注册中心 入门案例 ​ 分为服务端和客户端,引入Eureka都需要三步,添加依赖,配置,注解 ​ 首先都需要引入SpringCloud的依赖 ​ 该案例使用的SpringCloud的Hoxton.RELEASE版本,需要结合springboot2.2.x使用 org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import spring-milestones Spring Milestones https://repo.spring.io/milestone false 服务端 依赖 org.springframework.cloud spring-cloud-starter-netflix-eureka-server 配置 server: port: 8080 # 端口 spring: application: name: eureka-server # 应用名称，会在Eureka中显示 eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:${server.port}/eureka 注解 ​ 在启动类上添加 @EnableEurekaServer // 声明这个应用是一个EurekaServer 访问:http://127.0.0.1:8080 客户端 依赖 org.springframework.cloud spring-cloud-starter-netflix-eureka-client 配置 server: port: 8081 spring: datasource: url: jdbc:mysql://localhost:3306/mydb?useUnicode=true&characterEncoding=utf8 username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: user-service # 应用名称 eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:8080/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称(也就是根据主机名还是ip访问) ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注解 // 两者选其一 @EnableEurekaClient // 开启EurekaClient功能 @EnableDiscoveryClient // 开启Eureka客户端 客户端又分为生产者和消费者,生产者也就是服务提供者,需要将自身注册到服务中心即可,而消费者需要到服务中心调用对应的服务,服务中心存储的相当于服务名称=多个服务地址的键值对 使用DiscoveryClient类 // 必须导入org.springframework.cloud.client.discovery.DiscoveryClient @Autowired private DiscoveryClient discoveryClient; public void demo(){ // 根据服务名称,拿到所有已注册的服务实例,因为可能会有集群所以是个集合 List instances = discoveryClient.getInstances(\"user-service\"); // 拿到其中一个实例 ServiceInstance serviceInstance = instances.get(0); // host主机地址 String host = serviceInstance.getHost(); // port端口号 int port = serviceInstance.getPort(); String url = \"http://\"+host+\":\"+port+\"controller地址及参数\"; } 结合RestTemplate使用 @Configuration public class RestTemplateConfig { @Bean public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(); // 解决乱码 restTemplate.getMessageConverters().add(1,new StringHttpMessageConverter(Charset.forName(\"UTF-8\"))); return restTemplate; } } #修改Eureka服务实例的显示 eureka: instance: instance-id: ${spring.application.name}:${server.port} 负载均衡 ​ 首先负载均衡是在集群的基础上,集群就是将相同功能的代码部署到不同的服务器,而负载均衡则是将流量平均分发到集群的不同服务上,同时做集群的目的也就是为了负载均衡,其中负载均衡又有很多策略,也就是实现负载均衡的算法 ​ Eureka中集成了Ribbon负载均衡器,使用时只需要简单的配置即可 ​ 使用 ​ 在RestTemplate的配置方法上添加@LoadBalanced注解： ​ 添加该注解后,才可以使用服务名的方式访问 @Configuration public class RestTemplateConfig { @Bean // 开启负载均衡 @LoadBalanced public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(); // 解决乱码 restTemplate.getMessageConverters().add(1,new StringHttpMessageConverter(Charset.forName(\"UTF-8\"))); return restTemplate; } } ​ 修改调用方式,从host+port改为直接调用服务名称的方式 http://服务名称/controller方法的映射地址 String url = \"http://user-service/user/\"+id; ​ 默认使用的是轮询机制,注入RibbonLoadBalanceClient类进行测试 @RunWith(SpringRunner.class) @SpringBootTest(classes = 启动类.class) public class LoadBalanceTest { @Autowired RibbonLoadBalancerClient client; @Test public void test(){ for (int i = 0; i ​ 修改负载均衡的策略 ​ 查看IRule接口的实现类,可以找到其他实现负载均衡的策略 ​ 在客户端添加配置 # 根 user-service: # 服务名 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #策略 高可用Eureka 将多个EurekaServer相互注册为服务 启动多个EureakServe服务,进行相互注册,只需要将注册地址的ip互换 server: port: 10086 # 端口 spring: application: name: eureka-server # 应用名称，会在Eureka中显示 eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 客户端注册到Eureka服务集群 eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 EurekaServer集群只需注册在一台上即可共享 defaultZone: http://127.0.0.1:10086/eureka 服务续约 eureka: instance: lease-expiration-duration-in-seconds: 90 #超过90秒默认该服务宕机 lease-renewal-interval-in-seconds: 30 #每30秒发送一次心跳 当服务消费者启动时，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： eureka: client: registry-fetch-interval-seconds: 5 失效剔除和自我保护 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不便，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 在eureka的yml文件中配置 eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 重试机制 ​ CAP原则：CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得 Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能 user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖,测试 org.springframework.retry spring-retry Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"microservice/netflix/Hystrix.html":{"url":"microservice/netflix/Hystrix.html","title":"Hystrix","keywords":"","body":"Hystrix使用环境依赖注解逻辑代码配置Hystrix ​ 熔断,在分布式系统中,高并发的环境下服务可能因为压力会出现宕机,而其他的服务可能会依赖该服务,并且导致级联的失败,但是在生产环境中应该避免让用户看到错误的情况,所以可以使用熔断来解决相关问题 ​ 类似生活中的保险丝,当出现漏电等情况,会将保险丝熔断,避免出现火灾 使用 ​ 在服务调用方进行操作 环境 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import spring-milestones Spring Milestones https://repo.spring.io/milestone false 依赖 org.springframework.cloud spring-cloud-starter-netflix-hystrix 注解 // 在启动类上添加 @EnableHystrix // 开启Hystrix熔断 逻辑代码 // 在需要熔断的方法上添加注解并指定熔断的回调函数 @HystrixCommand(fallbackMethod = \"queryUserByIdFallback\") public User queryUserById(Long id) { String url = \"http://user-service-tao/user/\" + id; User user = restTemplate.getForObject(url, User.class); return user; } // 熔断后的回调函数 参数及返回值一致 public User queryUserByIdFallback(Long id){ User user = new User(); user.setId(id); user.setName(\"用户信息查询出现异常！\"); return user; } 配置 ​ 其默认的触发熔断的时间为1s,所以当结合重试使用时,需要将熔断的时间设置的比重试的时间长一些,不然重试就没有了其意义 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"microservice/netflix/Feign.html":{"url":"microservice/netflix/Feign.html","title":"Feign","keywords":"","body":"Feign入门使用依赖注解配置逻辑代码请求压缩Feign ​ 简化远程调用代码,支持SpringMVC注解,不需要拼接url地址,同时整合了负载均衡Ribbon以及服务熔断(Hystrix) 入门使用 服务调用者 依赖 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE org.springframework.cloud spring-cloud-starter-openfeign org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import spring-milestones Spring Milestones https://repo.spring.io/milestone false 注解 // 启动类上添加 @EnableFeignClients // 开启Feign功能 配置 ​ 虽然Feign集成了Hystrix熔断,但默认是关闭的 feign: hystrix: enabled: true # 开启Feign的熔断功能 ​ 同样支持对Ribbon负载均衡的配置 #服务名 如果不写服务名是全局配置 ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 逻辑代码 // 创建接口 添加访问的服务名称以及熔断时进行处理的class类(接口的实现类) @FeignClient(value = \"user-service-tao\",fallback = UserFeignClientFallback.class) public interface UserFeignClient { @GetMapping(\"/user/{id}\") User queryUserById(@PathVariable(\"id\") Long id); } // 实现Feign的接口,重写回调函数 @Component public class UserFeignClientFallback implements UserFeignClient{ @Override public User queryUserById(Long id) { User user = new User(); user.setId(id); user.setName(\"用户查询出现异常！\"); return user; } } // 注入后接口并调用 @Autowired private UserFeignClient userFeignClient; public User queryUserById(Long id){ User user = userFeignClient.queryUserById(id); return user; } 请求压缩 ​ Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"httptool/HttpClient.html":{"url":"httptool/HttpClient.html","title":"HttpClient","keywords":"","body":"HttpClient什么是HttpClient入门案例发起Get请求带参数的Get请求发起POST请求带参数POST请求SpringBoot整合HttpClientHttpClient 什么是HttpClient HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 特点： HttpClient别名：HttpComponents HttpClient可以发送get、post、put、delete、...等请求 入门案例 导入maven坐标 org.apache.httpcomponents httpclient 4.4 发起Get请求 1创建一个客户端 CloseableHttpClient 2创建一个get方法请求实例 HttpGet 3发送请求 execute 4获取响应的头信息 5获取响应的主题内容 6关闭响应对象 使用HttpClient发起Get请求的案例代码： public class DoGET { public static void main(String[] args) throws Exception { // 创建Httpclient对象,相当于打开了浏览器 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建HttpGet请求，相当于在浏览器输入地址 HttpGet httpGet = new HttpGet(\"http://www.baidu.com/\"); CloseableHttpResponse response = null; try { // 执行请求，相当于敲完地址后按下回车。获取响应 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应，获取数据 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { // 关闭资源 response.close(); } // 关闭浏览器 httpclient.close(); } } } 带参数的Get请求 1创建一个客户端 CloseableHttpClient 2 通过URIBuilder传递参数 3创建一个get方法请求实例 HttpGet 4发送请求 execute 5获取响应的头信息 6获取响应的主题内容 7关闭响应对象 访问网站的爬虫协议： public class DoGETParam { public static void main(String[] args) throws Exception { // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建URI对象，并且设置请求参数 URI uri = new URIBuilder(\"http://www.baidu.com/s\").setParameter(\"wd\", \"java\").build(); // 创建http GET请求 HttpGet httpGet = new HttpGet(uri); // HttpGet get = new HttpGet(\"http://www.baidu.com/s?wd=java\"); CloseableHttpResponse response = null; try { // 执行请求 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应数据 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { response.close(); } httpclient.close(); } } } 发起POST请求 /* * 演示：使用HttpClient发起POST请求 */ public class DoPOST { public static void main(String[] args) throws Exception { // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建http POST请求 HttpPost httpPost = new HttpPost(\"http://www.oschina.net/\"); // 把自己伪装成浏览器。否则开源中国会拦截访问 httpPost.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"); CloseableHttpResponse response = null; try { // 执行请求 response = httpclient.execute(httpPost); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应数据 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { response.close(); } // 关闭浏览器 httpclient.close(); } } } 带参数POST请求 /* * 演示：使用HttpClient发起带有参数的POST请求 */ public class DoPOSTParam { public static void main(String[] args) throws Exception { // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建http POST请求，访问开源中国 HttpPost httpPost = new HttpPost(\"http://www.oschina.net/search\"); // 根据开源中国的请求需要，设置post请求参数 List parameters = new ArrayList(0); parameters.add(new BasicNameValuePair(\"scope\", \"project\")); parameters.add(new BasicNameValuePair(\"q\", \"java\")); parameters.add(new BasicNameValuePair(\"fromerr\", \"8bDnUWwC\")); // 构造一个form表单式的实体 UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(parameters); // 将请求实体设置到httpPost对象中 httpPost.setEntity(formEntity); CloseableHttpResponse response = null; try { // 执行请求 response = httpclient.execute(httpPost); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应体 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { response.close(); } // 关闭浏览器 httpclient.close(); } } } SpringBoot整合HttpClient SpringBoot官方并没有对HttpClient的启动器。所以我们需要自己完成配置，还好，我们刚才在测试案例中已经写过了。 不过，SpringBoot虽然没有提供启动器，但是却提供了一个统一的对Restful服务进行调用的模板类：RestTemplate，底层可以使用HttpClient来实现。有了这个我们就无需自己定义APIService了。 1、导入maven坐标 org.apache.httpcomponents httpclient 2、在application.properties添加如下配置: #The config for HttpClient http.maxTotal=300 http.defaultMaxPerRoute=50 http.connectTimeout=1000 http.connectionRequestTimeout=500 http.socketTimeout=5000 http.staleConnectionCheckEnabled=true 3、 创建HttpClientConfig类--类似util 在类中编写代码 /** * HttpClient的配置类 * */ @Configuration @ConfigurationProperties(prefix = \"http\", ignoreUnknownFields = true) public class HttpClientConfig { private Integer maxTotal;// 最大连接 private Integer defaultMaxPerRoute;// 每个host的最大连接 private Integer connectTimeout;// 连接超时时间 private Integer connectionRequestTimeout;// 请求超时时间 private Integer socketTimeout;// 响应超时时间 /** * HttpClient连接池 * @return */ @Bean public HttpClientConnectionManager httpClientConnectionManager() { PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(maxTotal); connectionManager.setDefaultMaxPerRoute(defaultMaxPerRoute); return connectionManager; } /** * 注册RequestConfig * @return */ @Bean public RequestConfig requestConfig() { return RequestConfig.custom().setConnectTimeout(connectTimeout) .setConnectionRequestTimeout(connectionRequestTimeout).setSocketTimeout(socketTimeout) .build(); } /** * 注册HttpClient * @param manager * @param config * @return */ @Bean public HttpClient httpClient(HttpClientConnectionManager manager, RequestConfig config) { return HttpClientBuilder.create().setConnectionManager(manager).setDefaultRequestConfig(config) .build(); } /** * 使用连接池管理连接 * @param httpClient * @return */ @Bean public ClientHttpRequestFactory requestFactory(HttpClient httpClient) { return new HttpComponentsClientHttpRequestFactory(httpClient); } /** * 使用HttpClient来初始化一个RestTemplate * @param requestFactory * @return */ @Bean public RestTemplate restTemplate(ClientHttpRequestFactory requestFactory) { RestTemplate template = new RestTemplate(requestFactory); List> list = template.getMessageConverters(); for (HttpMessageConverter mc : list) { if (mc instanceof StringHttpMessageConverter) { ((StringHttpMessageConverter) mc).setDefaultCharset(Charset.forName(\"UTF-8\")); } } return template; } public Integer getMaxTotal() { return maxTotal; } public void setMaxTotal(Integer maxTotal) { this.maxTotal = maxTotal; } public Integer getDefaultMaxPerRoute() { return defaultMaxPerRoute; } public void setDefaultMaxPerRoute(Integer defaultMaxPerRoute) { this.defaultMaxPerRoute = defaultMaxPerRoute; } public Integer getConnectTimeout() { return connectTimeout; } public void setConnectTimeout(Integer connectTimeout) { this.connectTimeout = connectTimeout; } public Integer getConnectionRequestTimeout() { return connectionRequestTimeout; } public void setConnectionRequestTimeout(Integer connectionRequestTimeout) { this.connectionRequestTimeout = connectionRequestTimeout; } public Integer getSocketTimeout() { return socketTimeout; } public void setSocketTimeout(Integer socketTimeout) { this.socketTimeout = socketTimeout; } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"httptool/RestTemplate.html":{"url":"httptool/RestTemplate.html","title":"RestTemplate","keywords":"","body":"RestTemplateRestTemplate是什么?使用所需依赖解决中文乱码问题访问中国天气出现乱码简单使用RestTemplate RestTemplate是什么? ​ 是一个可以在服务器之间相互调用,发送http请求的工具包,封装了其他有相同功能的工具包,使用更加简洁方便 使用 所需依赖 org.springframework.boot spring-boot-starter-web 解决中文乱码问题 @Configuration public class RestTemplateConfig { //第二种 不用配置类,可以直接在SpringBoot 启动类注册 @Bean public RestTemplate restTemplate() { // 默认的RestTemplate，底层是走JDK的URLConnection方式。 // 设置中文乱码问题方式一 RestTemplate restTemplate = new RestTemplate(); restTemplate.getMessageConverters().add(1,new StringHttpMessageConverter(Charset.forName(\"UTF-8\"))); // 设置中文乱码问题方式二 // restTemplate.getMessageConverters().set(1, // new StringHttpMessageConverter(StandardCharsets.UTF_8)); // 支持中文编码 return restTemplate; } } 访问中国天气出现乱码 请求接口: http://wthrcdn.etouch.cn/weather_mini?city=北京 增加依赖 org.apache.httpcomponents httpclient 4.4 修改配置类 //获得的返回数据是经过 GZIP 压缩过的, 而默认的URLConnection无法支持所以考虑创建使用httpClient的RestTemplate RestTemplate restTemplate = new RestTemplate( new HttpComponentsClientHttpRequestFactory()); // 使用HttpClient，支持GZIP restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); // 支持中文编码 简单使用 @RestController @RequestMapping(\"/rest\") public class RestTemplateController { @Autowired private RestTemplate restTemplate; private String urlPrefix = \"http://localhost:8080/\"; @GetMapping public ResponseEntity findAll(){ ResponseEntity forEntity = restTemplate.getForEntity(urlPrefix + \"brand\", BaseResult.class); return forEntity; } @GetMapping(\"/product\") public ResponseEntity findAllProduct(PageRequest pageRequest){ // 也可以直接将参数拼接在地址栏上 注意传递参数是 参数为null 会被拼接为字符串的问题 HashMap hashMap = new HashMap<>(); hashMap.put(\"pageNum\",pageRequest.getPageNum()); hashMap.put(\"pageSize\",pageRequest.getPageSize()); ResponseEntity forEntity = restTemplate.getForEntity(urlPrefix + \"product?pageNum={pageNum}&pageSize={pageSize}\",BaseResult.class,hashMap); return forEntity; } @PostMapping public ResponseEntity add(@RequestBody TbProduct tbProduct){ ResponseEntity forEntity = restTemplate.postForEntity(urlPrefix + \"product\",tbProduct, String.class); return ResponseEntity.ok(forEntity.getBody()); } @DeleteMapping(\"/{id}\") public ResponseEntity deleteById(@PathVariable Integer id){ restTemplate.delete(urlPrefix + \"product/\"+id); return ResponseEntity.ok(\"删除成功\"); } @PutMapping public ResponseEntity edit(@RequestBody TbProduct tbProduct){ restTemplate.put(urlPrefix + \"product\",tbProduct); return ResponseEntity.ok(\"修改成功\"); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"mybatis/mybatis.html":{"url":"mybatis/mybatis.html","title":"Mybatis","keywords":"","body":"什么是Mybatis什么是ORM案例什么是Mybatis Mybatis是一个持久层ORM框架。内部封装了jdbc，使开发更简洁，更高效。 Mybatis使开发者只需要关注sql语句本身，简化JDBC操作，不需要在关注加载驱动、创建连接、处理SQL语句等繁杂的过程。 Mybatis可以通过xml或注解完成ORM映射关系配置。 什么是ORM ORM的全称是Object Relational Mapping，即对象关系映射。 描述的是对象和表之间的映射。操作Java对象，通过映射关系，就可以自动操作数据库。 在ORM关系中，数据库表对应Java中的类，一条记录对应一个对象，一个属性对应一个列。 常见的ORM框架：Mybatis、Hibernate 案例 该例子主要为了结合springboot、example以及PageHelper分页使用 pom.xml org.springframework.boot spring-boot-starter-parent 2.2.5.RELEASE UTF-8 UTF-8 1.8 1.3.2 2.0.2 1.1.9 5.1.32 1.2.3 org.springframework.boot spring-boot-starter-web org.projectlombok lombok org.mybatis.spring.boot mybatis-spring-boot-starter ${mybatis.starter.version} tk.mybatis mapper-spring-boot-starter ${mapper.starter.version} com.github.pagehelper pagehelper-spring-boot-starter ${pageHelper.starter.version} com.alibaba druid-spring-boot-starter ${druid.starter.version} mysql mysql-connector-java ${mysql.version} org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine application.yml server: port: 10400 spring: datasource: url: jdbc:mysql://localhost:3306/数据库?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai username: root password: 123 driver-class-name: com.mysql.jdbc.Driver # 德鲁伊连接池 druid: # 初始化大小,最小,最大 initial-size: 5 min-idle: 5 max-active: 20 # 获取连接等待超时的时间 max-wait: 60000 # 配置一个连接在池中最小生存的时间,单位是毫秒 min-evictable-idle-time-millis: 300000 application: name: book mybatis: configuration: # 在控制台输出sql日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 指定xml文件位置 mapper-locations: classpath:mapperxml/*.xml BookMapper.xml id, book_name, produce_date, book_pub, book_num SELECT from book WHERE id IN #{id} mapper public interface BookMapper extends Mapper { List findByIds(String[] bookIds); } service @Service public class BookService{ @Resource private BookMapper bookMapper; public List findAll() { return bookMapper.selectAll(); } public List findByIds(String[] ids) { return bookMapper.findByIds(ids); } public List findByPage(Integer pageNum,Integer pageSize) { PageHelper.startPage(pageNum,pageSize); Example example = new Example(Book.class); example.createCriteria().orIsNotNull(\"bookPub\"); return bookMapper.selectByExample(example); } } controller @RequestMapping(\"/book\") @RestController public class BookController { @Autowired private BookService bookService; @GetMapping(\"/findByIds\") public List findByIds(String[] ids){ System.out.println(Arrays.toString(ids)); return bookService.findByIds(ids); } } domain @Data @Table(name = \"book\") public class Book { @Id @Column(name = \"id\") @GeneratedValue(generator = \"JDBC\") private Integer id; @Column(name = \"book_name\") private String bookName; // 传入数据库的格式 @DateTimeFormat(pattern = \"yyyy-MM-dd\") // 返回数据的格式 @JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"GMT+8\") @Column(name = \"produce_date\") private LocalDate produceDate; @Column(name = \"book_pub\") private String bookPub; @Column(name = \"book_num\") private Integer bookNum; } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"mybatis/注意事项.html":{"url":"mybatis/注意事项.html","title":"注意事项","keywords":"","body":"注意事项@Id@Transient热部署注意事项 @Id ​ 一定不要忘了添加该注解,在使用通用mapper时,有很多方法会根据主键对数据进行操作 // 正确写法 // import javax.persistence.*; @Id // 对应列名 @Column(name = \"id\") // 自增id 在插入后可以通过getId()获取到插入后的id @GeneratedValue(generator = \"JDBC\") private Integer id; @Transient ​ 如果实体类中有属性不是表中字段,添加该注解避免出现不必要的异常 ​ Mybatis-3.2.5及以上版本必须添加 @Transient private String cids; 热部署 通用mapper不支持热部署 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"mybatis/mybatis-plus.html":{"url":"mybatis/mybatis-plus.html","title":"mybatis-plus","keywords":"","body":"简介依赖自动生成代码配置分页插件使用分页示例代码官方文档简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 依赖 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE org.springframework.boot spring-boot-starter-jdbc mysql mysql-connector-java 5.1.47 com.baomidou mybatis-plus-generator 3.2.0 org.freemarker freemarker 2.3.29 org.springframework.boot spring-boot-starter-test test org.projectlombok lombok true com.baomidou mybatis-plus-boot-starter 3.2.0 自动生成代码 // 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中 public class CodeGenerator { /** * * 读取控制台内容 * */ public static String scanner(String tip) { Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\" + tip + \"：\"); System.out.println(help.toString()); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) { return ipt; } } throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\"); } public static void main(String[] args) { // 代码生成器 AutoGenerator mpg = new AutoGenerator(); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"Tao\"); gc.setOpen(false); // gc.setIdType(IdType.NONE); // gc.setSwagger2(true); 实体属性 Swagger2 注解 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/数据库?useUnicode=true&useSSL=false&characterEncoding=utf8\"); // dsc.setSchemaName(\"public\"); dsc.setDriverName(\"com.mysql.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"密码\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(scanner(\"模块名\")); pc.setParent(\"父包\"); // pc.setService(\"%sService\"); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing } }; // 如果模板引擎是 freemarker String templatePath = \"/templates/mapper.xml.ftl\"; // 如果模板引擎是 velocity // String templatePath = \"/templates/mapper.xml.vm\"; // 自定义输出配置 List focList = new ArrayList<>(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName() + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; } }); /* cfg.setFileCreate(new IFileCreate() { @Override public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) { // 判断自定义文件夹是否需要创建 checkDir(\"调用默认方法创建的目录\"); return false; } }); */ cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); // 配置自定义输出模板 //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别 // templateConfig.setEntity(\"templates/entity2.java\"); // templateConfig.setService(); // templateConfig.setController(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); // strategy.setSuperEntityClass(\"com.baomidou.ant.common.BaseEntity\"); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); // 公共父类 // strategy.setSuperControllerClass(\"com.baomidou.ant.common.BaseController\"); // 写于父类中的公共字段 strategy.setSuperEntityColumns(\"id\"); strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\")); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(pc.getModuleName() + \"_\"); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); } } 配置分页插件 @Configuration public class MyBatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor(){ // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false // paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 // paginationInterceptor.setLimit(500); PaginationInterceptor page = new PaginationInterceptor(); //设置方言类型 page.setDialectType(\"mysql\"); return page; } 使用分页 @Test public void page(){ User user = new User(); // 分页查询加条件 所有字段为空正常查询 user.setAge(20); IPage page = iUserService.page(new Page(1, 3),new QueryWrapper(user)); page.getRecords().forEach(System.out::println); } 示例代码 ​ https://github.com/TaoQZ/mybatis-plus-learning-exam.git 官方文档 ​ https://mp.baomidou.com/ Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"maven/maven.html":{"url":"maven/maven.html","title":"Maven","keywords":"","body":"Mavenmaven是什么?为什么使用maven?下载与配置配置环境变量:阿里镜像本地仓库远程仓库IDEA中配置maven入门使用坐标version后缀生命周期pom文件常用标签依赖的生命周期注意事项pom标签大全详解Maven maven是什么? Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 为什么使用maven? 在之前的项目中,每次都需要先导入很多jar包,并且出现依赖冲突没有直观显示,使用maven后不用在手动导入很多jar包, 只需要引入jar在仓库对应的坐标即可,大大减小了项目的体积 下载与配置 下载地址:https://maven.apache.org/download.cgi windows环境下选择二进制压缩包进行下载 配置环境变量: ​ 可以先在系统变量创建一个MAVEN_HOME指向maven安装路径,然后在path中添加此变量,并指向bin目 录%MAVEN_HOME%\\bin,这样做的目的是如果maven换了安装目录只需要更改MAVEN_HOME,而不需要更改path,避免出 现其他问题,配置好后使用mvn - v 命令查看版本 阿里镜像 主要的配置文件在conf文件夹中的settings.xml,其默认使用的是maven的中央仓库,为了解决国内下载速度慢的情况 找到mirrors标签添加 alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ maven安装后会有一个默认的仓库在c盘用户的文件夹.m2,更改其默认的仓库 本地仓库 在settings.xml中配置自定义本地仓库的位置 仓库所在磁盘路径 远程仓库 使用Nexus搭建maven私服 需要配置认证信息,在maven的settings.xml文件的serves节点添加 nexus-releases admin admin123 nexus-snapshots admin admin123 自动化部署,上传 命令 : mvn deploy nexus-releases Nexus Release Repository http://127.0.0.1:8081/repository/maven-releases/ nexus-snapshots Nexus Snapshot Repository http://127.0.0.1:8081/repository/maven-snapshots/ 配置代理仓库 修改url地址即可 nexus Nexus Repository http://127.0.0.1:8081/repository/maven-public/ true true nexus Nexus Plugin Repository http://127.0.0.1:8081/repository/maven-public/ true true IDEA中配置maven ​ 点击左上角File ---> other-settings ---> settings for new projects ​ 搜索maven ​ 设置创建新项目时的配置,更改本项目的配置在File ---> setting ---> 中搜索maven做同样的配置 解决IDEA中创建项目慢,因为默认使用的是远程创建 切换成使用本地的配置文件创建项目 入门使用 坐标 ​ 以下面的依赖作为示例解释坐标的概念 ​ 其实就是该jar(依赖)在仓库的位置 仓库所在磁盘位置\\org\\projectlombok\\lombok\\1.18.10 org.projectlombok 组名 lombok 模块名 1.18.10 版本号 version后缀 SNAPSHOT：快照版本,此jar包没有经过测试,很多bug RC：此jar包经过了充分测试，但是可能还有很多bug BETA：上线前的测试版本 RELEASE：正式版 生命周期 阶段 处理 描述 验证 validate 验证项目 验证项目是否正确且所有必须信息是可用的 编译 compile 执行编译 源代码编译在此阶段完成 测试 Test 测试 使用适当的单元测试框架（例如JUnit）运行测试。 包装 package 打包 创建JAR/WAR包如在 pom.xml 中定义提及的包 检查 verify 检查 对集成测试的结果进行检查，以保证质量达标 安装 install 安装 安装打包的项目到本地仓库，以供其他项目使用 部署 deploy 部署 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程 pom文件常用标签 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE jar 子模块 UTF-8 UTF-8 1.8 5.1.32 org.springframework.boot spring-boot-starter-web mysql mysql-connector-java ${mysql.version} tk.mybatis mapper 3.5.2 javax.persistence persistence-api 依赖的生命周期 compile : 编译范围,默认值 provided : 打包时需要,例如写servlet程序时需要依赖servlet-api进行编译,但是运行在tomcat容器中有相同的依赖会引起依赖冲突,此时需要添加此注解 runtime : 仅参与项目的运行阶段,例如mysql的驱动 test : 该依赖仅参与测试相关的内容,例如junit system : 使用的非maven仓库中依赖,引用的是本地文件系统的jar 注意事项 解决依赖下载不完全的问题 创建.bat文件,更改目录完毕后,双击运行 set REPOSITORY_PATH=指向maven仓库 rem 正在搜索... for /f \"delims=\" %%i in ('dir /b /s \"%REPOSITORY_PATH%\\*lastUpdated*\"') do ( del /s /q %%i ) rem 搜索完毕 pause install打包到本地仓库 将项目封装为工具类时,应该打包成为一个不可运行的jar,所以需要将下方插件依赖删除 org.springframework.boot spring-boot-maven-plugin pom标签大全详解 4.0.0 asia.banseon banseon-maven2 jar 1.0-SNAPSHOT banseon-maven http://www.baidu.com/banseon A maven project to study maven. jira http://jira.baidu.com/banseon Demo banseon@126.com banseon@126.com banseon@126.com http:/hi.baidu.com/banseon/demo/dev/ HELLO WORLD banseon banseon@126.com Project Manager Architect demo http://hi.baidu.com/banseon No -5 Apache 2 http://www.baidu.com/banseon/LICENSE-2.0.txt repo A business-friendly OSS license scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk http://svn.baidu.com/banseon demo http://www.baidu.com/banseon ...... ...... Windows XP Windows x86 5.1.2600 mavenVersion 2.0.3 /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ ...... ...... ...... ...... ...... ...... banseon-repository-proxy banseon-repository-proxy http://192.168.1.169:9999/repository/ default ...... org.apache.maven maven-artifact 3.8.1 jar test spring-core org.springframework true ...... banseon-maven2 banseon maven2 file://${basedir}/target/deploy banseon-maven2 Banseon-maven2 Snapshot Repository scp://svn.baidu.com/banseon:/usr/local/maven-snapshot banseon-site business api website scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web value。 --> Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"mongodb/Mongo的安装与卸载.html":{"url":"mongodb/Mongo的安装与卸载.html","title":"Mongo的安装与卸载","keywords":"","body":"卸载:停止对应服务:卸载服务:卸载应用:安装:步骤:配置环境变量:卸载: 停止对应服务: ​ 使用管理员命令窗口 win+x+a ​ net stop 服务名 卸载服务: ​ mongod.exe --remove --serviceName \"mongo的服务名\" 卸载应用: ​ 在系统应用中进行卸载 安装: 步骤: 1.下载对应安装包 mongodb中文官网:https://www.mongodb.org.cn/tutorial/55.html 2.点击安装,选择自定义配置 3.选择安装目录 4.进行配置 配置环境变量: ​ 配置环境变量的目的:为了在电脑中任意位置都可以使用mongo(其他应用程序也是如此) ​ 系统变量和用户变量:系统变量针对当前系统有效,而用户变量只对当前用户有效 ​ 步骤: 此电脑 --> 右键 --> 属性 高级系统设置 --> 环境变量 系统变量 --> 新建 在系统变量Path的变量值中添加%mongo%\\bin; 指向mongo的bin目录 测试启动 打开命令行cmd 默认端口 27017 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"mongodb/Mongo介绍及命令行使用.html":{"url":"mongodb/Mongo介绍及命令行使用.html","title":"Mongo的介绍及命令行使用","keywords":"","body":"1. 简介2. Mongdb与MySQL的区别2.1 结构2.2 数据及存储方式2.3 优缺点2.4 使用场景3.数据类型3.1 数值类型3.2 数组类型3.3 日期类型3.4 ObjectId3.5 typeof 和$type3.6 null4.命令行启动4.1 启动服务4.2 运行mongodb4.3 基本操作5.使用5.1 基本概念5.2 添加insertOne(对象)insertMany(数组)insert(文档对象或数组)savesave和insert的区别5.3 删除deteleOnedeleteManyremove5.4 查询findfindOne5.5 更新updateOneupdateManyupdate结合参数使用6.常用操作符$set$unset$inc$exists$in$or$and$sort$skip $limit7.操作数组8. 整合springboot简单增删改查8.1 项目环境8.2 pom依赖8.3 代码1. 简介 ​ MongoDB是一个基于分布式文件存储的数据库,是非关系型数据库(NoSQL) ​ 分布式文件存储:在mongodb中也叫分片管理,将数据库中存储的数据分散在不同的机器上,减缓了数据库的压力,提高响应速度 2. Mongdb与MySQL的区别 2.1 结构 MySQL MongoDB 对应关系 database database 库 table collection 表;集合 row document 一行数据(记录);一个文档 column field 列;字段 2.2 数据及存储方式 SQL NoSQL 存储方式 存在特定结构表中 更加灵活和可扩展,简单说就是在集合中每个文档可以有不相同个数或类型 表/集合数据的关系 必须定义好表和字段结构后才能添加数据,虽然表结构定义后可更新,比较复杂 数据可以在任何时候任何地方添加，不需要先定义表 多表查询 可以使用JOIN表连接方式将多个关系数据表中的数据用一条简单的查询语句查询出来 大多非关系型数据库不支持(MongoDB 3.2后可以指定同一数据库中的集合以执行连接 ) 数据耦合性 不允许删除已经被使用的外部数据(外键),规范方式设置外键,也可手动维护 NoSQL中没有这种强耦合的概念，可以随时删除任何数据 2.3 优缺点 NoSQL SQL 优点 扩展简单,快速读写,成本低 是所有关系型数据库的通用语言(差别不大),移植性好,数据统计方便直观,事务处理,保持数据的一致性 缺点 不提供对SQL的支持,大部分非关系型数据不支持事务,现有 产品不够成熟(MongoDB4.0提供了事务的API) 扩展困难,读写慢(当数据量达到一定规模时),成本高(企业级的需要付费的) 2.4 使用场景 ​ 单从功能上讲,NoSQL几乎所有的功能,在关系型数据库上都能满足,所以选择NoSQL主要是和关系型数据库进 行结合使用,各取所长 ​ 比如说数据库中的表结构需要经常变化,增加字段,如果在一个百万级数据量的关系型数据库中新增字段会有很 多问题,而使用非关系型数据库极大提升扩展性,也可以作为缓存数据库,典型就是Redis 3.数据类型 ​ mongodb存储数据的格式为BSON,和JSON很像,是JSON的扩展 mongodb支持的所有的数据类型: Type Number Alias Notes Double 1 “double” String 2 “string” Object 3 “object” Array 4 “array” Binary data 5 “binData” Undefined 6 “undefined” Deprecated. ObjectId 7 “objectId” Boolean 8 “bool” Date 9 “date” Null 10 “null” Regular Expression 11 “regex” DBPointer 12 “dbPointer” Deprecated. JavaScript 13 “javascript” Symbol 14 “symbol” Deprecated. JavaScript (with scope) 15 “javascriptWithScope” 32-bit integer 16 “int” Timestamp 17 “timestamp” 64-bit integer 18 “long” Decimal128 19 “decimal” New in version 3.4. Min key -1 “minKey” Max key 127 “maxKey” ​ ​ JSON : 布尔、数字、字符串、数组和对象 ​ 没有日期类型,只有一种数字类型,无法区分浮点数和整数,也没法表示正则表达式或者函数 ​ BSON : 是一种类JSON的二进制形式的存储格式,有JSON没有的一些数据类型,如Date,BinData(二进制数据) 3.1 数值类型 ​ mongodb的数值类型默认使用64位浮点型数值,整型可以使用NumberInt(值)或者NumberLong (值) db.emp.insert({age:18}) db.emp.find({age:18}) // 如果有int类型会同时查询出来 { \"_id\" : ObjectId(\"5dca61c0f366526745ae2f13\"), \"age\" : 18.0 } ====================================== // NumberInt 插入 NumberLong 同理 db.emp.insert({age:NumberInt(18)}) // $type : 可以使用此命令查询对应的数据类型 // 可以使用上面表格中的Number 也可以使用 Alias db.emp.find({age:{$type:\"int\"}}) { \"_id\" : ObjectId(\"5dca62c9f366526745ae2f16\"), \"age\" : NumberInt(18) } 3.2 数组类型 ​ db.emp.insert({ _id:new ObjectId(), name:'taoqz', arr:[ '字符串', 100, new Date(\"2019-11-11\") ] }) db.emp.findOne({name:\"taoqz\"}) // 数组中支持不同的类型 { \"_id\" : ObjectId(\"5dca6971f366526745ae2f17\"), \"name\" : \"taoqz\", \"arr\" : [ \"字符串\", 100.0, ISODate(\"2019-11-11T00:00:00.000+0000\") ] } 3.3 日期类型 // 构建一个格林尼治时间 可以看到正好和我们的时间相差8小时，我们是+8时区，也就是时差相差8 new Date() new Date(\"1999-10-09T18:56:01\") // 真实时间是要比下面的时间大八个小时的 ISODate(\"2019-11-12T08:30:50.060Z\") // 此问题在Java中结合springboot时可以在对应的字段上添加下面注释 @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") 3.4 ObjectId ​ ObjectId使用12字节的存储空间，每个字节可以存储两个十六进制数字，所以一共可以存储24个十六进制数 字组成的字符串，在这24个字符串中，前8位表示时间戳，接下来6位是一个机器码，接下来4位表示进程id，最后 6位表示计数器 ​ 是文档的唯一标识,没有自增,如果不添加id会自动添加一个 \"_id\" : ObjectId(\"值\") db.emp.insert({_id:new ObjectId(),name:\"zz\"}) db.emp.findOne({name:\"zz\"}) { \"_id\" : ObjectId(\"5dca6eb4f366526745ae2f18\"), \"name\" : \"zz\" } 3.5 typeof 和$type ​ typeof 1 number typeof \"zz\" string ​ 每个数据类型对应一个数字，在MongoDB中可以使用$type操作符查看字段的数据类型 ​ $type:根据数据类型查找数据 {字段:{$type:数字}} {字段:{$type:\"数据类型\"}} 3.6 null ​ 用于表示空值或者不存在的字段 ,在查询的时候也可能会使用到 4.命令行启动 4.1 启动服务 ​ net start 服务名 (管理员cmd) 4.2 运行mongodb ​ mongo 4.3 基本操作 查看所有数据库 show dbs 查看所有集合 show tables | show collections 查看当前所在数据库 db 使用数据库 use db_name 删除数据库 db.dropDatabase() # 删除当前正在使用的数据库 使用集合 db.collection_name.find() # 查所有满足条件数据 db.collection_name.findOne() # 查满足条件的一条数据 db.collection_name.count() # 统计集合下面有多少数量的数据 删除集合 db.collection_name.drop() 创建数据库和集合 # 当你使用一个不存在的mongo数据库时,就自动创建了一个mongo数据库 # 同理当你往一个空集合里面插入了一条数据之后就自动创建了一个集合 查看当前数据库版本 db.version() 备份数据库 // 导出 如果没有设置账号密码 可以省略 mongodump --host IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件路径 // 导入 mongorestore --host --port -d 文件路径 5.使用 5.1 基本概念 ​ 数据库(database) ​ 集合(collection) ​ 文档(document) ​ 一个数据库由多个集合组成,一个集合中有许多文档,文档是最小的存储单位 5.2 添加 insertOne(对象) // 添加一条数据 db.emp.insertOne({name:\"张三\"}) // 返回的数据,也可以定义变量接收 { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"5dca9ef4f366526745ae2f1a\") } insertMany(数组) // 添加多条数据 db.emp.insertMany([{name:\"李四\"},{name:\"王五\"}]) { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"5dca9f91f366526745ae2f1c\"), ObjectId(\"5dca9f91f366526745ae2f1d\") ] } insert(文档对象或数组) // 添加一条或者多条 db.emp.insert({name:\"赵六\"}) WriteResult({ \"nInserted\" : 1 }) db.emp.insert([{name:\"田七\"},{name:\"吴八\"}]) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 2, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) // 查询所有 db.emp.find({}) { \"_id\" : ObjectId(\"5dca9f2bf366526745ae2f1b\"), \"name\" : \"张三\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9f91f366526745ae2f1c\"), \"name\" : \"李四\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9f91f366526745ae2f1d\"), \"name\" : \"王五\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9feef366526745ae2f1e\"), \"name\" : \"赵六\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa017f366526745ae2f1f\"), \"name\" : \"田七\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa017f366526745ae2f20\"), \"name\" : \"吴八\" } // 可以看到在插入时并没有指定id,确自动生成了一个_id // 在插入的时候如果已经存在了相同的id会报错 // 如果想要存在相同的id的时候不报错而是更新数据 请使用 save方法 ​ save // 当集合中没有此条数据,进行插入 db.emp.save({_id:\"1\",name:\"阿里\"}) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : \"1\" }) ----------------------------------------------------------------------------- // 有数据时会进行替换,而不是更新,更新会有专门针对字段更新的API db.emp.save({_id:\"1\",name:\"腾讯\",boss:\"马化腾\"}) // 一处匹配 一处修改 WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) ----------------------------------------------------------------------------- // 查询结果 { \"_id\" : \"1\", \"name\" : \"腾讯\", \"boss\" : \"马化腾\" } save和insert的区别 save和insert的区别 如果save没有指定id,直接插入 ​ 如果save指定了id,并且id已存在会替换已有的文档 5.3 删除 ​ // 插入两条数据 { \"_id\" : ObjectId(\"5dcaa5445feb59ece4310397\"), \"name\" : \"小王\", \"age\" : NumberInt(18) } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa5445feb59ece4310398\"), \"name\" : \"小红\", \"age\" : NumberInt(18) } deteleOne // 参数为空文档会集合中第一条文档 db.student.deleteOne({}) { \"acknowledged\" : true, \"deletedCount\" : 1.0 } // 两条命令效果一样 // $eq:== $gt:> $gte:>= $lt: deleteMany // 删除多条数据 // 如果传入空文档 会删除整个集合中的数据 db.student.deleteMany({}) { \"acknowledged\" : true, \"deletedCount\" : 2.0 } // 使用该命令会删除所有的匹配项 db.student.deleteMany({age:18}) { \"acknowledged\" : true, \"deletedCount\" : 2.0 } remove // 指定删除 会删除所有匹配项 db.student.remove({name:\"小王\"}) db.student.remove({age:18}) 5.4 查询 find // 查询所有 // 直接使用集合名称 db.student.find() // 指定集合名称 db.getCollection(\"student\").find({}) findOne // 只查询到第一个匹配到的 db.student.findOne({age:{$eq:18}}) // 会查询到所有匹配的 db.student.find({age:{$eq:18}}) 5.5 更新 ​ 数据 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } updateOne // 更新 db.books.updateOne({flag:1},{$set:{name:\"newName\"}}) { \"acknowledged\" : true, \"matchedCount\" : 1.0, \"modifiedCount\" : 1.0 } // 只更新了第一条 { \"_id\" : 1.0, \"name\" : \"newName\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } updateMany // 重新初始化数据后使用该命令会修改所有匹配项 db.books.updateMany({flag:1},{$set:{name:\"newName\"}}) update 和使用updateOne效果一样 结合参数使用 // 语法 db.collection.update( , , { upsert: , multi: , writeConcern: } ) query: 查询的条件 update: 可以配合操作符更新字段 upsert: 可选 当没有匹配项时,是否作为新的对象插入,默认false不插入 multi: 可选 默认false,只更新匹配的第一条记录,如果为true,将跟新所有匹配项 // 例如 可以弥补上面update时只更新一个匹配项 db.books.update({flag:1},{$set:{name:\"newName\"}},false,true) // 没有匹配项会添加 db.books.update({name:\"西游记\"},{name:\"西游记\"},true) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcab070763517547f7d8d95\"), \"name\" : \"西游记\" } 6.常用操作符 $set ​ 在更新时可以一个或多个字段 ​ 如果更新的字段不存在会添加该字段 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } // 更新flag和view字段 但flag字段之前不存在 进行了添加 db.books.update({_id:1},{$set:{flag:11,view:100}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } $unset ​ 删除字段 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // 将flag字段删除,其中flag的值可以随意写不用匹配 db.books.update({_id:1},{$unset:{flag:11}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } $inc ​ 自增或自减 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } // 将view字段自增10 db.books.update({_id:1},{$inc:{view:+10}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 10.0 } $exists ​ 匹配字段是否存在 // 格式 {字段:{$exists:boolean}} // 如果为true 匹配到所有有该字段的文档,包括null值 // false 则匹配没有该字段的文档 db.books.find({flag:{$exists:true}}) $in ​ 相当于mysql中的in ​ 是否在对应的范围 // 会匹配到对应字段在对应范围中的所有文档 db.books.find({_id:{$in:[1,3]}}) $or ​ 或者 ​ 格式:{ $or: [ { }, { }, ... , { } ] } { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"西游记\", \"publisher\" : \"吴承恩\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 0.0 } // ---------------------------------------------- { \"_id\" : 3.0, \"name\" : \"zz\" } // ---------------------------------------------- { \"_id\" : 4.0, \"name\" : \"qwe\", \"flag\" : null } // 查询名字水浒传或者view大于等于0或者拥有flag字段的文档 db.books.find({$or:[ {name:\"水浒传\"}, {view:{$gte:0}}, {flag:{$exists:true}} ]}) $and ​ 并且 ​ 格式:{ $and: [ { }, { } , ... , { } ] } { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"西游记\", \"publisher\" : \"吴承恩\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0 } // 查询view大于等于100 并且存在flag字段的文档 db.books.find({$and:[ {view:{$gte:100}}, {flag:{$exists:true}} ]}) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } $sort ​ 排序 // 按照id 倒叙排序 // -1 从大到小 // 1 从小到大 db.books.find({}).sort({_id:-1}) $skip $limit ​ $skip 采用一个正整数，该整数指定要跳过的最大文档数。 ​ $limit 采用一个正整数，该整数指定要传递的最大文档数。 ​ 作用相当于mysql中的limit 两者可以结合使用 skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 7.操作数组 8. 整合springboot简单增删改查 8.1 项目环境 ​ mongodb: 4.0.9 ​ java:1.8 ​ springboot:2.2.0 ​ idea : 2019 ​ 使用了lombok简化实体类的代码 8.2 pom依赖 org.springframework.boot spring-boot-starter-parent 2.2.0.RELEASE org.springframework.boot spring-boot-starter-data-mongodb org.springframework.boot spring-boot-starter-web org.projectlombok lombok 1.18.8 8.3 代码 实体类 @Data @Document(collection = \"students\") public class Student { @Id private String id; private Integer sid; private String name; @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:dd\") @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:dd\",timezone = \"GMT+8\") private Date birthday; private String classId; private Classes classes; private String hobbies[]; } controller @RestController @CrossOrigin(\"*\") @RequestMapping(\"/student\") public class StudentController { @Autowired private StudentDao studentDao; /** * 查询所有 * @return */ @GetMapping public List fun() { return studentDao.findAll(); } /** * 添加 * @param student */ @PostMapping public void add(@RequestBody Student student) { studentDao.save(student); } /** * 修改 * @param student */ @PutMapping public void edit(@RequestBody Student student) { studentDao.update(student); } /** * 根据字段及值 进行删除 * @param filedName * @param value */ @DeleteMapping public void deleteByFiledName(@RequestParam(name = \"filedName\") String filedName, String value) { studentDao.deleteByFiledName(filedName, value); } } dao @Repository public class StudentDao { @Autowired private MongoTemplate mongoTemplate; /** * 查询所有 * @return */ public List findAll(){ List all = mongoTemplate.findAll(Student.class); for (Student student : all) { if (student.getClassId() != null){ // 拿到每个学生对应的班级id 创建ObjectId对象 ObjectId objectId = new ObjectId(student.getClassId()); // 根据班级id查询班级 Classes one = mongoTemplate.findOne(new Query(Criteria.where(\"id\").is(objectId)), Classes.class); // 将班级添加到学生对象中 student.setClasses(one); } } return all; } /** * 添加 * @param student */ public void save(Student student) { // 可以在笔记中看到两者的区别 mongoTemplate.insert(student); // mongoTemplate.save(student); } /** * 更新 * @param student */ public void update(Student student) { // 查询条件 根据id Query id = Query.query(Criteria.where(\"_id\").is(student.getId())); // 创建文档对象 Document document = new Document(); // 向文档中追加数据 更新哪个字段添加哪个字段 document.append(\"name\",student.getName()).append(\"birthday\",student.getBirthday()) .append(\"hobbies\",student.getHobbies()); // 根据id 根据文档对象进行更新 // 因为是根据ObjectId进行更新所以唯一 使用updateFirst 只更新第一条 mongoTemplate.updateFirst(id, Update.fromDocument(document),Student.class); // 更新所有能匹配的文档 // mongoTemplate.updateMulti(); } /** * 根据字段名称删除文档 * @param filedName 字段名称 * @param value 字段对应的值 */ public void deleteByFiledName(String filedName,String value){ Query query = Query.query(Criteria.where(filedName).is(value)); mongoTemplate.remove(query, Student.class); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"aliyun/阿里云域名.html":{"url":"aliyun/阿里云域名.html","title":"阿里云域名","keywords":"","body":"阿里云购买域名注册并登陆阿里云挑选并购买域名进入控制台备案解析域名阿里云购买域名 ​ 想要搭建一个网站肯定少不了一个域名,分享一下自己在阿里云购买域名的经验 ​ 还有一个提供免费域名的网站,我没有购买成功,每次购买都会有未知错误,所以就没有后续了,哈哈 [ https://www.freenom.com/zh/index.html?lang=zh]: 注册并登陆阿里云 ​ 可以选择直接使用支付宝登陆 挑选并购买域名 进入控制台备案 ​ 购买成功后点击右上角进入控制台,在顶部搜索栏输入域名进入域名控制台. ​ 现在还不能使用我们的域名,需要我们进行备案,添加域名模板 ​ 注意事项: ​ 身份证照片:会控制大小,55k-1MB左右需要注意一下.如果手机像素太高,可以拍完后使用QQ截图 ​ 地址信息:最好和你的身份证上一致 ​ 邮箱:可能会让你验证一下,记不太清楚了 ​ 备案验证成功后进入左侧列表中的域名列表,点击解析 解析域名 ​ 解析域名就是将你的域名指向网站IP,方便记忆 ​ 进入解析设置页面后点击添加记录,其中每个选项都有解释,添加记录的旁边还有新手引导 ​ 更详细的解释有阿里提供的文档:https://help.aliyun.com/knowledge_detail/29725.html ​ 10分钟左右就可以通过域名访问你的网站了 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"aliyun/OSS存储.html":{"url":"aliyun/OSS存储.html","title":"OSS存储","keywords":"","body":"阿里云OSS基本概念存储空间(bucket)访问域名(endpoint)访问秘钥(AccessKey)结合springboot使用pom依赖配置文件具体代码添加水印访问原图保护阿里云OSS 登录阿里云搜索对象存储 OSS进行开通 基本概念 文档: https://help.aliyun.com/document_detail/31827.html?spm=a2c4g.11186623.2.7.549b58d5qcqqsh#concept-izx-fmt-tdb 所需配置(概念)所在位置 首先需要进入对象存储OSS的控制台 存储空间(bucket) 注意下方还有一个读写权限,选择为公共读 访问域名(endpoint) 点击进入指定的bucket 访问秘钥(AccessKey) 结合springboot使用 jdk 1.8 springboot 2.1.0 pom依赖 com.aliyun.oss aliyun-sdk-oss 2.8.3 org.projectlombok lombok 1.18.4 joda-time joda-time 2.9.9 org.apache.commons commons-lang3 3.7 配置文件 创建alioss.properties文件,文件名可自定义 # 填写在基本概念中找到的值 aliyun.endpoint= aliyun.accessKeyId= aliyun.accessKeySecret= aliyun.bucketName= # 访问前缀,可以在具体的上传的文件中找到url aliyun.urlPrefix= # 测试用 #aliyun.param= 如果上传的文件过大,在主配置文件中添加 spring.servlet.multipart.max-file-size=10MB spring.servlet.multipart.max-request-size=20MB 具体代码 config // lombok 简化实体类操作 @Data // 指定该类是一个配置类 @Configuration // 指定配置文件 @PropertySource(\"classpath:alioss.properties\") // 指定配置参数的前缀 @ConfigurationProperties(prefix = \"aliyun\") public class AliOSSConfig { private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; private String urlPrefix; // 另一种方式从配置文件中读取参数 @Value(\"${aliyun.param}\") private String param; // 将OSSClient对象交由spring管理 @Bean public OSSClient ossClient(){ return new OSSClient(endpoint,accessKeyId,accessKeySecret); } } controller @RestController @RequestMapping(\"/pic/upload\") public class PicUploadController { @Autowired private PicUploadService picUploadService; @PostMapping public PicUploadResult upload(@RequestParam(\"file\") MultipartFile file){ return picUploadService.upload(file); } } service @Service public class PicUploadService { // 允许上传的格式 private static final String[] IMAGE_TYPE = new String[]{\".bmp\", \".jpg\", \".jpeg\", \".gif\", \".png\"}; @Autowired private OSS ossClient; @Autowired private AliOSSConfig aliOSSConfig; public PicUploadResult upload(MultipartFile uploadFile) { // 校验图片格式 boolean isLegal = false; for (String type : IMAGE_TYPE) { if (StringUtils.endsWithIgnoreCase(uploadFile.getOriginalFilename(), type)) { isLegal = true; break; } } // 封装Result对象，并且将文件的byte数组放置到result对象中 PicUploadResult fileUploadResult = new PicUploadResult(); if(!isLegal){ fileUploadResult.setStatus(\"error\"); return fileUploadResult; } // 文件新路径 String fileName = uploadFile.getOriginalFilename(); String filePath = getFilePath(fileName); // 上传到阿里云 try { ossClient.putObject(aliOSSConfig.getBucketName(), filePath, new ByteArrayInputStream(uploadFile.getBytes())); } catch (Exception e) { e.printStackTrace(); //上传失败 fileUploadResult.setStatus(\"error\"); return fileUploadResult; } fileUploadResult.setStatus(\"done\"); fileUploadResult.setName(this.aliOSSConfig.getUrlPrefix() + filePath); fileUploadResult.setUid(String.valueOf(System.currentTimeMillis())); return fileUploadResult; } // 用于生成文件夹及以时间戳命名的文件名 private String getFilePath(String sourceFileName) { DateTime dateTime = new DateTime(); return \"images/\" + dateTime.toString(\"yyyy\") + \"/\" + dateTime.toString(\"MM\") + \"/\" + dateTime.toString(\"dd\") + \"/\" + System.currentTimeMillis() + RandomUtils.nextInt(100, 9999) + \".\" + StringUtils.substringAfterLast(sourceFileName, \".\"); } } 将返回的数据进行封装 @Data public class PicUploadResult { // 文件唯一标识 private String uid; // 文件名 private String name; // 状态有：uploading done error removed private String status; // 服务端响应内容，如：'{\"status\": \"success\"}' private String response; } 添加水印 修改水印样式 访问 保存规则后之前的文件也会生效,只需在图片的路径后添加在访问设置时的自定义分隔符及水印规则名称 例如 原图保护 也就是在访问设置自定义分隔符的上方有一个原图保护,其功能为只有添加水印后才可访问,需要点击开启,选择*号应用于所有文件即可 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"swagger/SpringBoot整合Swagger2.html":{"url":"swagger/SpringBoot整合Swagger2.html","title":"Springboot整合Swagger2","keywords":"","body":"Swgger2依赖配置类示例代码其他主要注解Swgger2 ​ Swagger 是一个根据接口生成API文档,进行测试 ​ 这里主要是结合springboot方便测试使用 依赖 这里只列出springboot版本 以及swagger所需的依赖 org.springframework.boot spring-boot-starter-parent 2.2.0.RELEASE io.springfox springfox-swagger2 2.9.2 io.springfox springfox-swagger-ui 2.9.2 配置类 主要配置生成的API的title和开启Swagger接口文档 @Configuration //标记配置类 @EnableSwagger2 //开启在线接口文档 public class Swagger2Config { /** * 添加摘要信息(Docket) */ @Bean public Docket controllerApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(new ApiInfoBuilder() .title(\"接口测试\") .description(\"接口测试\") // .contact(new Contact(\"一只袜子\", null, null)) .version(\"版本号:1.0\") .build()) .select() .apis(RequestHandlerSelectors.basePackage(\"xyz.taoqz.controller\")) .paths(PathSelectors.any()) .build(); } } 示例代码 @Api(value = \"emp\") @RestController @CrossOrigin @RequestMapping(\"/emp\") public class EmpController { @Autowired private IEmpService iEmpService; @ApiOperation(value = \"根据id删除\",httpMethod = \"DELETE\") @DeleteMapping(\"/{id}\") public ResponseEntity deleteById(@PathVariable Integer id){ try { iEmpService.removeById(id); baseResult.setMsg(\"删除成功\"); baseResult.setStateCode(StateCode.SUCCESS); } catch (Exception e) { baseResult.setMsg(\"删除失败\"); baseResult.setStateCode(StateCode.FAIL); } return ResponseEntity.ok(baseResult); } } 生成后的api文档页面 访问接口: http://localhost:8080/swagger-ui.html 使用: 点击其中一个接口 Try it out 填写好参数后 Excute发送请求 推荐使用Idea中的插件RestServices,可以更加方便进行测试 其他主要注解 https://blog.csdn.net/xupeng874395012/article/details/68946676 https://blog.csdn.net/weixin_41846320/article/details/82970204 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"elementUI/ElementUI.html":{"url":"elementUI/ElementUI.html","title":"elementUI","keywords":"","body":"网站快速成型工具vue中使用安装与配置使用样例NavMenu导航菜单Table表格Pagination 分页Radio单选框Checkbox 多选框Tree 树形Tabs 标签页DatePicker 日期选择器Cascader级联选择器网站快速成型工具 ​ Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 vue中使用 安装与配置 // 安装 npm i element-ui // 配置 import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); 使用样例 NavMenu导航菜单 ​ default-active=\"2\" : 默认打开菜单的index ​ 设置为根据路由显示: ​ :default-active=\"$route.path\" ​ 同时在相同位置添加 :router=\"true\" 首页 xxx Table表格 ​ 获取当前行数据 { {scope.row} } Pagination 分页 Radio单选框 ​ 需要设置v-model绑定变量，选中意味着变量的值为相应 Radio label属性的值，label可以是String、Number或Boolean 禁用 Checkbox 多选框 ​ 注意 :label绑定对应id ​ value此时对应的应该是一个数字类型的数组 Tree 树形 // 数据格式 对应数据的字段名 defaultProps: { children: '', label: '' } // 获取值 // 全选 this.$refs.tree.getCheckedKeys()+'' // 半选 也就是父级 // this.$refs.tree.getHalfCheckedKeys() Tabs 标签页 ​ 标签 ​ js export default { name: 'home', data(){ return{ activename:'/home', tabs:[] } }, methods:{ // 点击选项卡后触发的方法 handleClick(tab, event) { // 跳转到对应选项卡的path this.$router.push(tab.name) }, // 添加选项卡 addTab(routeName,routePath){ // 如果是首页 不添加直接返回 if (routeName == 'home'){ return } // 设置标记 用来标记选项卡数组中是否已存在要添加的 // 如果存在 则选中该选项卡 let flag = true; this.tabs.forEach(ele => { if (ele.title == routeName){ flag = false; this.activename = ele.path } }) // 添加选项卡 // title 使用路由的名称 // path 使用路由的path if (flag){ this.tabs.push({ title: routeName, path: routePath }) // 将新添加的选项卡激活 this.activename = routePath } }, // 移除选项卡 removeTab(targetName){ this.tabs.forEach((ele,index) => { if (ele.path == targetName){ this.tabs.splice(index,1) } }) // 如果选项卡组中还有其他选项卡,将最后一个激活 否则跳转首页 if (this.tabs.length != 0){ this.activename = this.tabs[this.tabs.length-1].path this.$router.push(this.tabs[this.tabs.length-1].path) }else { this.$router.push('/home') } } }, // 监听路由 发生变化时添加选项卡 watch:{ '$route'(to,from){ this.addTab(to.name,to.path) } }, // 页面激活添加选项卡 mounted() { this.addTab(this.$route.name,this.$route.path) } } DatePicker 日期选择器 Cascader级联选择器 // 改变时触发的方法 data(){ return{ values:[], props:{ // 最后获取的是该value值 value:'', label:'', children:'' } } }, method:{ handleChange(value) { console.log(value); }, } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:31 "},"other/使用Google Cloud搭建ssr.html":{"url":"other/使用Google Cloud搭建ssr.html","title":"搭建SSR","keywords":"","body":"使用Google Cloud搭建ssr1.需要用到2.申请注册谷歌云3.创建实例4.创建防火墙规则5.开始搭建使用Google Cloud搭建ssr ​ 在youtube或者各种搜索引擎上已经有不少的视频和教程,写本文也是分享一下自己的经验:happy:。 ​ 谷歌云平台会赠送新用户300美金，免费使用一年，薅羊毛嘛:joy:。 1.需要用到 ​ 1.1.前置的科学上网工具 ​ 1.2.谷歌账号 ​ 1.3.支持外币支付的信用卡（ps.我申请的中国银行的万事达） ​ 这里放上我申请的信用卡链接:https://mp.weixin.qq.com/s/NXSM8C5mnq7I4NAlOOMlNw 2.申请注册谷歌云 ​ 2.1.地址:https://cloud.google.com/free/ ​ 2.2.其中的地区已经没有中国了选其他地区或国家,我选的香港,将自己的信用卡绑定后进入主页面 ​ 可以看到下图说明已经成功激活谷歌云了 3.创建实例 ​ 3.1.点击左上角菜单栏图标选中结算,去激活你的结算账号 ​ 3.2.选中Compute Engine ​ 3.3.创建实例详细信息 ​ 3.4.测试延迟 ​ 创建VM实例完成后,会有一个外部IP,复制该IP进行 ​ 测速:https://tools.ipip.net/traceroute.php ​ 延迟在50左右还行,100以下都能用,越小越好 4.创建防火墙规则 ​ 4.1选中菜单栏VPC网络点击防火墙规则 ​ 注意需要创建两个,下图中会有说明 5.开始搭建 ​ 5.1.在创建好的实例有一个SSH选择在浏览器窗口打开 ​ 依次输入以下命令 ​ 5.1.1. sudo -i 切换到root ​ 5.1.2. 安装SSR wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2>&1 | tee shadowsocksR.log ​ 5.1.3. ./shadowsocksR.sh 运行 ​ 5.2.回车运行后会看到下图,有解释说明 到此一个通过Google Cloud搭建的SSR就可以使用了:beers: Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "},"other/kaptcha验证码.html":{"url":"other/kaptcha验证码.html","title":"Kaptcha验证码","keywords":"","body":"Kaptcha结合springboot使用依赖配置类controllerKaptcha Kaptcha是一个高度可配置的生成验证码的工具 结合springboot使用 依赖 com.google.code.kaptcha kaptcha 2.3 配置类 @Configuration public class KaptchaConfig { @Bean public DefaultKaptcha getDefaultKaptcha(){ com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = new com.google.code.kaptcha.impl.DefaultKaptcha(); Properties properties = new Properties(); // 图片边框 properties.put(\"kaptcha.border\", \"no\"); properties.put(\"kaptcha.textproducer.font.color\", \"black\"); // 图片高宽 properties.put(\"kaptcha.image.width\", \"150\"); properties.put(\"kaptcha.image.height\", \"40\"); // 字体大小 properties.put(\"kaptcha.textproducer.font.size\", \"30\"); // 存在session中的key properties.put(\"kaptcha.session.key\", \"verifyCode\"); // 验证码长度 properties.put(\"kaptcha.textproducer.char.length\", \"5\"); // 文字间隔 properties.put(\"kaptcha.textproducer.char.space\", \"5\"); // 图片样式 properties.put(\"kaptcha.obscurificator.impl\", \"com.google.code.kaptcha.impl.FishEyeGimpy\"); Config config = new Config(properties); defaultKaptcha.setConfig(config); return defaultKaptcha; } } controller @Controller public class KaptchaController { @Autowired private DefaultKaptcha captchaProducer; @GetMapping(\"/kaptcha\") public void defaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { byte[] captchaOutputStream = null; ByteArrayOutputStream imgOutputStream = new ByteArrayOutputStream(); try { // 生产验证码字符串并保存到session中 String verifyCode = captchaProducer.createText(); System.out.println(verifyCode); httpServletRequest.getSession().setAttribute(\"verifyCode\", verifyCode); BufferedImage challenge = captchaProducer.createImage(verifyCode); ImageIO.write(challenge, \"jpg\", imgOutputStream); } catch (IllegalArgumentException e) { httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND); return; } captchaOutputStream = imgOutputStream.toByteArray(); httpServletResponse.setHeader(\"Cache-Control\", \"no-store\"); httpServletResponse.setHeader(\"Pragma\", \"no-cache\"); httpServletResponse.setDateHeader(\"Expires\", 0); httpServletResponse.setContentType(\"image/jpeg\"); ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream(); responseOutputStream.write(captchaOutputStream); responseOutputStream.flush(); responseOutputStream.close(); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-21 15:58:32 "}}