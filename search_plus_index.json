{"./":{"url":"./","title":"前言","keywords":"","body":"前言前言 ​ 学习笔记 ​ qq邮箱:2538474354@qq.com Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:27 "},"git/Git.html":{"url":"git/Git.html","title":"git安装及简介","keywords":"","body":"Git是什么及为什么使用安装及配置基本概念介绍常用流程冲突TortoiseGit:Idea配置git可能出现的问题1. 解决git clone 克隆慢2. 解决github.com 无法访问连接超时Git 是什么及为什么使用 ​ git是一个强大的版本控制工具 ​ 例如在企业团队开发中,需要协同开发,每个人负责不同的模块,但又有可能依赖其他的模块 ​ 使用git可以解决这些问题,同时还可以对版本进行严格的控制与管理 安装及配置 ​ 官网:https://git-scm.com/download ​ 一路点击下一步,取消最后的两个选项,点finish ​ 安装完成后 配置用户名和邮箱 配置后的文件在 C:\\Users\\{用户名}\\.gitconfig文件中 git config --global user.name \"taoqz\" git config --global user.email \"2538474354@qq.com\" ​ 生成ssh 秘钥与 github相关联 1. ssh-keygen -t rsa -C \"邮箱地址\" 默认生成到当前用户 C:\\Users\\{当前用户}\\.ssh\\id_rsa.pub 2. 进入github官网,登陆后 3. Settings --> SSH and GPG keys --> New SSH key 4. 将文件中的秘钥全部复制到 key 中 基本概念介绍 master : 默认开发分支 origin : 默认远程版本库 Index/Stage : 暂存区(工作区和版本库之间) add后的区域 workspace : 工作区 init后的区域 repository : 本地仓库 commit后的区域 remote : 远程仓库 github head : 指针 可以通过指针切换版本 常用流程 git init : 初始化仓库 把这个目录变成Git可以管理的仓库 git add 文件名: 添加文件 直接写符号.将(全部文件) 把文件添加到本地仓库的暂存区 git commit -m \"提交 注释\" 提交到当前分支 git remote add origin 远程仓库地址 ：远程仓库与本地仓库添加关联 有关联后,就不用再写这行 git pull origin master : 在推之前先拉 更新代码 git push -u origin master 将代码推到远程仓库 冲突 ​ 对同一行或者同一块区域的代码进行修改后,导致本地仓库与远程仓库无法合并,因为软件也不知道采用哪一段代码,需要人工解决 这是出现冲突后在推时出现的情况 冲突:不同的人修改了相同位置的代码 ======= 其他人的代码 >>>>>>>版本号(具体的版本号可以在命令行中查询) 手动解决冲突后提交或合并后提交即可 TortoiseGit: ​ 使用git bash 需要很多重复的操作克隆 提交 推送,可以使用视图化工具简化操作 ​ 官网:https://tortoisegit.org/download/ ​ ​ 点击finish后,会进入配置 ​ 填入用户名和邮箱 ​ 安装完成后可能会需要重启 重启完成后点击鼠标右键会出现 ​ TortoiseGit --> settings 选择下方选项进行配置 安装完成后,在任意位置鼠标右键,可以完成快速克隆 提交... Idea配置git ​ Settings --> Version Control ​ 登录 ​ 如果选择上方的Enter token 登录 ​ 需要登录github官网 创建token ​ ​ 可能出现的问题 1. 解决git clone 克隆慢 ​ 开启代理(本人使用的ssr 默认端口是1080): git config --global http.proxy socks5://127.0.0.1:1080 ​ 关闭代理: git config --global http.proxy \"\" ​ 如果代理没有关闭可能也会出现 fatal: unable to access 'https://github.com/xxx/xxx.git/': Failed to connect to 127.0.0.1 port 1080: Connection refused ​ 可以使用命令关闭也可以在 C:\\Users\\{用户名}\\\\.gitconfig 中删除proxy代理 2. 解决github.com 无法访问连接超时 ​ 先在命令行ping官网 github.com ​ 如果ping不通 ​ 在 C:\\Windows\\System32\\drivers\\etc\\hosts 末尾添加 192.30.255.112 github.com git 185.31.16.184 github.global.ssl.fastly.net ​ Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:27 "},"git/Idea中使用Git.html":{"url":"git/Idea中使用Git.html","title":"Idea使用Git","keywords":"","body":"配置使用1. 创建项目2. 添加文件3. 提交并推送4. 冲突配置 ​ 在git一章中有写在Idea中如何配置git 使用 1. 创建项目 ​ idea中创建项目 相当于 init 将当前项目变为工作空间 ​ github中创建新的仓库 2. 添加文件 ​ 相当于 add (文件) ​ 3. 提交并推送 ​ 在idea菜单栏VSC选项 相当于 commit ​ 选择需要提交的文件,在Commit Message 中填写信息,选择commit and push ​ 选择commit和push后,在第一次push时会遇到下图,需要将当前工作空间与远程仓库进行关联 ​ 填写完成后便可以进行推送 ​ 4. 冲突 ​ 不同的人在对相同行数的代码进行修改时,一方已经提交,另一方在拉取或者推送时会遇到冲突的问题 案例: ​ 第一次提交的代码 ​ 假设有人修改了代码,并上传成功 ​ 同时修改idea中的代码 ​ 进行commit 提交后进行pull 拉取 ​ 会出现冲突提示 ,点击中间的合并按钮 ​ 进行合并 ​ 合并后重新提交 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:27 "},"vue/Vue.html":{"url":"vue/Vue.html","title":"Vue基础","keywords":"","body":"Vue1.Vue是什么2.使用Vue2.1使用cdn2.2官网下载3.入门案例4.方法5.生命周期6.指令7.计算属性8.axios9.路由9.1. router-link & router-view9.2配置路由:9.3.style scope9.4.export default9.5. 路由传参9.6.路由跳转9.7.嵌套路由10.Vuex10.1.什么是Vuex,为什么要有Vuex10.2.在项目中使用vuex10.3.访问vuex中的数据及方法10.4. 案例,使用并修改state中的数据10.5. 在Vuex中跳转组件(使用路由)10.6. mutations传参问题10.7. 注意事项11.组件之间传值11.1. 父传子11.2 . 子传父11.3. 非父子组件之间传值Vue 1.Vue是什么 ​ Vue是一套用于构建用户界面的渐进式框架(可以循序渐进的进行学习),是一个MVVM的框架,功能强大,重要特点双向绑定 ​ MVVM: ​ M:model,数据/模型层 ​ V:view 视图层 ​ VM:核心层,负责连接M和V,这一层已经由Vue实现好了 ​ 双向绑定: ​ 更新view页面的数据同步到data ​ 更新data中的数据同步渲染到页面 2.使用Vue ​ 以下案例的github地址:https://github.com/TaoQZ/Vue_example.git 2.1使用cdn 2.2官网下载 https://cn.vuejs.org/v2/guide/installation.html 3.入门案例 Title // 创建vue实例 // el 获取指定id的容器 // data 数据 // methods 方法 var vm = new Vue({ el:'#app', data:{ msg:'测试' }, methods:{ } }) 4.方法 var vm = new Vue({ methods:{ fun1:function () { console.log('方法1') }, fun2(){ console.log('方法2') }, // 箭头函数 // 1. 没有参数,或多个参数使用 () (a,b) // 2. 一个参数可以省略() 直接写形参 a // 3. 返回值 只有一行代码包括返回值 可以省略{} // 4. 多行代码需要 {} // 5. 注意 使用该箭头函数定义方法时,方法中this的指向不在再是Vue实例 fun3: () => console.log('方法3') } }); vm.fun1(); vm.fun2(); vm.fun3(); 5.生命周期 var vm = new Vue({ el:'#app', data:{ msg:'+' }, methods:{ show(){ console.log('我是show方法') } }, // 初始化前 数据和方法均为未初始化 beforeCreate(){ // undefined console.log(this.msg) // this.show is not a function this.show() console.log('=======================================') }, // 初始化完成 数据和方法已初始化完成 created(){ // 全部正常打印 console.log(this.msg) this.show() console.log('=======================================') }, // 双向绑定(挂载)前,表示模板已经编译完成,但是未将模板渲染到页面中 beforeMount(){ // 未渲染状态,只是原始字符串 console.log(document.getElementById('app').innerText) console.log('=======================================') }, // 双向绑定(挂载)后,将数据渲染到页面 mounted(){ // + console.log(document.getElementById('app').innerText) console.log('=======================================') }, // 更新钩子函数需要改变数据才会触发 // 更新前 data中的数据已经发生变化 未渲染到页面(页面还没同步) beforeUpdate(){ // + console.log(\"更新前\"+this.msg) // - console.log(\"更新前\"+document.getElementById('app').innerText) }, // 更新后 updated(){ // - console.log(\"更新后\"+this.msg) // - console.log(\"更新后\"+document.getElementById('app').innerText) }, // 销毁Vue实例 beforeDestroy(){ console.log('销毁前'+this) }, destroyed(){ console.log('销毁后'+this) } }) // 销毁Vue实例 vm.$destroy(); 6.指令 6.1.插值表达式 ​ 格式:{{}} ​ 可以直接获取Vue实例中定义的数据或函数 ​ 支持有返回值的函数或表达式 ​ 注意:该方式有缺点,在网速较慢时会出现{{}} 闪烁问题 2 var vm = new Vue({ el:'#app', data:{ msg:'zz' }, methods:{ show(){ return 10 } } }) 6.2. v-text v-html ​ 为了解决插值闪烁问题提供了解决办法 ​ v-text : 将数据原样输出 ​ v-html : 可以将html的字符串渲染到页面 ​ var vm = new Vue({ el:'#app', data:{ msg:'tao' } }) 6.3.v-model 加 表单元素 ​ 插值表达式,v-text,v-html : 只是数据的单向绑定 ​ v-model可以使视图和数据进行双向绑定,互相影响 ​ Title hobby: 网球 游泳 跑步 sex: 男 女 单复选框： 下拉列表 请选择 // 注意: 在data中拿到的值是标签的value值 var vm = new Vue({ el:'#app', data:{ num:1, hobby:[], checked: true, sex:'male', items:['河北','天津','北京'], province:'' } }) 6.4.v-on ​ 例子 涉及事件 ​ click keydown mouseover mouseout ​ 事件处理的指令 var vm = new Vue({ el:'#app', methods:{ show(e){ console.log(e.keyCode) }, inDiv(){ console.log(\"鼠标移入\") }, outDiv(){ console.log(\"鼠标移出\") }, buttonClick(){ console.log('点击事件') }, isEnter(e){ console.log(e.keyCode) } } }) ​ 6.5. 事件冒泡+vue解决办法_按键修饰符 ​ 事件发生时,触发内层的事件会同时触发外层的事件 ​ 常用按键修饰符 ​ .enter // 表示键盘的enter键 .tab .delete (捕获 \"删除\" 和 \"退格\" 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta 百度 var vm = new Vue({ el:'#app', methods:{ divClick(){ console.log('div') }, buttonClick(e){ // js中冒泡的解决方案 // 阻止事件的传播行为 // e.stopPropagation(); console.log('button') }, jump:()=>{ console.log('点击a标签后没有跳转网页') }, isEnter(e){ console.log(e.keyCode) } } }) 6.6.v-for --------- var vm = new Vue({ el:'#app', data:{ users:[ {name:\"aa\",age:\"23\",sex:\"男\"}, {name:\"bb\",age:\"21\",sex:\"男\"}, {name:\"cc\",age:\"20\",sex:\"男\"} ] } }) 6.7.v-if v-else-if v-else ​ v-else 必须紧跟在 v-if 或 v-else-if 后 ​ v-else-if 必须紧跟在v-if 或者 v-else-if 后 ​ A B C 索引 姓名 年龄 性别 20\"> {{index}} {{user.name}} {{user.age}} {{user.sex}} var vm = new Vue({ el:'#app', data:{ char:'A', users:[ {name:\"aa\",age:\"23\",sex:\"男\"}, {name:\"bb\",age:\"21\",sex:\"男\"}, {name:\"cc\",age:\"20\",sex:\"男\"} ] } }) ​ 6.8.v-show与v-if flag flag var vm = new Vue({ el:'#app', data:{ flag:true }, methods:{ change(){ this.flag = !this.flag } } }) 6.9. v-bind ​ 将html标签的属性与data中的数据进行绑定,可以简写为 :需要绑定的属性 Title .red{ background-color: red; } .black{ background-color: black; } .green{ background-color: green; } 请选择 var vm = new Vue({ el:'#app', data:{ myclass:'', colors:[ {name:'红',clas:'red'}, {name:'黑',clas:'black'}, {name:'绿',clas:'green'} ] } }) ​ 7.计算属性 ​ 解决在插值表达式中书写过长或需要长期维护使用的表达式比较麻烦 var vm = new Vue({ el:'#app', data:{ msg:'' }, methods:{ method_num(){ return 1+1; } }, computed:{ computed_num(){ return 2+1; } } }) 8.axios ​ 用于发送http请求 ​ cdn 在使用vue-cli脚手架创建的项目中使用 下载依赖 npm install axios 在项目中引入 全局引入需要在main.js中导入 局部引入需要在export default 上导入: // 导入 axios import axios from 'axios' // 设置请求路径的前缀 axios.defaults.baseURL='http://localhost:8080' // 第一个axios可以当做全局的访问前缀 Vue.prototype.axios(相当于起别名) = axios 示例: 全局 全局需要使用this. 局部不需要 export default { name: \"list\", data(){ return{ users:[] } }, methods:{ findAll(){ this.axios.get('/user') .then(res => this.users = res.data) }, created() { this.findAll(); } } ​ 2.局部 // 局部引入axios 不需要this // import axios from 'axios' // axios.defaults.baseURL='http://localhost:8080' export default { name: \"list\", data(){ return{ users:[] } }, methods:{ findAll(){ axios.get('/user') .then(res => this.users = res.data) } }, created() { this.findAll(); } } ​ git传递对象参数 this.axios.get('url',{ params : 对象 }) ​ delete传递参数 数组 ​ 需要配合qs使用 安装 npm install qs main.js 中配置 import qs from 'qs' Vue.prototype.qs = qs this.axios.delete(\"/book\", { params: { books: arr }, paramsSerializer: params => { // false 用来控制格式 return qs.stringify(params, { indices: false }) } }).then(() => { this.getPageInfo(this.num, this.size); }) 9.路由 9.1. router-link & router-view : : 9.2配置路由: ​ 使用vue-cli创建项目后就已做好的: ​ 在router/index.js文件中 导入 vue-router并使用 // 导入 导入时名字可以随便起,但在use名字时必须相同 import Vue from 'vue' import VueRouter from 'vue-router' // 导入组件 全局引入 import Home from '../views/Home' // 使用 Vue.use(VueRouter) // 创建路由 数组 const routes = [ // path:访问路径 // name:路由名称 // component:要跳转到的组件 需要导入 { // 写路径时记得写 / path: '/', name: 'home', component: Home, // 再使用时引入的方式,可以提高首页显示速度 // component: () => import('../views/Home.vue') } ] ​ main.js import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false; new Vue({ router, // 相当于 router:router store, render: h => h(App) }).$mount('#app'); 9.3.style scope 9.4.export default // 就是vue的实例 是es6的语法 和之前写的差别是,data只能按照这种格式(和写时组件一样) export default { name: \"list\", methods:{ to(){ alert(\"list\") } }, data(){ return{ msg:'msg' } } } 9.5. 路由传参 ​ 1.name+params 修改 ​ // 接收 this.$route.params.id ​ 2.path+query 修改 // 接收 this.$route.query.id; ​ 3.路由传参(地址栏) // 在路由的path后添加 :参数名 { path: '/edit/:id', name: 'edit', component: Edit } 修改 9.6.路由跳转 this.$router.push(路由的path) 9.7.嵌套路由 ​ 在一个组件中引入了另一个组件,相当于父与子的关系 我是父页面 去子页面 我是子页面 ​ router/index.js 配置 const routes = [ // path:访问路径 // name:路由名称 // component:要跳转到的组件 需要导入 { path: '/father', name: 'father', component: () => import('../views/father.vue'), children:[ { // 注意子路由不能加 / path: 'son', name: 'son', component: () => import('../views/son.vue'), }, // 子路由path的第二种写法,访问路径加上父组件的路径 // { // path: '/home/son', // name: 'son', // component: () => import('../views/son.vue') // } ] } ] 10.Vuex 10.1.什么是Vuex,为什么要有Vuex ​ Vuex是组件之间数据共享的一种机制 ​ 使用父子传值或兄弟传值,太麻烦不好管理,有了Vuex想要共享数据,只需要把数据挂在到vuex就行,想要获取数据,直接从vuex上拿就行,vuex中的数据被修改后其他引用了此数据的组件,也会同步更新 10.2.在项目中使用vuex ​ 安装vuex: npm install vuex ​ 使用 在store/index.js文件 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ // 公共区域数据 state: { num : 10, msg : 'zz' }, mutations: { }, actions: { }, modules: { } }) 在main.js文件中将store挂在到vm实例上 import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false new Vue({ router, store, render: h => h(App) }).$mount('#app') 10.3.访问vuex中的数据及方法 ​ 数据 this.$store.state.变量名 vue官方并不推荐通过上面的方式获取数据 使用结构表达式 在组件内导入 import {mapState} from 'vuex' 创建一个computed属性 // 官方推荐的使用方式,进行结构,将公共属性的值作为计算属性 computed:{ ...mapState(['num','msg']) }, ​ 方法 ​ 登录案例 登录 账号: 密码: import {mapActions} from 'vuex' export default { methods:{ ...mapActions(['login']), }, name: \"Login\", data(){ return{ user:{} } }, } actions: { // 第一个参数默认 login(context,user){ // 调用的mutations中的方法,进行封装使之可以提交异步请求 context.commit('login',user) } }, 10.4. 案例,使用并修改state中的数据 在store/index.js中定义变量存储数据 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ // 公共区域数据 state: { num : 10, }, mutations: { addNum(state){ state.num++ } }, actions: { }, modules: { } }) 在components中创建两个组件 ​ app.vue --> add: --> add: num: // 结构表达式 import {mapState} from 'vuex' import {mapMutations} from 'vuex' export default { name: \"add\", // 官方推荐的使用方式,进行结构,将公共属性的值作为计算属性 computed:{ ...mapState(['num','msg']) }, methods:{ add(){ this.$store.state.num++ }, ...mapMutations(['addNum']) } } ​ minus.vue // 解构 将vuex中的数据解构成计算属性使用 import {mapState} from 'vuex' export default { name: \"add\", methods:{ }, computed:{ ...mapState(['num']) } } ​ router/index.js // 将这两个组件导入 import add from '@/components/add.vue' import minus from '@/components/minus.vue' const routes = [ { path:'/访问路径', name:'home', components:{ add, minus } }, ] ​ ​ App.vue:用于显示变量,观察其修改后组件中数据是否同步更新 10.5. 在Vuex中跳转组件(使用路由) ​ 在Vuex中访问不到路由实例 ​ 需要导入 // 导入 import router from '../router'; // 使用 router.push({path:'/'}) 10.6. mutations传参问题 ​ 如果在调用mutations中的方法时,方法有多个参数,后面的参数是undefined ​ 将参数封装成对象进行传值 10.7. 注意事项 ​ 如果想获取有返回值的方法(对state中的数据有所更改后),可以在getters中创建方法,并 返回处理后的结果,使用this.$store.getters.方法名获取 ​ vue推荐使用mutations来对state中的数据进行修改,mutations中的方法第一个参数必 须是state,也就是当前vuex中的state,可以直接调用 ​ actions:包裹mutations中的方法,异步调用 ​ 例子: mutations:{ // 第一个参数必须是state addNumS(state,step){ state.num += step }, }, actions: { // 第一个参数必须是context step:参数 addNumSAysc(context,step){ // 利用context来调用mutations的方法来操作state中的数据 context.commit('addNumS',step) } }, 11.组件之间传值 11.1. 父传子 ​ 父组件 我是父组件 // 导入子组件 import son from '@/views/Son' export default { name: \"Parent\", data(){ return{ msg : '我是父组件中的数据' } }, // 注册使用 components:{son} } ​ 子组件 我是子组件: export default { name: \"Son\", // 定义props属性用来接收父组件的数据 props:['sonMsg'] } 11.2 . 子传父 ​ 父组件 我是父组件 我是子组件传递到父组件的数据: // 导入子组件 import son from '@/views/Son' export default { name: \"Parent\", data(){ return{ msg : '我是父组件中的数据', sonMs: '' } }, methods:{ sonSMsg(msg){ this.sonMs = msg } }, // 注册使用 components:{son} } ​ 子组件 我是子组件中的按钮 export default { name: \"Son\", data(){ return{ msg:'我是子组件中的数据' } }, methods : { sendMsgToParent(){ this.$emit('fromSon',this.msg) } } } 11.3. 非父子组件之间传值 ​ 设立公共数据文件 ​ Bus.js // 导入vue import vue from 'vue' // 创建vue对象 export default new vue() ​ Demo01.vue // 导入 兄弟组件 为了将其显示在同一个页面 import demo02 from '@/views/Demo02' // 导入Bus.js 公共数据文件 import bus from './Bus.js' export default { name: \"Demo01\", data(){ return{ msg : '我是demo01中的数据' } }, methods:{ sendMsgToDemo02(){ // 固定格式 bus.$emit('fromDemo02',this.msg) } }, components:{demo02} } ​ Demo02.vue 我是demo02: 我是传递过来的数据:插值表达式 msg // 导入Bus.js 公共数据文件 import bus from './Bus.js' export default { name: \"Demo02\", data(){ return{ msg : '' } }, created() { // 固定格式 data就是传递过来的数据 bus.$on('fromDemo02',data => { this.msg = data }) } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:29 "},"vue/vue面试题.html":{"url":"vue/vue面试题.html","title":"Vue面试题","keywords":"","body":"1.MVVM中,MVVM分别代表什么?作用是什么2.简述什么是单页,以及单页的优缺点3.Vue项目中的src文件夹一般放置那些文件及文件夹4.简述vue的声明周期及钩子函数5.前后台分离,怎么解决跨域问题6.Vue-router的作用是什么7.Vue中父子组件之间如何传值是怎么实现的8.Vue如何传参9.Vuex怎么实现数据共享10.Vue的全家桶有哪些11.Vue的导航守卫是什么?有什么作用?12.Vuex的五大核心属性13.var let const的区别14.Vue中常用的指令15.Vue中的事件修饰符16.什么是js的冒泡事件17.什么是计算属性,如何理解18.import.export导入和导出1.MVVM中,MVVM分别代表什么?作用是什么 ​ MVVM是model-view-viewModel的简写,是MVC的改进版 ​ 为了分离model(模型)和view(视图),再由viewModel将v和m连接起来 ​ 当model(模型)发生改变时,通过MVVM框架自动更新view视图状态 ​ 当view(视图)发生改变时,通过MVVM框架自动更新model模型数据 2.简述什么是单页,以及单页的优缺点 ​ 总:项目中只有一个html页面,由多个组件构成 ​ 优点:速度快,用户体验好,修改内容不会刷新整个页面,因此,spa对服务器的压力也会变小;前后端分离;页面效果炫酷(比如切换页面时的专场动画) ​ 缺点:初次加载耗时长;提高页面复杂度;不利于seo;导航不可用,如果需要使用需要自行完成后退前进功能 3.Vue项目中的src文件夹一般放置那些文件及文件夹 ​ assets:静态资源目录 ​ components:功能组件 ​ views:页面组件 ​ store:vuex的数据 ​ router:路由文件 ​ App.vue:入口页面 ​ main.js:全局的配置文件 4.简述vue的声明周期及钩子函数 ​ vue的生命周期就是该vue实例从创建到销毁的过程 ​ beforeCreat:创建完成之前,数据未完成初始化 ​ created:创建完成后,数据已完成初始化,一般用于页面渲染 ​ beforeMount:双向绑定前 ​ mounted:双向绑定后 ​ beforeUpdate:更新前 ​ updated:更新后 ​ beforeDestroy:销毁前 ​ destroyed:销毁后 5.前后台分离,怎么解决跨域问题 ​ 1.jsonp:叫古老的方式,利用script标签可跨域的特性,缺点是只能发送get请求 ​ 2.nginx:配置代理服务器,使其可以访问目标服务器,然后再将目标服务器返回的数据返回到我们的客户端,可以发送各种请求 ​ 3.比较常用的cors,需要后端设置Access-control-Allow-Origin头,可以自行配置可跨域的地址,缺点是可能会发生两次请求 6.Vue-router的作用是什么 ​ vue-router是vue.js官方的路由管理器 ​ :完成组件之间的切换 ​ this.$route : 完成组件之间的传参 ​ this.$router.push():完成组件之间的跳转 7.Vue中父子组件之间如何传值是怎么实现的 ​ 1.父传子:在子组件中设置props属性用于接受父组件传递的数据 ​ 2.子传父:子组件触发自身的方法,使用$emit调用父类的监听的方法 ​ 3.非父子组件:需要设立公共的文件 8.Vue如何传参 ​ 1.query+path 传参: 获取值: this.$route.query.参数名 ​ 2.params+name 传参: 获取值: this.$route.params.参数名 ​ 3.路由传参(地址栏) 在路由组件的配置上添加 { path:'/path/:参数名' name: component: } 获取值: this.$route.params.参数名 9.Vuex怎么实现数据共享 ​ vue整合vuex,在main.js中以组件的方式导入store.js文件 ​ 在store.js文件的state区域保存数据,使之可以在任何位置可被访问 ​ 使用store.js文件中的mutations可以更新state区域的数据,通过读写完成数据的共享 10.Vue的全家桶有哪些 ​ Vue的两大核心: ​ 组件化:将一个整体应用,拆分成多个可复用的个体(组件) ​ 数据驱动:在修改数据的前提下,不操作dom,直接影响bom显示 ​ vue-router:路由,组件之间的切换 ​ vue-cli:构建vue单页应用的脚手架工具 ​ vuex:状态数据 ​ axios:vue官方推荐的发送http请求的工具包 11.Vue的导航守卫是什么?有什么作用? ​ vue-rouer提供的导航钩子,主要用来拦截导航,完成跳转或取消,有多种方式可以在路由导航发生时执行路由导航钩子 ​ 全局的: ​ router.beforeEach在全局注册一个before钩子 ​ 单个路由独享的: ​ 在路由配置中直接定义一个beforeEnter路由导航钩子 ​ 组件级别的: ​ beforeRouteEnter,beforeRouteUpate,beforeRouteLeave ​ 直接在路由组件中定义路由导航钩子 12.Vuex的五大核心属性 ​ Vuex是专门为vue.js应用设计的状态管理架构 ​ 1.state:基本数据 ​ 2.getters:从基本数据派生的数据 ​ 3.mutations:更改数据的提交方式,同步 ​ 4.actions:像一个装饰器,用来包裹mutations,使之可以异步 ​ 5.modules:模块化vuex 13.var let const的区别 ​ var是es3提供的创建变量的关键字,定义的变量为全局变量 ​ let是es6新增的定义变量的关键字,定义的变量是局部变量 ​ const定义的变量的常量 14.Vue中常用的指令 ​ v-if:当条件为true时,显示该元素 ​ v-show:修改页面元素的css样式完成显示或隐藏 ​ v-on:为标签添加事件 ​ v-model:双向绑定,用于数据和视图的同步 ​ v-bind:将数据绑定的标签的属性上 ​ v-for:遍历数组 15.Vue中的事件修饰符 ​ .stop:阻止冒泡 ​ .prevent:禁止默认事件 ​ .capture:捕获 ​ .once:只执行一次 ​ .self:只在自身触发 16.什么是js的冒泡事件 ​ 当触发页面中标签的事件时,会同时触发其所有父与子标签的事件,直到跟标签 17.什么是计算属性,如何理解 ​ 计算属性本质是一个有返回值的方法,在页面渲染时,可以将该方法当做一个属性使用,当data中的数据未发生改变时,计算属性直接读取缓存 18.import.export导入和导出 ​ 是es6中,module主要构成的两个命令 ​ export:用于导出模块中的变量的接口 ​ import:用于在一个模块中导入另一个含有export接口的接口 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:29 "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring","keywords":"","body":"Springday01XML方式注解方式@ComponentScan自定义一个扫描过滤类TypeFilter@ComponentScans@Scope作用域@Lazy懒加载day02@Conditional条件注册Bean@Import注册BeanFactoryBeanday03Bean的声明周期自定义初始化销毁方法BeanPostProcessor接口day04@Value 赋值关于自动装配day05day08spring使用事务day11springmvc自定义配置Spring day01 ​ context包提供了IOC容器功能 ​ IOC就是一个大的Map集合,key就是name,value就是对象 XML方式 public class XmlTest { @Test public void demo(){ ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = classPathXmlApplicationContext.getBean(\"user\"); System.out.println(user); } } 注解方式 // 使用注解方式的配置类 @Configuration public class SpringConfig { // 可以自定义name,默认是方法名 @Bean public User getUser(){ return new User(); } } public class AnnoTest { @Test public void demo(){ AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); User user = (User) app.getBean(\"getUser\"); System.out.println(user); // 根据类获取该类在容器中的name String[] beanNamesForType = app.getBeanNamesForType(User.class); // 获取容器中所有的name String[] names = app.getBeanDefinitionNames(); } } @ComponentScan ​ 该注解写在配置类用于扫描其他其他包中的组件@Controller @Service @Repository 这三个组件最顶层是@Component ​ 默认的name是类名首字母小写 ​ 通过该注解扫描得到的Bean和在配置类中使用@Bean注解得到的Bean是一个级别的 // 扫描时进行包含过滤,过滤类型默认为注解,classes的值则是最后包含的组件 // 需要将默认的过滤方式禁用 false // FilterType 常用类型还有自定义 也就是指定哪些类 ASSIGNABLE_TYPE // useDefaultFilters的作用是 是否开启扫描其他组件默认为true 包含时设置为false,排除某个类型时为true @Configuration @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}) },useDefaultFilters = false) // public class SpringConfig { } 主要属性 value：指定要扫描的package； includeFilters=Filter[]：指定只包含的组件 excludeFilters=Filter[]：指定需要排除的组件； useDefaultFilters=true/false：指定是否需要使用Spring默认的扫描规则：被@Component, @Repository, @Service, @Controller或者已经声明过@Component自定义注解标记的组件； 在过滤规则Filter中： FilterType：指定过滤规则，支持的过滤规则有 ANNOTATION：按照注解规则，过滤被指定注解标记的类； ASSIGNABLE_TYPE：按照给定的类型； ASPECTJ：按照ASPECTJ表达式； REGEX：按照正则表达式 CUSTOM：自定义规则； value：指定在该规则下过滤的表达式； 自定义一个扫描过滤类TypeFilter 过滤类: public class CustomTypeFilter implements TypeFilter { /** * 读取到当前正在扫描类的信息 * @param metadataReader * 可以获取到其他任何类的信息 * @param metadataReaderFactory * @return * @throws IOException */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { // 获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); // 获取当前正在扫描的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); // 获取当前类路径 Resource resource = metadataReader.getResource(); System.out.println(classMetadata.getClassName()); // 可以在此处进行判断,根据类信息进行过滤 return false; } } 配置类: @Configuration @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { // 将过滤类型改为CUSTOM自定义,classes的值为自定义的过滤类 @ComponentScan.Filter(type = FilterType.CUSTOM,classes ={CustomTypeFilter.class}) },useDefaultFilters = false) public class SpringConfig { } ​ @ComponentScans // (可以声明多个@ComponentScan) @ComponentScans({@ComponentScan(\"xyz.taoqz\"), @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {CustomTypeFilter.class}) },useDefaultFilters = false) }) public class SpringConfig { } @Scope作用域 @Configuration public class SpringConfig { // 无论是使用@Bean还是其他组件的注解,默认都是单例的 @Bean /** * 更改作用域 * singleton: 单实例,IOC容器启动时会调用方法创建对象并放到IOC容器中,以后获取时拿的是同一个对象 * prototype: 多实例,IOC容器启动时并不会调用方法创建对象,而是每次使用时用方法创建对象 * request: 一个请求一个实例 * session: 同一个会话一个实例 */ @Scope(\"PROTOTYPE\") public User getUser(){ return new User(); } } @Lazy懒加载 ​ 懒加载:主要针对单例Bean在容器启动时创建对象,设置懒加载后,容器启动后不再创建对象,但是可以在容器中获取其beanname,在第一次使用时才会创建对象初始化 ​ 如何使用懒加载? ​ 在@Bean注解或者其他组件上添加@Lazy注解 ​ 代码示例: @Configuration public class SpringConfig { @Bean @Lazy public User getUser(){ System.out.println(\"向容器中添加对象\"); return new User(); } } public class LazyTest { @Test public void fun(){ AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); System.out.println(\"容器创建完成\"); app.getBean(\"getUser\"); } } console: 容器创建完成 向容器中添加对象 使用懒加载后,会先创建容器,然后在获取Bean时才会向容器中添加对象并获得 day02 @Conditional条件注册Bean ​ @Conditional(Class [] value()) ​ 写在类上表示该类或者该配置类下所有Bean必须符合条件才会注册,和@Bean一起写在方法上表示该方法返回值能否注册 ​ 该注解的参数是一个Condition的实现类,实现其方法,可以判断Bean满足需求时进行注册 public class MyCondition implements Condition { /** * 判断条件可以使用的上下文(环境0 * @param context * 注解的信息 * @param metadata * @return */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 可以在此处进行逻辑判断 返回true时Bean实例才会注入到容器中 return false; } } @Import注册Bean ​ @Import(Class [] value()) : 参数时要注册的Bean的class数组 回顾注册Bean的几种常用的方式 ​ 1.在配置中使用@Bean的方式将方法的返回值注册到容器中,通常是使用第三方类库时使用使用组件加包扫描的方式,一般用于自定义 ​ 2.组件注解:@Component @Controller @Service @Repository ​ 包扫描:@ComponentScan(组件注解所在的包) ​ 此方法优先级高于Import方式使用@Import注解 ​ 3.使用@Import方式注册的Bean其name是类全路径(包名+类名) ​ 回顾使用其他方式时的name(没有指定名称的情况下) ​ @Bean : 方法名 ​ 组件 : 类首字母小写 ​ 4.使用FactoryBean 下方有解释 ImportSelector自定义注册Bean // 在配置类中添加 @Import(value = {MyImportSelector.class}) public class MyImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { // 返回需要注册到容器中的Bean的全类名数组 return new String[0]; } } ImportBeanDefinitionRegistrar手动注册Bean // 在配置类中添加 // @Import(value = {MyImportBeanDefinitionRegistrar.class}) public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { /** * 当前类的注解信息 * @param importingClassMetadata * BeanDefinition注册类 * 把所有需要添加到容器中的Bean加入 * @param registry */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // 该方法可以判断容器中是否有指定name的Bean registry.containsBeanDefinition(\"\"); // 使用该方式注册Bean时,需要手动给出Bean的信息 Spring提供了RootBeanDefinition类 // 调用注册Bean的方法手动将Bean的name 和 信息注册到容器中 // IDEA中双击Shift键 搜索DefaultListableBeanFactory 类 会调用该类中的registerBeanDefinition将Bean注册到容器中 RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Animal.class); registry.registerBeanDefinition(\"animal\",rootBeanDefinition); } } FactoryBean ​ 如果想创建一个工厂类,用来灵活的创建对象并且想要交由Spring管理,可以使用该类 ​ 需要注意的是getBean时获取的对象并不是Factory本身,而是其getObject()方法的返回值返回的具体类型 ​ 想要获取该类对象在getBean()中的beanname参数前加&,底层在获取对象时会先判断beanname是否以&开头 ​ 使用方式:实现改接口,并且重写方法,将该类注入到容器中 Object getObject() : 该方法则为实际返回的对象 Class getObjectType() : 对象的类型 boolean isSingleton() : 表示对象注入容器时是否单例 day03 ​ Bean的声明周期 ​ 创建 : 构造方法 ​ 初始化 : 指定的初始化方法 ​ 销毁 : 指定的销毁方法 ​ 会在容器关闭或移除对象时执行 ​ 创建和初始化会在容器创建完成前 自定义初始化销毁方法 ​ xml方式 ​ 注解方式1 @Bean(initMethod = \"初始化方法名\",destroyMethod = \"销毁方法名\") public Person person(){ return new Person(); } ​ 注解方式2 ​ 属于JDK的注解 ​ @PostConstruct : 初始化方法 ​ @PreDestroy : 销毁方法 @Component public class Person { public Person() { System.out.println(\"创建Person\"); } // 对象创建并赋值后调用 @PostConstruct public void init(){ System.out.println(\"Person 初始化\"); } // 容器移除对象调用 @PreDestroy public void destory(){ System.out.println(\"Person销毁\"); } } ​ spring 提供的接口 ​ InitializingBean, DisposableBean : 实现该接口完成init和destroy ​ 注意:只有单实例在容器创建时才会执行Bean的创建和初始化,并添加到容器中 ​ 多实例只有在获取Bean时才会执行 BeanPostProcessor接口 ​ 实现该接口可以在对象创建完成后的初始化方法前后进行增强 ​ spring底层有很多实现该接口的类(处理器),功能包括bean的赋值,注入其他组件,生命周期注解功能等 day04 @Value 赋值 ​ 1.普通赋值,直接在组件的成员变量上声明该注解并且赋值(字符串),同时支持springEL表达式完成计算 ​ 例如 @Value(\"#{1*3}\") 在获取时便可得到该表达式的结果 ​ 2.使用.properties文件+@PropertySource(文件名数组)注解 ​ @Value(\"${属性名在文件中的key}\") ​ 在配置类上声明@PropertySource(value = {\"文件名\"}) AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); // 获取环境 ConfigurableEnvironment environment = app.getEnvironment(); // 获取所有配置文件 MutablePropertySources propertySources = environment.getPropertySources(); for (PropertySource propertySource : propertySources) { System.out.println(\"获取每一个配置文件名称\"+propertySource.getName()); System.out.println(\"获取每一个文件中的所有的属性及属性值\"+propertySource.getSource()); System.out.println(\"获取指定属性名称的属性值 没有则为null\"+propertySource.getProperty(\"name\")); } 关于自动装配 @Autowired ​ @Autowired默认根据变量名作为beanname获取,如果没有则根据类型查找,@Autowired本身不能根据beanname指定 获取容器中的实例对象,需要配合使用@Qualifier(beanname) ​ required属性 ​ 属性值为true表示注入的时候，容器中该bean必须存在，否则就会注入失败。 ​ 属性值为false：表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错 @Resource ​ jdk提供的@Resource(name = beanname)注解可以指定名称,默认根据变量名作为beanname获取,如果没有则根据类型查找,不支持required,不支持优先级 @Primary ​ 设置获取bean时的优先级,可以在类上添加,也可以配合@Bean使用 ​ 使用@Autowired注解进行依赖注入时便会使用声明该注解的实例,@Resource不会起作用 ​ 比如一个接口有两个实现类,都会被扫描进容器,但是在使用接口进行注入时会报错,如果给 其中一个实现类添加优先级,会解决该问题并且优先使用该实现类 ​ @Inject ​ 是Java JSR330的规范,和@Autowired功能类似,支持@Primary优先级,区别是没有required属性 javax.inject javax.inject 1 ​ 如果@Bean的方法名或者name相同于类首字母小写或者注解中的beanname会优先使用 @Bean产生的实例此效果三种注解相同 如果同时声明了@Qualifier(beanname1)+@Autowired和@Primary+@Bean(beanname2):会使用beanname1 注入顺序 **@Qualifier > 优先级 > 变量名(同名@Bean优先) > 类型** day05 AOP ​ 面向切面编程(底层使用动态代理) ​ 在程序运行期间动态,在不修改源码的基础上，对已有方法进行增强。 ​ 使用aop需要的依赖 org.springframework spring-aspects 5.1.8.RELEASE ​ 相关术语: ​ Target(目标对象):被增强方法的所属对象 ​ Joinpoint(连接点):目标方法可增强的位置 ​ Pointcut(切入点):实际被增强的方法 ​ Advice(通知/增强):对切入点增强的位置及方法 ​ Aspect(切面):切入点的通知的结合() ​ Proxy(代理):一个类被AOP织入增强后,会产生一个结果代理类 相关注解: 注解 描述 @Aspect 把当前类声明成切面类 @Before 把当前方法看成是前置通知 @AfterReturning 把当前方法看成是返回通知,需要方法正常返回。 @AfterThrowing 把当前方法看成是异常通知,方法参数可以拿到 @After 把当前方法看成是后置(最终)通知,,无论是否出现异常都会执行 @Around 把当前方法看成是环绕通知 @Pointcut 定义方法声明该注解添加切入点表达式,可以直接引用该方法作为表达式,相当于提取 切入点表达式: //切入点表达式：execution后小括号中寻找要增强方法的表达式 // @Before(\"execution(public void com.czxy.demo03.*.save())\") //某个包下的所有类用* // @Before(\"execution(void com.czxy.demo03.*.save())\") //访问权限可以省略 // @Before(\"execution(* com.czxy.demo03.*.save())\") //任意返回值 // @Before(\"execution(* *.*.*.*.save())\") //任意包 // @Before(\"execution(* com..*.save())\") //当前包下的任意包 // @Before(\"execution(* com..*.*())\") //任意方法名称 // @Before(\"execution(* com..*.*(*))\") //任意方法参数必须有 // @Before(\"execution(* com..*.*(..))\") //任意方法任意参数均可 // @Before(\"execution(* *..*.*(..))\") //项目中所有方法 ​ 基本使用步骤: ​ 1.导入spring aop 的相关依赖 ​ 2.声明一个切面类 添加@Aspect @Component 注解 ​ 3.在切面类中编写增强方法,并添加相关通知注解以及所需切入点 ​ 4.在配置类中添加@EnableAspectJAutoProxy 注解开启切面 注意事项: ​ 关于@Around 注解的使用 ​ 声明该注解后方法会默认有一个JoinPoint/ProceedingJoinPoint形参 ​ 将joinpoint强转为proceedingJoinPoint,并调用其pjp.proceed();方法 ​ 在该方法调用前执行的就是前置通知,之后则是后置通知 ​ 可以使用ty{}catch()finally{}做出异常通知和最终通知的效果 @Around(\"execution(public void com.czxy.demo03.OrderDao.save())\") public void myAround(JoinPoint joinPoint,ProceedingJoinPoint proceedingJoinPoint) { //获取目标对象 Object target = joinPoint.getTarget(); System.out.println(target); //获取切点方法 Signature signature = joinPoint.getSignature(); System.out.println(signature); //将joinpoint强转为proceedingJoinPoint ProceedingJoinPoint pjp = (ProceedingJoinPoint)joinPoint; try { System.out.println(\"之前？\"); pjp.proceed(); System.out.println(\"之后？\"); } catch (Throwable throwable) { System.out.println(\"异常出现啦！\"); throwable.printStackTrace(); } finally { System.out.println(\"最终执行的！\"); } } ​ 关于@Pointcut的使用 //设置公共切点，可以方便其他增强使用，这里bf方法与ar方法使用了该公共切点 @Pointcut(需要提取的切入点的表达式) private void myPointcut(){ } @Before(\"切面类.myPointcut()\") // @AfterReturning(\"myPointcut()\") public void bf() { System.out.println(\"增强\"); } 切面类示例代码 //日志切面类 @Aspect public class LogAspects { @Pointcut(\"execution(public int com.enjoy.cap10.aop.Calculator.*(..))\") public void pointCut(){}; //@before代表在目标方法执行前切入, 并指定在哪个方法前切入 @Before(\"pointCut()\") public void logStart(JoinPoint joinPoint){ System.out.println(joinPoint.getSignature().getName()+\"除法运行....参数列表是:{\"+ Arrays.asList(joinPoint.getArgs())+\"}\"); } @After(\"pointCut()\") public void logEnd(JoinPoint joinPoint){ System.out.println(joinPoint.getSignature().getName()+\"除法结束......\"); } @AfterReturning(value=\"pointCut()\",returning=\"result\") public void logReturn(Object result){ System.out.println(\"除法正常返回......运行结果是:{\"+result+\"}\"); } // @AfterThrowing(value=\"pointCut()\",throwing=\"exception\") public void logException(Exception exception){ System.out.println(\"运行异常......异常信息是:{\"+exception+\"}\"); } @Around(\"pointCut()\") public Object Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{ System.out.println(\"@Arount:执行目标方法之前...\"); Object obj = proceedingJoinPoint.proceed();//相当于开始调div地 System.out.println(\"@Arount:执行目标方法之后...\"); return obj; } } 执行顺序 ​ @Around之前 > @Before > 切入点(目标方法) > @Around之后(如抛出异常不执行) > @After > @AfterThrowing(程序抛出异常) > @AfterReturning(成功返回,如抛出异常不执行) ​ day08 ​ spring声明式事务 什么是声明式事务? ​ 以方法为单位,进行事务控制,抛出异常,事务回滚 ​ 最小的执行单位为方法,决定执行成败通过是否抛出异常来判断,抛出异常即执行失败 spring使用事务 ​ 导入相关依赖: mysql mysql-connector-java 5.1.47 com.alibaba druid 1.1.10 org.springframework spring-jdbc 5.1.8.RELEASE ​ 配置类 package xyz.taoqz.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; /** * @author :almostTao * @date :Created in 2019/9/7 15:13 */ @Configuration @ComponentScan(\"xyz.taoqz\") // 开启事务 配合@Transactional注解以及事务管理器使用 @EnableTransactionManagement public class SpringConfig { /** * 配置数据源 * @return */ @Bean public DataSource dataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUsername(\"root\"); druidDataSource.setPassword(\"123\"); druidDataSource.setUrl(\"jdbc:mysql:///spring_day08_shiwu\"); druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); return druidDataSource; } /** * 实现简单的增删改查 * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ return new JdbcTemplate(dataSource); } /** * 事务管理器 * @param dataSource * @return */ @Bean public DataSourceTransactionManager txManager(DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } } ​ dao依赖注入 @Autowired private JdbcTemplate jdbcTemplate; ​ @Transactional ​ 添加在方法上,表示该方法有事务效果 ​ 添加在类上,表示该类中所有方法都有事务 day11 ​ springmvc自定义配置 ​ 应该实现WebMvcConfigurer接口还是继承WebMvcConfigurerAdapter类,该类是接口的一个实现类.为了解决需要单独配置其中一项而需要实现接口中的所有方法而产生,但在spring5之后该接口中的方法定义为default,可以选择重写方法,因此推荐使用实现WebMvcConfigurer接口的方式 ​ 需要实现WebMvcConfigurer接口的同时 添加@EnableWebMvc 注解 ​ FactoryBean和BeanFactory的区别 ​ FactoryBean:将java实例注入到容器中 ​ BeanFactroy:从容器中获取实例化后的Bean Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:29 "},"spring/SpringBoot.html":{"url":"spring/SpringBoot.html","title":"SpringBoot","keywords":"","body":"1.什么是SpringBoot?2..SpringBoot的项目结构:3.idea中创建项目后使用创建webapp目录,以及使用jsp4.自定义过滤器:5.整合Mybatis:6.整合JPA:7.使用log4j:8.boot热部署:9.webjars:10.定时任务:11.@PropertySource和@ConfigurationProperties注解12.前后台日期格式相互转换13.boot中使用拦截器14.静态文件15.实现页面跳转的简便化,配置类中的addViewControllers()方法16.上传图片17.restful结合ajax18.路径映射:19.mysql驱动包 8.x 修改时区20.application.yml: 1.什么是SpringBoot? ​ 简化了Spring项目的搭建和开发过程,可以整合其他框架,简单,快速,快变 2..SpringBoot的项目结构: ​ 其他包和boot的启动类在同一级目录 com +- example +- myproject +- Application.java | +- model | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | ​ 使用idea创建的Boot项目默认给出两个依赖 ​ spring-boot-starter:核心模块,包括自动配置支持、日志和 YAML ​ spring-boot-starter-test ：测试模块 3.idea中创建项目后使用创建webapp目录,以及使用jsp ​ 需要添加依赖: javax.servlet jstl org.apache.tomcat.embed tomcat-embed-jasper provided ​ 创建webapp目录应该与Java和resources目录同级 ​ 标记为web目录:Modules --> 点击项目下的Web,将webapp路径添加到下图 4.自定义过滤器: ​ 其中MyFilter类自己实现javax.servlet.Filter接口 5.整合Mybatis: ​ 需要的依赖: org.mybatis.spring.boot mybatis-spring-boot-starter 1.1.1 mysql mysql-connector-java tk.mybatis mapper 3.5.2 javax.persistence persistence-api ​ 其中如果数据出现乱码: org.springframework.boot spring-boot-maven-plugin -Dfile.encoding=UTF-8 repackage ​ application.yml需要的配置: #com.mysql.jdbc.Driver 是 mysql-connector-java 5中的， #com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6中的 #jdbc:mysql://localhost:3306/test?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false spring: datasource: url: jdbc:mysql:///study?serverTimezone=UTC driverClassName: com.mysql.cj.jdbc.Driver username: root password: 123 #spring集成Mybatis环境 #pojo别名扫描包 mybatis: #执行SQL语句日志 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl type-aliases-package: com.czxy.springboot_mybatis.domain #加载Mybatis映射文件 在resources文件夹下创建mapper文件夹 # mapper-locations: classpath:mapper/*.xml #加载映射文件 在Java文件夹中的xml文件 # mapper-locations: classpath:com/czxy/springboot_mybatis/mapper/*.xml #加载Mybatis配置文件 还没试 # config-location: classpath:mybatis/mybatis-config.xml # 驼峰命名规范 如：数据库字段是 order_id 那么 实体字段就要写成 orderId # mybatis.configuration.map-underscore-to-camel-case=true ​ 1.在接口上添加@Mapper,如果很多Mapper需要添加很多注解,可以用下面的方式, @org.apache.ibatis.annotations.Mapper ​ 2.在启动类上添加: // 扫描所有mapper 该注解是tk包下的 @MapperScan(\"com.czxy.springboot_mybatis.mapper\") ​ 如果需要加载在java包中的映射文件,需要在pom文件中添加: src/main/resources src/main/java **/*.xml true ​ 6.整合JPA: #JPA Configuration: spring: jpa: database: MySQL show-sql: true generate-ddl: true hibernate: ddl-auto: update naming: implicit-strategy: org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy ​ 注意事项:与mybatis一起使用时**,会引起依赖冲突** ​ 解决:**排除掉出现冲突的依赖** tk.mybatis mapper 3.5.2 javax.persistence persistence-api org.springframework.boot spring-boot-starter-data-jpa 7.使用log4j: ​ 在resources文件夹下添加log4j.properties ​ yml: #使用log4j作为日志文件 #logging: # config: src/main/resources/log4j.properties ​ 需要的依赖:需要排除boot的自带日志 org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-logging org.springframework.boot spring-boot-starter-log4j 1.3.8.RELEASE 8.boot热部署: ​ 需要的依赖: org.springframework.boot spring-boot-devtools ​ properties: #开启热部署 spring.devtools.restart.enabled=true #设置重启文件目录 spring.devtools.restart.additional-paths=src/main/java #页面不加载缓存，修改即时生效 spring.thymeleaf.cache=false ​ idea需要的配置: 9.webjars: ​ WebJars可以让大家 以Jar 包的形式来使用前端的各种框架、组件。 ​ WebJars 是将客户端（浏览器）资源（JavaScript，Css等）打成 Jar 包文件，以对资源进行统一依赖管理。WebJars 的 Jar 包部署在 Maven 中央仓库上。 ​ 可以让我们对前端资源也以jar包的方式进行依赖管理 通过查看mvc的自动配置类可以看到前端资源配置的虚拟路径和映射路径 引入时,按照其在pom文件中的 webjars/a/v/具体引入的东西 ​ 官网:https://www.webjars.org/ ​ 所需依赖: org.webjars webjars-locator-core org.webjars jquery 3.3.1 ​ 测试访问路径:http://localhost:8080/webjars/jquery/3.3.1/jquery.js ​ 对应在jsp中引用: 10.定时任务: ​ 在启动类上添加@EnableScheduling启用定时任务 ​ 创建定时任务类并交由spring管理,在需要运行的方法上添加@Scheduled注解 ​ @Scheduled注解参数说明: @Scheduled参数可以接受两种定时的设置，一种是我们常用的cron=\"*/6 * * * * ?\"，一种 是fixedRate = 6000，两种都表示每隔六秒打印一下内容。 fixedRate说明 @Scheduled(fixedRate = 6000) ：上一次开始执行时间点之后6秒再执行 @Scheduled(fixedDelay = 6000) ：上一次执行完毕时间点之后6秒再执行 @Scheduled(initialDelay=1000, fixedRate=6000) ：第一次延迟1秒后执行，之后按fixedRate的规则每6秒执行一次 11.@PropertySource和@ConfigurationProperties注解 ​ @PropertySource配合@Value注解使用 前者指定配置文件名称后者使用其在配置文件中的名称注入 ​ @ConfigurationProperties 自定义一个配置文件,配合@PropertySource指定配置文件后,提供getset方法进行注入 12.前后台日期格式相互转换 ​ 在bean类属性上添加 ​ 前台传递后台按照指定格式接收: ​ 方式一:@DateTimeFormat(pattern = \"\") ​ 方式二:在application.properties文件中添加 ​ spring.mvc.date-format=yyyy-MM-dd HH:mm:ss ​ 后台返回给前台json时的data自定义格式字符串: ​ 方式一:@JsonFormat(pattern=\"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\") ​ 方式二: ​ spring.jackson.time-zone=GMT+8 ​ spring.jackson.date-format=yyyy-MM-dd HH:mm:ss 13.boot中使用拦截器 ​ ssm方式使用配置类配置拦截器在springmvc_note中,注意spring5后一律推荐使用实现WebMvcConfigurer接口 ​ 创建HandlerInterceptor接口的实现类,并使用@Component注解将该类添加到spring容器中 ​ 创建mvc的配置类,并且声明该类是配置类,实现WebMvcConfigurer接口重写以下方法 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\"/**\").excludePathPatterns(\"/js/*\").excludePathPatterns(\"/login.html\").excludePathPatterns(\"/register.html\").excludePathPatterns(\"/login\").excludePathPatterns(\"/register\"); } ​ 14.静态文件 ​ 阅读源码可以看到WebMvcAutoConfiguration 类中addResourceHandlers方法 去读ResourceProperties类中的属性 其中将默认的值赋值给了它,共有四个默认值,其优先级跟下图声明顺序一样 这几个文件夹都是在resources文件夹下的 classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ / : mvc添加该路径方便我们创建webapp目录 还可以添加webapp,在idea中添加该目录需要在project settings -- > models 选中项目的web 有两栏添加第一个提那家web.xml路径,第二个添加webapp路径,如果jsp访问不到 如下配置,别忘记添加依赖 自定义方式: ​ 使用配置文件: ​ 配置文件第一行代表添加一个静态资源文件夹路径,如果没有把默认的配置加上会覆盖默认的设置 ​ 同时使用自定义和默认的,用英文逗号隔开即可,前面的优先级高 ​ 使用java配置类: ​ 实现WebMvcConfigurer接口重写addResourceHandlers,可以达到相同效果 ​ 映射resources下的文件夹或文件以classpath:开头 classpath:/ 代表resources根目录 ​ 映射磁盘下的文件以file:开头 ,其中盘符写绝对路径,盘符后的 冒号 可写可不写 ​ 例如 : file:D:/temp/upload/ file:D/temp/upload/ ​ 使用webapp目录,把js文件放在其根目录下,在webapp根目录和WEB-INF的jsp都可以从所在包直接引用 ​ 注意事项:这两种方式都会覆盖其默认配置,也就是说只配置了自己想要的路径,其默认的便会失效 ​ 关于前端引入可以在webjars中查看 ​ 参考博客 ​ https://www.jianshu.com/p/d40ee98b84b5 ​ https://www.cnblogs.com/sxdcgaq8080/p/7833400.html ​ 江南一点雨 15.实现页面跳转的简便化,配置类中的addViewControllers()方法 ​ 实现WebMvcConfigurer重写addViewControllers方法 ​ registry.addViewController(\"/\").setViewName(\"test.html\"); ​ 前面是url映射路径,后面是要显示的页面,其中setViewName()会经过视图解析器 ​ 注意事项:如果在配置类中的映射路径和在controller中的路径一样,会匹配到controller中的内容 ​ 参考博客: ​ https://www.cnblogs.com/sxdcgaq8080/p/7833400.html 16.上传图片 ​ 前台ajax固定代码 $(function () { // 当点击btn的时候 $(\"#btn\").click(function () { alert(1) //1 准备一个FormData对象，用来封装表单数据 var data = new FormData(); //2 获取上传文件 var files = $(\"#myfile\").prop(\"files\"); data.append(\"myfile\",files[0]); //3 获取其余的表单元素 data.append(\"username\",$(\"#username\").val()); data.append(\"password\",$(\"#password\").val()); data.append(\"age\",$(\"#age\").val()); /** * * form的enctype必须是multipart/form-data才可以上传多个文件，ajax通过FormData来上传数据，ajax的cache、processData、contentType均要设置为false。 cache设为false是为了兼容ie8，防止ie8之前版本缓存get请求的处理方式。 contentType设置为false原因：https://segmentfault.com/a/1190000007207128。 processData：要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型\"application/x-www-form-urlencoded\"。 如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 * * */ // 发送ajax debugger; $.ajax({ url:\"/register\", type:\"POST\", data:data, cache:false, processData:false, contentType:false, success:function () { location.href = \"login.html\" } }) }); }); contentType设置为false原因：https://segmentfault.com/a/1190000007207128 mvc 用来处理文件上传的对象MultipartFile 前台访问后台存储的文件,如果存储的路径是绝对路径,在前台找对应文 件路径时会找客户端电脑中的文件 如果直接在项目中直接存储,导致项目过大,在普通数据库存储也不太方便,最合适的方法在服务器存储 所以需要配置一个虚拟路径,为了在访问路径时去找我们服务器中存储文件的绝对路径 具体实现: ​ 写一个配置类,实现WebMvcConfigurer接口重写addResourceHandlers方法 ​ registry.addResourceHandler(\"/upload/**\").addResourceLocations(\"file:D:/temp/upload/\"); ​ 前面是请求的路径/代表upload下的所有的文件及文件夹** ​ 后面代表实际访问的服务器中的路径 注意要加file: 如果想要在项目根目录下存储 ​ 先获得存储文件的绝对路径,再加上文件名称 myfile.transferTo(new File(new File(\"upload\").getAbsolutePath()+\"/\"+myfile.getOriginalFilename())); ​ 存储在和java源文件和资源文件同目录 // 获取到的是项目/target/classes/路径 File file = new File(LoginController.class.getClass().getResource(\"/\").getPath() + \"/upload\"); if (!file.exists()){ file.mkdir(); } myfile.transferTo(new File(file.getAbsolutePath(),myfile.getOriginalFilename())); ​ 两种方式通过maven的install安装在本地仓库,都可以拿到存储的文件 图片太大 在application.properties中设置: #文件上传大小为20M spring.servlet.multipart.max-file-size=20MB #请求大小为20M spring.servlet.multipart.max-request-size=20MB 17.restful结合ajax ​ 首先要知道boot也是结合了mvc的,所以在后台方法进行封装时,和之前一样,只要前台name和方法参数对应mvc会帮我们自动封装 ​ 前台:在jquery.form.js插件中有$(\"#myForm\").formSerialize();方法可以直接将表单数据全部封装,直接发送请求即可 ​ 如果要前后台统一使用json来传输数据 ​ 前台: ​ contentType:\"application/json;charset=UTF-8\" : ajax要指名请求头的数据格式 ​ 自定义方法,将表单数据转换为json格式的字符串,最后使用js自身的方法JSON.stringify($(\"#myForm\").serializeJson()) 作为data传递到后台 $.fn.serializeJson=function() { var serializeObj = {}; var array = this.serializeArray(); var str = this.serialize(); $(array).each(function () { if (serializeObj[this.name]) { if ($.isArray(serializeObj[this.name])) { serializeObj[this.name].push(this.value); } else { serializeObj[this.name] = [serializeObj[this.name], this.value]; } } else { serializeObj[this.name] = this.value; } }); return serializeObj; }; ​ 如果前台跳转页面时,在地址栏传递信息,可以使用以下代码获取 // 获取id var a = location.search var b = location.search.split(\"=\") var c = location.search.split(\"=\")[1] // var d= parseInt((location.search.match(/id=\\w+/)[0]).split(\"=\")[1]) var id = parseInt(location.search.split(\"=\")[1]); ​ 由于ajax请求不支持转发页面所以需要在前台跳转 ​ 在ajax请求成功后 window.location.href = \"地址\" ​ 18.路径映射: ​ https://blog.csdn.net/zhou920786312/article/details/81026381 19.mysql驱动包 8.x 修改时区 spring.datasource.url=jdbc:mysql://localhost:3306/study?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC 20.application.yml: ​ 注意name和value之间要有一个空格 person: name: zhangsan #DB Configuration: 数据源 spring: datasource: url: jdbc:mysql:///study?serverTimezone=UTC driverClassName: com.mysql.cj.jdbc.Driver username: root password: 123 devtools: #热部署 restart: enabled: true additional-paths: src/main/java mvc: #mvc view: prefix: /WEB-INF/view/ suffix: .jsp #JPA Configuration: jpa: database: MySQL show-sql: true generate-ddl: true hibernate: ddl-auto: update naming: implicit-strategy: org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy #spring集成Mybatis环境 #pojo别名扫描包 mybatis: type-aliases-package: com.czxy.springboot_mybatis.domain #加载Mybatis映射文件 # mapper-locations: classpath:mapper/*.xml #加载Mybatis配置文件 # config-location: classpath:mybatis/mybatis-config.xml #配置默认端口以及默认项目路径 #server: # port: 8888 # servlet: # context-path: /demo #使用log4j作为日志文件 #logging: # config: src/main/resources/log4j.properties Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:29 "},"spring/SpringMVC.html":{"url":"spring/SpringMVC.html","title":"SpringMVC","keywords":"","body":"1.SpringMVC是什么:2.视图解析器:3.参数绑定:3.1.注意事项(重要)3.2.@RequestParam3.3.数组绑定3.4.集合类型:4.多路径映射/请求方法限定/窄化路径:4.1多路径映射:4.2请求方法限定(也是该注解的一个参数)4.3窄化路径:5. @PathVaraible注解的使用:6.Controller方法返回值以及跳转方式:7.异常处理器:8.图片上传:9.JSON数据交互:10.拦截器:11.序列化12.@RequestBody1.SpringMVC是什么: ​ Spring web mvc是表现层的框架,它是Spring框架的一部分 ​ 执行流程:客户端发送请求,springMVC的前端控制器DispatcherServlet接收并分配请求到对应的Controller执行对应的 方法,方法会返回视图,DispatherServlet解析视图,返回客户端进行渲染 2.视图解析器: ​ 视图:简单理解为浏览器向用户展示的界面 ​ 为什么使用? ​ 浏览器想要展示页面需要有一个请求的地址,拿到路径,但路径通常会在一个文件夹中,而文件夹可能会有多层,所 以SpringMVC中的视图解析器,可以帮我们减少一些重复的代码,把绝对路径可以写成我们的逻辑路径 ​ 需要在配置类中添加:用户在返回视图时,会经过该解析器,帮我们拼接字符串 ​ 配置类继承WebMvcConfigurerAdapter,注意spring5后一律推荐使用实现WebMvcConfigurer接口 @Bean public InternalResourceViewResolver viewResolver(){ InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); // 这是视图的前缀 viewResolver.setPrefix(\"/\"); // 这是视图的后缀 viewResolver.setSuffix(\".jsp\"); return viewResolver; } // properties 方式配置 spring.mvc.view.prefix= spring.mvc.view.suffix= 3.参数绑定: 3.1.注意事项(重要) ​ 其中前台的name必须和属性值名称一致,使用set方法赋值 ​ 其中方法的参数类型如果是基本数据类型推荐使用包装类型,因为基本数据类型不能为null,如果请求中没有改参数,会抛异常 3.2.@RequestParam ​ 作用:当请求参数的名称与方法参数名称不一致时,可以使用该注解标记对应关系 ​ 该注解中的参数: ​ name = \"对应的在前台的name名称\":与方法中的参数名对应 ​ required:表示是否必须有该参数有两个值,,默认为false ​ defaultValue:表示如果前台没有传递该参数时的默认值 ​ 引用数据类型的映射(POJO): ​ 在方法参数声明一个对象变量,请求时如果name和对象中的属性值一致,会自动注入到该对象中 ​ 简单说就是在对象中又有其他对象: ​ 在前台传递参数时,参数名称为该对象的名称再点属性 ​ 例子: 两个javaBean @Data public class CartItem { private Item item; private Integer number; private Double price; } @Data public class Item { private String name; private Double price; } 前台要提交的表单 Controller层处理,及控制台输出 3.3.数组绑定 ​ (比如类中说有一个成员变量是数组(爱好)): ​ 前台表单传递一个相同name的一组数据,可以在方法的参数中写一个数组类型进行赋值,其中数组的名称也要和 前台name的名称相同 3.4.集合类型: ​ 如果在方法参数中直接写集合类型是赋值不了的,需要使用数组或者在Bean中添加一个集合属性进行赋值,如果需 要给指定索引赋值,在name中指定索引即可 ​ 例子:在上面的基础之上CartItem类中添加了一个集合属性 ​ ​ 前台数据传递的方式以及后台打印结果 4.多路径映射/请求方法限定/窄化路径: 4.1多路径映射: ​ @RequestMapping:请求路径映射 ​ 常用的参数: ​ value:\"指定访问的路径\"可以多个{\"路径1\",\"路径2\"} ​ headers :指定请求头中的参数 **params** :你可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。也就是请求时的 不同参数,调用的方法也会不同 @RequestMapping(value = \"/hello.action\",params = {\"id=10\"}) public String fun(String id){ System.out.println(id); return \"index\"; } @RequestMapping(value = \"/hello.action\",params = {\"id=20\"}) public String fun2(String id){ System.out.println(id); return \"index\"; } 4.2请求方法限定(也是该注解的一个参数) ​ method:指定请求的类型,也可以是数组 ​ method = {RequestMethod.GET,RequestMethod.POST} 4.3窄化路径: ​ 在类上添加相当于设置请求的前缀 ​ 在方法上添加,设置方法对应的请求路径 5. @PathVaraible注解的使用: ​ @RequestMapping 注解可以同 @PathVaraible 注解一起使用，用来处理动态的 URI ​ 将 @PathVaraible注解写到方法的参数前,对应方法中的参数,可以将URL中的对应的位置的值赋值到变量中,还可以使用正则表达式 @RequestMapping(value = \"/fetch/{id}.action\", method = RequestMethod.GET) public String getDynamicUriValue(HttpServletRequest request, @PathVariable(\"id\") String id) { System.out.println(\"ID is \" + id); return \"index\"; } ​ 如果设置参数不是必须的,需要有对应的路径映射 // required 设置参数为非必须项 @GetMapping({\"/path/{id}\",\"/path\"}) public void fun(@PathVariable(required = false) Integer id){ System.out.println(id); } 6.Controller方法返回值以及跳转方式: ​ 返回值为ModelAndView:创建ModelAndView对象,或者在方法形参中给出,可以在构造方法中直接给(返回的页面,存在域中的名称,存在域中的数据),或者分别使用addObject(name,value),setViewName(地址),会经过视图解析器 ​ 返回值为String:在方法的形参上添加Model,使用addAttribute()存储数据,返回值写地址 ​ 还可以使用 return \"redirect:tao.jsp\"; ​ return \"forward:tao.jsp\"; ​ 这两种方法存储的域都是request(想要存储到别的域中,可以使用原生) ​ 返回值为void使用方式和BaseServlet时一样,并且不会经过SpringMVC中的视图解析器 ​ 想要重定向或请求转发,在字符串中分别拼接redirect:和forward:,MVC会帮我们解析返回值,并在底层调用不同的方法 7.异常处理器: ​ SpringMVC异常处理机制: ​ 系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由 异常处理器进行异常处理。springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。 具体代码实现: ​ 创建一个自己的异常类,继承Exception ​ 定义统一异常处理器类:实现HandlerExceptionResolver接口并交由spring管理,重写方法 ​ @Component public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) { //统一处理异常 CustomException customException = null; // 如果是自定义异常直接类型转换赋值,并显示错误信息 // 如果不是创建自定义异常,提示未知错误 if(ex instanceof CustomException){ customException = (CustomException) ex; } else { customException = new CustomException(\"系统错误，请与系统管理 员联系！\"); } //设置数据 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"message\", customException.getMessage()); modelAndView.setViewName(\"WEB-INF/error\"); return modelAndView; } } 8.图片上传: ​ 在写具体代码时,先了解一下表单的一个属性 ​ enctype:该属性有三个属性值 ​ application/x-www-form-urlencoded:默认值,请求方式为get时,会将表单中的数据以键值对的方式加到url后面中间用?分隔,为post时,浏览器把form数据封装到http body中，然后发送到服务器 ​ text/plain：表单以纯文本形式进行编码 ​ multipart/form-data：当上传的含有非文本数据时,设置为该属性值,将表单数据变成二进制数据进行上传,这时使用request是获取不到表单响应的值的 ​ 在了解这点后,看具体上传图片的代码: ​ 在配置类中添加文件上传解析器: ​ 需要导入commons-io和commons-fileupload依赖 ​ @Bean public CommonsMultipartResolver multipartResolver[1] (){ CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(); // 设置所有的上传文件的总大小 10M multipartResolver.setMaxInMemorySize(10*1024*1024); // 设置单个文件上传的大小 4M multipartResolver.setMaxUploadSize(4*1024*1024); multipartResolver.setDefaultEncoding(\"utf-8\"); return multipartResolver; } 注解方式: spring.servlet.multipart.max-file-size= 文件大小 spring.servlet.multipart.max-request-size= 请求大小 Controller中写方法接受表单数据,需要设置一个参数MultipartFile表示文件上传对象,其他参数可以正常获取 ​ 该类常用方法: 方法名 描述 String getOriginalFilename() 获得原始上传文件名 transferTo(File file) 将上传文件转换到一个指定的文件中 String getContentType() 获取文件MIME类型，如image/pjpeg、text/plain等 String getName() 获取表单中文件组件的名字 ​ 直接写一个数组(没试过) ​ 如果是多文件上传,可以写一个VO类,里面添加一个成员变量List MultipartFiles 9.JSON数据交互: ​ 需要导入的依赖: com.fasterxml.jackson.core jackson-databind 2.9.7 ​ 前端发送json格式的数据,如果对应的Controller方法中的对象或者变量名相同可以直接封装赋值 ​ 后台想要把数据返回到前台页面显示,需要在配置类上添加@EnableWebMvc开启配置 ​ 有两种方式: ​ 1.在类上添加@Controller在方法返回值前加@ResponseBody ​ 2.直接在类上添加@RestController,因为该注解包含上面两个注解 10.拦截器: ​ 自定义拦截器需要实现HandlerInterceptor接口重写其方法 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 afterCompletion方法是在JSP执行后执行 request或者response不能再跳转页面了 使用配置类配置拦截器: ​ 配置类继承WebMvcConfigurerAdapter ​ 重写方法: @Override public void addInterceptors(InterceptorRegistry registry) { // 添加拦截器 InterceptorRegistration interceptorRegistration1 = registry.addInterceptor(myInterceptor1); InterceptorRegistration interceptorRegistration2 = registry.addInterceptor(myInterceptor2); interceptorRegistration1.addPathPatterns(\"/**\"); interceptorRegistration2.addPathPatterns(\"/**\"); } ​ 多个拦截器执行流程: ​ 会先按顺序执行preHandle方法,在Controller方法执行完成并且在jsp视图执行前反顺序执行postHandle方法,然后 在返回视图,在返回视图完成后在反顺序执行afterCompletion方法 11.序列化 @JsonInclude注解的使用 有时前台获取数据时,数据中有为null或者\"\"空字符串的字段,为了解决不必要的麻烦,可以在实体类的字段上添加该注解 @JsonInclude(JsonInclude.Include.NON_NULL) // 字段的值为空时跳过序列化 @JsonInclude(JsonInclude.Include.NON_EMPTY)// 包含上面注解,同时字段值为空字符时跳过序列化 12.@RequestBody 配合post请求使用 该注解主要作用用于解析请求体中的数据 如果不添加该注解,那么获取形参的数据为null // 不添加注解 @PostMapping public void fun(String student){ System.out.println(student); } // 请求体中的数据 {\"sname\":\"taoqz\"} // 控制台输出 console : null // 添加注解 @PostMapping public void fun(@RequestBody String student){ System.out.println(student); } // 请求体中的数据 {\"sname\":\"taoqz\"} // 控制台输出 会将数据当做字符串解析赋值 console : {\"sname\":\"taoqz\"} ​ 传递对象 ​ 只需将参数设置为需要的对象,mvc会将请求中的数据自动封装到对象中,前提是请求体中的字段与实体类中的属性名称一致 @PostMapping public void fun(@RequestBody Student student){ System.out.println(student); } // 请求体中数据 { \"sname\":\"taoqz\", \"address\":\"北京\" } // 控制台输出 Student(sid=null, sname=taoqz, address=北京, teachers=null) ​ 结合@RequestParam使用 ​ @RequestBody注解只能使用一次,如果有特殊需要可以结合@RequestParam使用 @PostMapping(\"/test\") public void add(@RequestBody Student student, @RequestParam(\"arr\") String[] arr){ System.out.println(student); System.out.println(Arrays.toString(arr)); } // 请求路径 mvc会将路径中相同名称的参数封装到数组中 http://localhost:8080/test/zz?arr=1&arr=2 // 请求体 自动封装到对象中 { \"sname\": \"zs\", \"address\": \"江苏省南京市\" } // 控制台输出 student: Student(sid=null, sname=zs, address=江苏省南京市, teachers=null) arr : [1, 2] Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:29 "},"mybatis/mybatis.html":{"url":"mybatis/mybatis.html","title":"Mybatis","keywords":"","body":"什么是Mybatis什么是ORM项目地址:什么是Mybatis Mybatis是一个持久层ORM框架。内部封装了jdbc，使开发更简洁，更高效。 Mybatis使开发者只需要关注sql语句本身，简化JDBC操作，不需要在关注加载驱动、创建连接、处理SQL语句等繁杂的过程。 Mybatis可以通过xml或注解完成ORM映射关系配置。 什么是ORM ORM的全称是Object Relational Mapping，即对象关系映射。 描述的是对象和表之间的映射。操作Java对象，通过映射关系，就可以自动操作数据库。 在ORM关系中，数据库表对应Java中的类，一条记录对应一个对象，一个属性对应一个列。 常见的ORM框架：Mybatis、Hibernate 项目地址: mybatis+mapper https://github.com/TaoQZ/mybatis-learning-example.git springboot+mybatis+mapper: https://github.com/TaoQZ/springboot-mybatis-example.git Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:27 "},"mybatis/注意事项.html":{"url":"mybatis/注意事项.html","title":"注意事项","keywords":"","body":"注意事项@Id@Transient热部署注意事项 @Id ​ 一定不要忘了添加该注解,在使用通用mapper时,有很多方法会根据主键对数据进行操作 // 正确写法 // import javax.persistence.*; @Id // 对应列名 @Column(name = \"id\") // 自增id 在插入后可以通过getId()获取到插入后的id @GeneratedValue(generator = \"JDBC\") private Integer id; @Transient ​ 如果实体类中有属性不是表中字段,添加该注解避免出现不必要的异常 ​ Mybatis-3.2.5及以上版本必须添加 @Transient private String cids; 热部署 通用mapper不支持热部署 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:27 "},"mongodb/Mongo的安装与卸载.html":{"url":"mongodb/Mongo的安装与卸载.html","title":"Mongo的安装与卸载","keywords":"","body":"卸载:停止对应服务:卸载服务:卸载应用:安装:步骤:配置环境变量:卸载: 停止对应服务: ​ 使用管理员命令窗口 win+x+a ​ net stop 服务名 卸载服务: ​ mongod.exe --remove --serviceName \"mongo的服务名\" 卸载应用: ​ 在系统应用中进行卸载 安装: 步骤: 下载对应安装包 mongodb中文官网:https://www.mongodb.org.cn/tutorial/55.html 点击安装,选择自定义配置 3.选择安装目录 4.进行配置 配置环境变量: ​ 配置环境变量的目的:为了在电脑中任意位置都可以使用mongo(其他应用程序也是如此) ​ 系统变量和用户变量:系统变量针对当前系统有效,而用户变量只对当前用户有效 ​ 步骤: 此电脑 --> 右键 --> 属性 2. 高级系统设置 --> 环境变量 3. 系统变量 --> 新建 在系统变量Path的变量值中添加%mongo%\\bin; 指向mongo的bin目录 测试启动 打开命令行cmd 默认端口 27017 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:27 "},"mongodb/Mongo介绍及命令行使用.html":{"url":"mongodb/Mongo介绍及命令行使用.html","title":"Mongo的介绍及命令行使用","keywords":"","body":"1. 简介2. Mongdb与MySQL的区别2.1 结构2.2 数据及存储方式2.3 优缺点2.4 使用场景3.数据类型3.1 数值类型3.2 数组类型3.3 日期类型3.4 ObjectId3.5 typeof 和$type3.6 null4.命令行启动4.1 启动服务4.2 运行mongodb4.3 基本操作5.使用5.1 基本概念5.2 添加insertOne(对象)insertMany(数组)insert(文档对象或数组)savesave和insert的区别5.3 删除deteleOnedeleteManyremove5.4 查询findfindOne5.5 更新updateOneupdateManyupdate结合参数使用6.常用操作符$set$unset$inc$exists$in$or$and$sort$skip $limit7.操作数组8. 整合springboot简单增删改查8.1 项目环境8.2 pom依赖8.3 代码1. 简介 ​ MongoDB是一个基于分布式文件存储的数据库,是菲关系型数据库(NoSQL) ​ 分布式文件存储:在mongodb中也叫分片管理,将数据库中存储的数据分散在不同的机器上,减缓了数据库的压力,提高响应速度 2. Mongdb与MySQL的区别 2.1 结构 MySQL MongoDB 对应关系 database database 库 table collection 表;集合 row document 一行数据(记录);一个文档 column field 列;字段 2.2 数据及存储方式 SQL NoSQL 存储方式 存在特定结构表中 更加灵活和可扩展,简单说就是在集合中每个文档可以有不相同个数或类型 表/集合数据的关系 必须定义好表和字段结构后才能添加数据,虽然表结构定义后可更新,比较复杂 数据可以在任何时候任何地方添加，不需要先定义表 多表查询 可以使用JOIN表连接方式将多个关系数据表中的数据用一条简单的查询语句查询出来 大多非关系型数据库不支持(MongoDB 3.2后可以指定同一数据库中的集合以执行连接 ) 数据耦合性 不允许删除已经被使用的外部数据(外键),规范方式设置外键,也可手动维护 NoSQL中没有这种强耦合的概念，可以随时删除任何数据 2.3 优缺点 NoSQL SQL 优点 扩展简单,快速读写,成本低 是所有关系型数据库的通用语言(差别不大),移植性好,数据统计方便直观,事务处理,保持数据的一致性 缺点 不提供对SQL的支持,大部分非关系型数据不支持事务,现有 产品不够成熟(MongoDB4.0提供了事务的API) 扩展困难,读写慢(当数据量达到一定规模时),成本高(企业级的需要付费的) 2.4 使用场景 ​ 单从功能上讲,NoSQL几乎所有的功能,在关系型数据库上都能满足,所以选择NoSQL主要是和关系型数据库进 行结合使用,各取所长 ​ 比如说数据库中的表结构需要经常变化,增加字段,如果在一个百万级数据量的关系型数据库中新增字段会有很 多问题,而使用非关系型数据库极大提升扩展性,也可以作为缓存数据库,典型就是Redis 3.数据类型 ​ mongodb存储数据的格式为BSON,和JSON很像,是JSON的扩展 mongodb支持的所有的数据类型: Type Number Alias Notes Double 1 “double” String 2 “string” Object 3 “object” Array 4 “array” Binary data 5 “binData” Undefined 6 “undefined” Deprecated. ObjectId 7 “objectId” Boolean 8 “bool” Date 9 “date” Null 10 “null” Regular Expression 11 “regex” DBPointer 12 “dbPointer” Deprecated. JavaScript 13 “javascript” Symbol 14 “symbol” Deprecated. JavaScript (with scope) 15 “javascriptWithScope” 32-bit integer 16 “int” Timestamp 17 “timestamp” 64-bit integer 18 “long” Decimal128 19 “decimal” New in version 3.4. Min key -1 “minKey” Max key 127 “maxKey” ​ ​ JSON : 布尔、数字、字符串、数组和对象 ​ 没有日期类型,只有一种数字类型,无法区分浮点数和整数,也没法表示正则表达式或者函数 ​ BSON : 是一种类JSON的二进制形式的存储格式,有JSON没有的一些数据类型,如Date,BinData(二进制数据) 3.1 数值类型 ​ mongodb的数值类型默认使用64位浮点型数值,整型可以使用NumberInt(值)或者NumberLong (值) db.emp.insert({age:18}) db.emp.find({age:18}) // 如果有int类型会同时查询出来 { \"_id\" : ObjectId(\"5dca61c0f366526745ae2f13\"), \"age\" : 18.0 } ====================================== // NumberInt 插入 NumberLong 同理 db.emp.insert({age:NumberInt(18)}) // $type : 可以使用此命令查询对应的数据类型 // 可以使用上面表格中的Number 也可以使用 Alias db.emp.find({age:{$type:\"int\"}}) { \"_id\" : ObjectId(\"5dca62c9f366526745ae2f16\"), \"age\" : NumberInt(18) } 3.2 数组类型 ​ db.emp.insert({ _id:new ObjectId(), name:'taoqz', arr:[ '字符串', 100, new Date(\"2019-11-11\") ] }) db.emp.findOne({name:\"taoqz\"}) // 数组中支持不同的类型 { \"_id\" : ObjectId(\"5dca6971f366526745ae2f17\"), \"name\" : \"taoqz\", \"arr\" : [ \"字符串\", 100.0, ISODate(\"2019-11-11T00:00:00.000+0000\") ] } 3.3 日期类型 // 构建一个格林尼治时间 可以看到正好和我们的时间相差8小时，我们是+8时区，也就是时差相差8 new Date() new Date(\"1999-10-09T18:56:01\") // 真实时间是要比下面的时间大八个小时的 ISODate(\"2019-11-12T08:30:50.060Z\") // 此问题在Java中结合springboot时可以在对应的字段上添加下面注释 @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") 3.4 ObjectId ​ ObjectId使用12字节的存储空间，每个字节可以存储两个十六进制数字，所以一共可以存储24个十六进制数 字组成的字符串，在这24个字符串中，前8位表示时间戳，接下来6位是一个机器码，接下来4位表示进程id，最后 6位表示计数器 ​ 是文档的唯一标识,没有自增,如果不添加id会自动添加一个 \"_id\" : ObjectId(\"值\") db.emp.insert({_id:new ObjectId(),name:\"zz\"}) db.emp.findOne({name:\"zz\"}) { \"_id\" : ObjectId(\"5dca6eb4f366526745ae2f18\"), \"name\" : \"zz\" } 3.5 typeof 和$type ​ typeof 1 number typeof \"zz\" string ​ 每个数据类型对应一个数字，在MongoDB中可以使用$type操作符查看字段的数据类型 ​ $type:根据数据类型查找数据 {字段:{$type:数字}} {字段:{$type:\"数据类型\"}} 3.6 null ​ 用于表示空值或者不存在的字段 ,在查询的时候也可能会使用到 4.命令行启动 4.1 启动服务 ​ net start 服务名 (管理员cmd) 4.2 运行mongodb ​ mongo 4.3 基本操作 查看所有数据库 show dbs 查看所有集合 show tables | show collections 查看当前所在数据库 db 使用数据库 use db_name 删除数据库 db.dropDatabase() # 删除当前正在使用的数据库 使用集合 db.collection_name.find() # 查所有满足条件数据 db.collection_name.findOne() # 查满足条件的一条数据 db.collection_name.count() # 统计集合下面有多少数量的数据 删除集合 db.collection_name.drop() 创建数据库和集合 # 当你使用一个不存在的mongo数据库时,就自动创建了一个mongo数据库 # 同理当你往一个空集合里面插入了一条数据之后就自动创建了一个集合 查看当前数据库版本 db.version() 备份数据库 // 导出 如果没有设置账号密码 可以省略 mongodump --host IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件路径 // 导入 mongorestore --host --port -d 文件路径 5.使用 5.1 基本概念 ​ 数据库(database) ​ 集合(collection) ​ 文档(document) ​ 一个数据库由多个集合组成,一个集合中有许多文档,文档是最小的存储单位 5.2 添加 insertOne(对象) // 添加一条数据 db.emp.insertOne({name:\"张三\"}) // 返回的数据,也可以定义变量接收 { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"5dca9ef4f366526745ae2f1a\") } insertMany(数组) // 添加多条数据 db.emp.insertMany([{name:\"李四\"},{name:\"王五\"}]) { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"5dca9f91f366526745ae2f1c\"), ObjectId(\"5dca9f91f366526745ae2f1d\") ] } insert(文档对象或数组) // 添加一条或者多条 db.emp.insert({name:\"赵六\"}) WriteResult({ \"nInserted\" : 1 }) db.emp.insert([{name:\"田七\"},{name:\"吴八\"}]) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 2, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) // 查询所有 db.emp.find({}) { \"_id\" : ObjectId(\"5dca9f2bf366526745ae2f1b\"), \"name\" : \"张三\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9f91f366526745ae2f1c\"), \"name\" : \"李四\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9f91f366526745ae2f1d\"), \"name\" : \"王五\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9feef366526745ae2f1e\"), \"name\" : \"赵六\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa017f366526745ae2f1f\"), \"name\" : \"田七\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa017f366526745ae2f20\"), \"name\" : \"吴八\" } // 可以看到在插入时并没有指定id,确自动生成了一个_id // 在插入的时候如果已经存在了相同的id会报错 // 如果想要存在相同的id的时候不报错而是更新数据 请使用 save方法 ​ save // 当集合中没有此条数据,进行插入 db.emp.save({_id:\"1\",name:\"阿里\"}) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : \"1\" }) ----------------------------------------------------------------------------- // 有数据时会进行替换,而不是更新,更新会有专门针对字段更新的API db.emp.save({_id:\"1\",name:\"腾讯\",boss:\"马化腾\"}) // 一处匹配 一处修改 WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) ----------------------------------------------------------------------------- // 查询结果 { \"_id\" : \"1\", \"name\" : \"腾讯\", \"boss\" : \"马化腾\" } save和insert的区别 save和insert的区别 如果save没有指定id,直接插入 ​ 如果save指定了id,并且id已存在会替换已有的文档 5.3 删除 ​ // 插入两条数据 { \"_id\" : ObjectId(\"5dcaa5445feb59ece4310397\"), \"name\" : \"小王\", \"age\" : NumberInt(18) } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa5445feb59ece4310398\"), \"name\" : \"小红\", \"age\" : NumberInt(18) } deteleOne // 参数为空文档会集合中第一条文档 db.student.deleteOne({}) { \"acknowledged\" : true, \"deletedCount\" : 1.0 } // 两条命令效果一样 // $eq:== $gt:> $gte:>= $lt: deleteMany // 删除多条数据 // 如果传入空文档 会删除整个集合中的数据 db.student.deleteMany({}) { \"acknowledged\" : true, \"deletedCount\" : 2.0 } // 使用该命令会删除所有的匹配项 db.student.deleteMany({age:18}) { \"acknowledged\" : true, \"deletedCount\" : 2.0 } remove // 指定删除 会删除所有匹配项 db.student.remove({name:\"小王\"}) db.student.remove({age:18}) 5.4 查询 find // 查询所有 // 直接使用集合名称 db.student.find() // 指定集合名称 db.getCollection(\"student\").find({}) findOne // 只查询到第一个匹配到的 db.student.findOne({age:{$eq:18}}) // 会查询到所有匹配的 db.student.find({age:{$eq:18}}) 5.5 更新 ​ 数据 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } updateOne // 更新 db.books.updateOne({flag:1},{$set:{name:\"newName\"}}) { \"acknowledged\" : true, \"matchedCount\" : 1.0, \"modifiedCount\" : 1.0 } // 只更新了第一条 { \"_id\" : 1.0, \"name\" : \"newName\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } updateMany // 重新初始化数据后使用该命令会修改所有匹配项 db.books.updateMany({flag:1},{$set:{name:\"newName\"}}) update 和使用updateOne效果一样 结合参数使用 // 语法 db.collection.update( , , { upsert: , multi: , writeConcern: } ) query: 查询的条件 update: 可以配合操作符更新字段 upsert: 可选 当没有匹配项时,是否作为新的对象插入,默认false不插入 multi: 可选 默认false,只更新匹配的第一条记录,如果为true,将跟新所有匹配项 // 例如 可以弥补上面update时只更新一个匹配项 db.books.update({flag:1},{$set:{name:\"newName\"}},false,true) // 没有匹配项会添加 db.books.update({name:\"西游记\"},{name:\"西游记\"},true) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcab070763517547f7d8d95\"), \"name\" : \"西游记\" } 6.常用操作符 $set ​ 在更新时可以一个或多个字段 ​ 如果更新的字段不存在会添加该字段 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } // 更新flag和view字段 但flag字段之前不存在 进行了添加 db.books.update({_id:1},{$set:{flag:11,view:100}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } $unset ​ 删除字段 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // 将flag字段删除,其中flag的值可以随意写不用匹配 db.books.update({_id:1},{$unset:{flag:11}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } $inc ​ 自增或自减 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } // 将view字段自增10 db.books.update({_id:1},{$inc:{view:+10}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 10.0 } $exists ​ 匹配字段是否存在 // 格式 {字段:{$exists:boolean}} // 如果为true 匹配到所有有该字段的文档,包括null值 // false 则匹配没有该字段的文档 db.books.find({flag:{$exists:true}}) $in ​ 相当于mysql中的in ​ 是否在对应的范围 // 会匹配到对应字段在对应范围中的所有文档 db.books.find({_id:{$in:[1,3]}}) $or ​ 或者 ​ 格式:{ $or: [ { }, { }, ... , { } ] } { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"西游记\", \"publisher\" : \"吴承恩\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 0.0 } // ---------------------------------------------- { \"_id\" : 3.0, \"name\" : \"zz\" } // ---------------------------------------------- { \"_id\" : 4.0, \"name\" : \"qwe\", \"flag\" : null } // 查询名字水浒传或者view大于等于0或者拥有flag字段的文档 db.books.find({$or:[ {name:\"水浒传\"}, {view:{$gte:0}}, {flag:{$exists:true}} ]}) $and ​ 并且 ​ 格式:{ $and: [ { }, { } , ... , { } ] } { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"西游记\", \"publisher\" : \"吴承恩\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0 } // 查询view大于等于100 并且存在flag字段的文档 db.books.find({$and:[ {view:{$gte:100}}, {flag:{$exists:true}} ]}) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } $sort ​ 排序 // 按照id 倒叙排序 // -1 从大到小 // 1 从小到大 db.books.find({}).sort({_id:-1}) $skip $limit ​ $skip 采用一个正整数，该整数指定要跳过的最大文档数。 ​ $limit 采用一个正整数，该整数指定要传递的最大文档数。 ​ 作用相当于mysql中的limit 两者可以结合使用 skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 7.操作数组 8. 整合springboot简单增删改查 8.1 项目环境 ​ mongodb: 4.0.9 ​ java:1.8 ​ springboot:2.2.0 ​ idea : 2019 ​ 使用了lombok简化实体类的代码 8.2 pom依赖 org.springframework.boot spring-boot-starter-parent 2.2.0.RELEASE org.springframework.boot spring-boot-starter-data-mongodb org.springframework.boot spring-boot-starter-web org.projectlombok lombok 1.18.8 8.3 代码 实体类 @Data @Document(collection = \"students\") public class Student { @Id private String id; private Integer sid; private String name; @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:dd\") @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:dd\",timezone = \"GMT+8\") private Date birthday; private String classId; private Classes classes; private String hobbies[]; } controller @RestController @CrossOrigin(\"*\") @RequestMapping(\"/student\") public class StudentController { @Autowired private StudentDao studentDao; /** * 查询所有 * @return */ @GetMapping public List fun() { return studentDao.findAll(); } /** * 添加 * @param student */ @PostMapping public void add(@RequestBody Student student) { studentDao.save(student); } /** * 修改 * @param student */ @PutMapping public void edit(@RequestBody Student student) { studentDao.update(student); } /** * 根据字段及值 进行删除 * @param filedName * @param value */ @DeleteMapping public void deleteByFiledName(@RequestParam(name = \"filedName\") String filedName, String value) { studentDao.deleteByFiledName(filedName, value); } } dao @Repository public class StudentDao { @Autowired private MongoTemplate mongoTemplate; /** * 查询所有 * @return */ public List findAll(){ List all = mongoTemplate.findAll(Student.class); for (Student student : all) { if (student.getClassId() != null){ // 拿到每个学生对应的班级id 创建ObjectId对象 ObjectId objectId = new ObjectId(student.getClassId()); // 根据班级id查询班级 Classes one = mongoTemplate.findOne(new Query(Criteria.where(\"id\").is(objectId)), Classes.class); // 将班级添加到学生对象中 student.setClasses(one); } } return all; } /** * 添加 * @param student */ public void save(Student student) { // 可以在笔记中看到两者的区别 mongoTemplate.insert(student); // mongoTemplate.save(student); } /** * 更新 * @param student */ public void update(Student student) { // 查询条件 根据id Query id = Query.query(Criteria.where(\"_id\").is(student.getId())); // 创建文档对象 Document document = new Document(); // 向文档中追加数据 更新哪个字段添加哪个字段 document.append(\"name\",student.getName()).append(\"birthday\",student.getBirthday()) .append(\"hobbies\",student.getHobbies()); // 根据id 根据文档对象进行更新 // 因为是根据ObjectId进行更新所以唯一 使用updateFirst 只更新第一条 mongoTemplate.updateFirst(id, Update.fromDocument(document),Student.class); // 更新所有能匹配的文档 // mongoTemplate.updateMulti(); } /** * 根据字段名称删除文档 * @param filedName 字段名称 * @param value 字段对应的值 */ public void deleteByFiledName(String filedName,String value){ Query query = Query.query(Criteria.where(filedName).is(value)); mongoTemplate.remove(query, Student.class); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:27 "},"other/使用Google Cloud搭建ssr.html":{"url":"other/使用Google Cloud搭建ssr.html","title":"搭建SSR","keywords":"","body":"使用Google Cloud搭建ssr1.需要用到2.申请注册谷歌云3.创建实例4.创建防火墙规则5.开始搭建使用Google Cloud搭建ssr ​ 在youtube或者各种搜索引擎上已经有不少的视频和教程,写本文也是分享一下自己的经验:happy:。 ​ 谷歌云平台会赠送新用户300美金，免费使用一年，薅羊毛嘛:joy:。 1.需要用到 ​ 1.1.前置的科学上网工具 ​ 1.2.谷歌账号 ​ 1.3.支持外币支付的信用卡（ps.我申请的中国银行的万事达） ​ 这里放上我申请的信用卡链接:https://mp.weixin.qq.com/s/NXSM8C5mnq7I4NAlOOMlNw 2.申请注册谷歌云 ​ 2.1.地址:https://cloud.google.com/free/ ​ 2.2.其中的地区已经没有中国了选其他地区或国家,我选的香港,将自己的信用卡绑定后进入主页面 ​ 可以看到下图说明已经成功激活谷歌云了 3.创建实例 ​ 3.1.点击左上角菜单栏图标选中结算,去激活你的结算账号 ​ 3.2.选中Compute Engine ​ 3.3.创建实例详细信息 ​ 3.4.测试延迟 ​ 创建VM实例完成后,会有一个外部IP,复制该IP进行 ​ 测速:https://tools.ipip.net/traceroute.php ​ 延迟在50左右还行,100以下都能用,越小越好 4.创建防火墙规则 ​ 4.1选中菜单栏VPC网络点击防火墙规则 ​ 注意需要创建两个,下图中会有说明 5.开始搭建 ​ 5.1.在创建好的实例有一个SSH选择在浏览器窗口打开 ​ 依次输入以下命令 ​ 5.1.1. sudo -i 切换到root ​ 5.1.2. 安装SSR wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2>&1 | tee shadowsocksR.log ​ 5.1.3. ./shadowsocksR.sh 运行 ​ 5.2.回车运行后会看到下图,有解释说明 到此一个通过Google Cloud搭建的SSR就可以使用了:beers: Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:29 "},"other/阿里云域名.html":{"url":"other/阿里云域名.html","title":"阿里云域名","keywords":"","body":"阿里云购买域名注册并登陆阿里云挑选并购买域名进入控制台备案解析域名阿里云购买域名 ​ 想要搭建一个网站肯定少不了一个域名,分享一下自己在阿里云购买域名的经验 ​ 还有一个提供免费域名的网站,我没有购买成功,每次购买都会有未知错误,所以就没有后续了,哈哈 [ https://www.freenom.com/zh/index.html?lang=zh]: 注册并登陆阿里云 ​ 可以选择直接使用支付宝登陆 挑选并购买域名 进入控制台备案 ​ 购买成功后点击右上角进入控制台,在顶部搜索栏输入域名进入域名控制台. ​ 现在还不能使用我们的域名,需要我们进行备案,添加域名模板 ​ 注意事项: ​ 身份证照片:会控制大小,55k-1MB左右需要注意一下.如果手机像素太高,可以拍完后使用QQ截图 ​ 地址信息:最好和你的身份证上一致 ​ 邮箱:可能会让你验证一下,记不太清楚了 ​ 备案验证成功后进入左侧列表中的域名列表,点击解析 解析域名 ​ 解析域名就是将你的域名指向网站IP,方便记忆 ​ 进入解析设置页面后点击添加记录,其中每个选项都有解释,添加记录的旁边还有新手引导 ​ 更详细的解释有阿里提供的文档: [https://cloud.tencent.com/document/product/302/3468]: ​ 10分钟左右就可以通过域名访问你的网站了 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 23:18:29 "}}