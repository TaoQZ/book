# 一条更新语句是怎么执行的



更新与查询不一样的是，涉及了其他两个重要的日志模块，redo log(重做日志)和binlog(归档日志)，

redo log的作用：首先redo log功能是InnoDB存储引擎特有的，其作用是在真正写入数据文件前当一个缓冲，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后更新，整个IO成本、查找成本很高。redo log是物理日志，记录的是在某个数据页上做了什么修改。

这就是mysql经常说到的WAL技术，WAL全程是Write-Ahead-Logging,它的关键点就是先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候，InnoDB引擎会先把记录写到redo log里面，并更新内存，InnoDB引擎在适当的时候会将操作记录更新到磁盘里面，往往是在系统比较空闲的时候做。

binlog

是Server层实现的日志，每个存储引擎都可以使用，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给 id=2这一行的c字段加1”。

redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切文件继续写，并不会覆盖之前的日志。

更新的过程

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。


	这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

![update_sql_process](assets/update_sql_process.png)

你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

redo log的两阶段提交+binlog可以保证mysql遇到问题异常重启后的数据不丢失。

1. prepare阶段 2.写binlog 3.commit

![image-20210705100428816](assets/image-20210705100428816.png)

redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

## 不可重复读可能出现的问题

商场做活动，截至时间内，每个人只能得到一份优惠

1. 1000元以下送纸巾

2. 1000元及以上送食用油

	截至时间到后开始计算获奖名单，假如A事务正在算活动名单，先算送纸巾名单，发现用户小明消费了500符合条件添加到了获得纸巾得名单，然后事务A在算食用油名单时出现了卡顿，此时小明又成功消费了500，在计算食用油获奖名单时又出现了小明，此时小明会获得两份奖励。（）

![image-20210705112912171](assets/image-20210705112912171.png)

![image-20210705112931237](assets/image-20210705112931237.png)