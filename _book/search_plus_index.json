{"./":{"url":"./","title":"前言","keywords":"","body":"前言前言 ​ 学习笔记 ​ qq邮箱:2538474354@qq.com Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:53:58 "},"git/Git.html":{"url":"git/Git.html","title":"git安装及简介","keywords":"","body":"Git是什么及为什么使用安装及配置基本概念介绍常用流程冲突TortoiseGit:Idea配置git可能出现的问题1. 解决git clone 克隆慢2. 解决github.com 无法访问连接超时3.删除所有文件Git 是什么及为什么使用 ​ git是一个强大的版本控制工具 ​ 例如在企业团队开发中,需要协同开发,每个人负责不同的模块,但又有可能依赖其他的模块 ​ 使用git可以解决这些问题,同时还可以对版本进行严格的控制与管理 安装及配置 ​ 官网:https://git-scm.com/download ​ 一路点击下一步,取消最后的两个选项,点finish ​ 安装完成后 配置用户名和邮箱 git config --global user.name \"用户名\" git config --global user.email \"邮箱地址\" 配置后的文件在 C:\\用户\\{用户名}\\.gitconfig文件中 ​ 生成ssh 秘钥与 github相关联 1. ssh-keygen -t rsa -C \"邮箱地址\" 默认生成到当前用户 C:\\用户\\{当前用户}\\.ssh\\id_rsa.pub 2. 进入github官网,登陆后 3. Settings --> SSH and GPG keys --> New SSH key 4. 将文件中的秘钥全部复制到 key 中 基本概念介绍 master : 默认开发分支 origin : 默认远程版本库 Index/Stage : 暂存区(工作区和版本库之间) add后的区域 workspace : 工作区 init后的区域 repository : 本地仓库 commit后的区域 remote : 远程仓库 github head : 指针 可以通过指针切换版本 常用流程 git init : 初始化仓库 把这个目录变成Git可以管理的仓库 git add 文件名: 添加文件 直接写符号.将(全部文件) 把文件添加到本地仓库的暂存区 git commit -m \"提交 注释\" 提交到当前分支 git remote add origin 远程仓库地址 ：远程仓库与本地仓库添加关联 有关联后,就不用再写这行 git pull origin master : 在推之前先拉 更新代码 git push -u origin master 将代码推到远程仓库 冲突 ​ 对同一行或者同一块区域的代码进行修改后,导致本地仓库与远程仓库无法合并,因为软件也不知道采用哪一段代码,需要人工解决 这是出现冲突后在推时出现的情况 冲突:不同的人修改了相同位置的代码 ======= 其他人的代码 >>>>>>>版本号(具体的版本号可以在命令行中查询) 手动解决冲突后提交或合并后提交即可 TortoiseGit: ​ 使用git bash 需要很多重复的操作克隆 提交 推送,可以使用视图化工具简化操作 ​ 官网:https://tortoisegit.org/download/ ​ ​ 点击finish后,会进入配置 ​ 填入用户名和邮箱 ​ 安装完成后可能会需要重启 重启完成后点击鼠标右键会出现 ​ TortoiseGit --> settings 选择下方选项进行配置 安装完成后,在任意位置鼠标右键,可以完成快速克隆 提交... Idea配置git ​ Settings --> Version Control ​ 登录 ​ 如果选择上方的Enter token 登录 ​ 需要登录github官网 创建token ​ ​ 可能出现的问题 1. 解决git clone 克隆慢 ​ 开启代理(本人使用的ssr 默认端口是1080): git config --global http.proxy socks5://127.0.0.1:1080 ​ 关闭代理: git config --global http.proxy \"\" ​ 如果代理没有关闭可能也会出现 fatal: unable to access 'https://github.com/xxx/xxx.git/': Failed to connect to 127.0.0.1 port 1080: Connection refused ​ 可以使用命令关闭也可以在 C:\\Users\\{用户名}\\\\.gitconfig 中删除proxy代理 2. 解决github.com 无法访问连接超时 ​ 先在命令行ping官网 github.com ​ 如果ping不通 ​ 在 C:\\Windows\\System32\\drivers\\etc\\hosts 末尾添加 192.30.255.112 github.com git 185.31.16.184 github.global.ssl.fastly.net ​ 3.删除所有文件 git rm * -r Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"git/Idea中使用Git.html":{"url":"git/Idea中使用Git.html","title":"Idea使用Git","keywords":"","body":"配置使用1. 创建项目2. 添加文件3. 提交并推送4. 冲突配置 ​ 在git一章中有写在Idea中如何配置git 使用 1. 创建项目 ​ idea中创建项目 相当于 init 将当前项目变为工作空间 ​ github中创建新的仓库 2. 添加文件 ​ 相当于 add (文件) ​ 3. 提交并推送 ​ 在idea菜单栏VSC选项 相当于 commit ​ 选择需要提交的文件,在Commit Message 中填写信息,选择commit and push ​ 选择commit和push后,在第一次push时会遇到下图,需要将当前工作空间与远程仓库进行关联 ​ 填写完成后便可以进行推送 ​ 4. 冲突 ​ 不同的人在对相同行数的代码进行修改时,一方已经提交,另一方在拉取或者推送时会遇到冲突的问题 案例: ​ 第一次提交的代码 ​ 假设有人修改了代码,并上传成功 ​ 同时修改idea中的代码 ​ 进行commit 提交后进行pull 拉取 ​ 会出现冲突提示 ,点击中间的合并按钮 ​ 进行合并 ​ 合并后重新提交 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"vue/Vue.html":{"url":"vue/Vue.html","title":"Vue基础","keywords":"","body":"VueVue是什么使用Vue使用cdn官网下载入门案例方法生命周期指令计算属性axios路由router-link & router-view配置路由:style scopeexport default路由传参路由跳转嵌套路由Vuex什么是Vuex,为什么要有Vuex在项目中使用vuex访问vuex中的数据及方法案例,使用并修改state中的数据在Vuex中跳转组件(使用路由)mutations传参问题注意事项组件之间传值父传子子传父非父子组件之间传值导航守卫全局的单个路由独享的组件级别的Vue Vue是什么 ​ Vue是一套用于构建用户界面的渐进式框架(可以循序渐进的进行学习),是一个MVVM的框架,功能强大,重要特点双向绑定 ​ MVVM: ​ M:model,数据/模型层 ​ V:view 视图层 ​ VM:核心层,负责连接M和V,这一层已经由Vue实现好了 ​ 双向绑定: ​ 更新view页面的数据同步到data ​ 更新data中的数据同步渲染到页面 使用Vue ​ 以下案例的github地址:https://github.com/TaoQZ/Vue_example.git 使用cdn 官网下载 https://cn.vuejs.org/v2/guide/installation.html 入门案例 Title // 创建vue实例 // el 获取指定id的容器 // data 数据 // methods 方法 var vm = new Vue({ el:'#app', data:{ msg:'测试' }, methods:{ } }) 方法 var vm = new Vue({ methods:{ fun1:function () { console.log('方法1') }, fun2(){ console.log('方法2') }, // 箭头函数 // 1. 没有参数,或多个参数使用 () (a,b) // 2. 一个参数可以省略() 直接写形参 a // 3. 返回值 只有一行代码包括返回值 可以省略{} // 4. 多行代码需要 {} // 5. 注意 使用该箭头函数定义方法时,方法中this的指向不在再是Vue实例 fun3: () => console.log('方法3') } }); vm.fun1(); vm.fun2(); vm.fun3(); 生命周期 var vm = new Vue({ el:'#app', data:{ msg:'+' }, methods:{ show(){ console.log('我是show方法') } }, // 初始化前 数据和方法均为未初始化 beforeCreate(){ // undefined console.log(this.msg) // this.show is not a function this.show() console.log('=======================================') }, // 初始化完成 数据和方法已初始化完成 created(){ // 全部正常打印 console.log(this.msg) this.show() console.log('=======================================') }, // 双向绑定(挂载)前,表示模板已经编译完成,但是未将模板渲染到页面中 beforeMount(){ // 未渲染状态,只是原始字符串 console.log(document.getElementById('app').innerText) console.log('=======================================') }, // 双向绑定(挂载)后,将数据渲染到页面 mounted(){ // + console.log(document.getElementById('app').innerText) console.log('=======================================') }, // 更新钩子函数需要改变数据才会触发 // 更新前 data中的数据已经发生变化 未渲染到页面(页面还没同步) beforeUpdate(){ // + console.log(\"更新前\"+this.msg) // - console.log(\"更新前\"+document.getElementById('app').innerText) }, // 更新后 updated(){ // - console.log(\"更新后\"+this.msg) // - console.log(\"更新后\"+document.getElementById('app').innerText) }, // 销毁Vue实例 beforeDestroy(){ console.log('销毁前'+this) }, destroyed(){ console.log('销毁后'+this) } }) // 销毁Vue实例 vm.$destroy(); 指令 插值表达式 ​ 格式:{{}} ​ 可以直接获取Vue实例中定义的数据或函数 ​ 支持有返回值的函数或表达式 ​ 注意:该方式有缺点,在网速较慢时会出现{{}} 闪烁问题 2 var vm = new Vue({ el:'#app', data:{ msg:'zz' }, methods:{ show(){ return 10 } } }) v-text v-html ​ 为了解决插值闪烁问题提供了解决办法 ​ v-text : 将数据原样输出 ​ v-html : 可以将html的字符串渲染到页面 ​ var vm = new Vue({ el:'#app', data:{ msg:'tao' } }) v-model 加 表单元素 ​ 插值表达式,v-text,v-html : 只是数据的单向绑定 ​ v-model可以使视图和数据进行双向绑定,互相影响 ​ Title hobby: 网球 游泳 跑步 sex: 男 女 单复选框： 下拉列表 请选择 // 注意: 在data中拿到的值是标签的value值 var vm = new Vue({ el:'#app', data:{ num:1, hobby:[], checked: true, sex:'male', items:['河北','天津','北京'], province:'' } }) v-on ​ 例子 涉及事件 ​ click keydown mouseover mouseout ​ 事件处理的指令 var vm = new Vue({ el:'#app', methods:{ show(e){ console.log(e.keyCode) }, inDiv(){ console.log(\"鼠标移入\") }, outDiv(){ console.log(\"鼠标移出\") }, buttonClick(){ console.log('点击事件') }, isEnter(e){ console.log(e.keyCode) } } }) ​ 事件冒泡+vue解决办法_按键修饰符 ​ 事件发生时,触发内层的事件会同时触发外层的事件 ​ 常用按键修饰符 ​ .enter // 表示键盘的enter键 .tab .delete (捕获 \"删除\" 和 \"退格\" 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta 百度 var vm = new Vue({ el:'#app', methods:{ divClick(){ console.log('div') }, buttonClick(e){ // js中冒泡的解决方案 // 阻止事件的传播行为 // e.stopPropagation(); console.log('button') }, jump:()=>{ console.log('点击a标签后没有跳转网页') }, isEnter(e){ console.log(e.keyCode) } } }) v-for --------- var vm = new Vue({ el:'#app', data:{ users:[ {name:\"aa\",age:\"23\",sex:\"男\"}, {name:\"bb\",age:\"21\",sex:\"男\"}, {name:\"cc\",age:\"20\",sex:\"男\"} ] } }) v-if v-else-if v-else ​ v-else 必须紧跟在 v-if 或 v-else-if 后 ​ v-else-if 必须紧跟在v-if 或者 v-else-if 后 ​ A B C 索引 姓名 年龄 性别 20\"> {{index}} {{user.name}} {{user.age}} {{user.sex}} var vm = new Vue({ el:'#app', data:{ char:'A', users:[ {name:\"aa\",age:\"23\",sex:\"男\"}, {name:\"bb\",age:\"21\",sex:\"男\"}, {name:\"cc\",age:\"20\",sex:\"男\"} ] } }) ​ v-show与v-if flag flag var vm = new Vue({ el:'#app', data:{ flag:true }, methods:{ change(){ this.flag = !this.flag } } }) v-bind ​ 将html标签的属性与data中的数据进行绑定,可以简写为 :需要绑定的属性 Title .red{ background-color: red; } .black{ background-color: black; } .green{ background-color: green; } 请选择 var vm = new Vue({ el:'#app', data:{ myclass:'', colors:[ {name:'红',clas:'red'}, {name:'黑',clas:'black'}, {name:'绿',clas:'green'} ] } }) ​ 计算属性 ​ 解决在插值表达式中书写过长或需要长期维护使用的表达式比较麻烦 var vm = new Vue({ el:'#app', data:{ msg:'' }, methods:{ method_num(){ return 1+1; } }, computed:{ computed_num(){ return 2+1; } } }) axios ​ 用于发送http请求 ​ cdn 在使用vue-cli脚手架创建的项目中使用 下载依赖 npm install axios 在项目中引入 全局引入需要在main.js中导入 局部引入需要在export default 上导入: // 导入 axios import axios from 'axios' // 设置请求路径的前缀 axios.defaults.baseURL='http://localhost:8080' // 第一个axios可以当做全局的访问前缀 Vue.prototype.axios(相当于起别名) = axios 示例: 全局 全局需要使用this. 局部不需要 export default { name: \"list\", data(){ return{ users:[] } }, methods:{ findAll(){ this.axios.get('/user') .then(res => this.users = res.data) }, created() { this.findAll(); } } ​ 2.局部 // 局部引入axios 不需要this // import axios from 'axios' // axios.defaults.baseURL='http://localhost:8080' export default { name: \"list\", data(){ return{ users:[] } }, methods:{ findAll(){ axios.get('/user') .then(res => this.users = res.data) } }, created() { this.findAll(); } } ​ git传递对象参数 this.axios.get('url',{ params : 对象 }) ​ delete传递参数 数组 ​ 需要配合qs使用 安装 npm install qs main.js 中配置 import qs from 'qs' Vue.prototype.qs = qs this.axios.delete(\"/book\", { params: { books: arr }, paramsSerializer: params => { // false 用来控制格式 return qs.stringify(params, { indices: false }) } }).then(() => { this.getPageInfo(this.num, this.size); }) 路由 router-link & router-view : : 配置路由: ​ 使用vue-cli创建项目后就已做好的: ​ 在router/index.js文件中 导入 vue-router并使用 // 导入 导入时名字可以随便起,但在use名字时必须相同 import Vue from 'vue' import VueRouter from 'vue-router' // 导入组件 全局引入 import Home from '../views/Home' // 使用 Vue.use(VueRouter) // 创建路由 数组 const routes = [ // path:访问路径 // name:路由名称 // component:要跳转到的组件 需要导入 { // 写路径时记得写 / path: '/', name: 'home', component: Home, // 再使用时引入的方式,可以提高首页显示速度 // component: () => import('../views/Home.vue') } ] ​ main.js import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false; new Vue({ router, // 相当于 router:router store, render: h => h(App) }).$mount('#app'); style scope export default // 就是vue的实例 是es6的语法 和之前写的差别是,data只能按照这种格式(和写时组件一样) export default { name: \"list\", methods:{ to(){ alert(\"list\") } }, data(){ return{ msg:'msg' } } } 路由传参 ​ 1.name+params 修改 ​ // 接收 this.$route.params.id ​ 2.path+query 修改 // 接收 在地址栏填写参数也是使用该方式获取 this.$route.query.id; ​ 3.路由传参(地址栏) // 在路由的path后添加 :参数名 { path: '/edit/:id', name: 'edit', component: Edit } 修改 路由跳转 this.$router.push(路由的path) 嵌套路由 ​ 在一个组件中引入了另一个组件,相当于父与子的关系 我是父页面 去子页面 我是子页面 ​ router/index.js 配置 const routes = [ // path:访问路径 // name:路由名称 // component:要跳转到的组件 需要导入 { path: '/father', name: 'father', component: () => import('../views/father.vue'), children:[ { // 注意子路由不能加 / path: 'son', name: 'son', component: () => import('../views/son.vue'), }, // 子路由path的第二种写法,访问路径加上父组件的路径 // { // path: '/home/son', // name: 'son', // component: () => import('../views/son.vue') // } ] } ] Vuex 什么是Vuex,为什么要有Vuex ​ Vuex是组件之间数据共享的一种机制 ​ 使用父子传值或兄弟传值,太麻烦不好管理,有了Vuex想要共享数据,只需要把数据挂在到vuex就行,想要获取数据,直接从vuex上拿就行,vuex中的数据被修改后其他引用了此数据的组件,也会同步更新 在项目中使用vuex ​ 安装vuex: npm install vuex ​ 使用 在store/index.js文件 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ // 公共区域数据 state: { num : 10, msg : 'zz' }, mutations: { }, actions: { }, modules: { } }) 在main.js文件中将store挂在到vm实例上 import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false new Vue({ router, store, render: h => h(App) }).$mount('#app') 访问vuex中的数据及方法 ​ 数据 this.$store.state.变量名 vue官方并不推荐通过上面的方式获取数据 使用结构表达式 在组件内导入 import {mapState} from 'vuex' 创建一个computed属性 // 官方推荐的使用方式,进行结构,将公共属性的值作为计算属性 computed:{ ...mapState(['num','msg']) }, ​ 方法 ​ 登录案例 登录 账号: 密码: import {mapActions} from 'vuex' export default { methods:{ ...mapActions(['login']), }, name: \"Login\", data(){ return{ user:{} } }, } actions: { // 第一个参数默认 login(context,user){ // 调用的mutations中的方法,进行封装使之可以提交异步请求 context.commit('login',user) } }, 案例,使用并修改state中的数据 在store/index.js中定义变量存储数据 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ // 公共区域数据 state: { num : 10, }, mutations: { addNum(state){ state.num++ } }, actions: { }, modules: { } }) 在components中创建两个组件 ​ app.vue --> add: --> add: num: // 结构表达式 import {mapState} from 'vuex' import {mapMutations} from 'vuex' export default { name: \"add\", // 官方推荐的使用方式,进行结构,将公共属性的值作为计算属性 computed:{ ...mapState(['num','msg']) }, methods:{ add(){ this.$store.state.num++ }, ...mapMutations(['addNum']) } } ​ minus.vue // 解构 将vuex中的数据解构成计算属性使用 import {mapState} from 'vuex' export default { name: \"add\", methods:{ }, computed:{ ...mapState(['num']) } } ​ router/index.js // 将这两个组件导入 import add from '@/components/add.vue' import minus from '@/components/minus.vue' const routes = [ { path:'/访问路径', name:'home', components:{ add, minus } }, ] ​ ​ App.vue:用于显示变量,观察其修改后组件中数据是否同步更新 在Vuex中跳转组件(使用路由) ​ 在Vuex中访问不到路由实例 ​ 需要导入 // 导入 import router from '../router'; // 使用 router.push({path:'/'}) mutations传参问题 ​ 如果在调用mutations中的方法时,方法有多个参数,后面的参数是undefined ​ 将参数封装成对象进行传值 注意事项 ​ 如果想获取有返回值的方法(对state中的数据有所更改后),可以在getters中创建方法,并 返回处理后的结果,使用this.$store.getters.方法名获取 ​ vue推荐使用mutations来对state中的数据进行修改,mutations中的方法第一个参数必 须是state,也就是当前vuex中的state,可以直接调用 ​ actions:包裹mutations中的方法,异步调用 ​ 例子: mutations:{ // 第一个参数必须是state addNumS(state,step){ state.num += step }, }, actions: { // 第一个参数必须是context step:参数 addNumSAysc(context,step){ // 利用context来调用mutations的方法来操作state中的数据 context.commit('addNumS',step) } }, 组件之间传值 父传子 ​ 父组件 我是父组件 // 导入子组件 import son from '@/views/Son' export default { name: \"Parent\", data(){ return{ msg : '我是父组件中的数据' } }, // 注册使用 components:{son} } ​ 子组件 我是子组件: export default { name: \"Son\", // 定义props属性用来接收父组件的数据 props:['sonMsg'] } 子传父 ​ 父组件 我是父组件 我是子组件传递到父组件的数据: // 导入子组件 import son from '@/views/Son' export default { name: \"Parent\", data(){ return{ msg : '我是父组件中的数据', sonMs: '' } }, methods:{ sonSMsg(msg){ this.sonMs = msg } }, // 注册使用 components:{son} } ​ 子组件 我是子组件中的按钮 export default { name: \"Son\", data(){ return{ msg:'我是子组件中的数据' } }, methods : { sendMsgToParent(){ this.$emit('fromSon',this.msg) } } } 非父子组件之间传值 ​ 设立公共数据文件 ​ Bus.js // 导入vue import vue from 'vue' // 创建vue对象 export default new vue() ​ Demo01.vue // 导入 兄弟组件 为了将其显示在同一个页面 import demo02 from '@/views/Demo02' // 导入Bus.js 公共数据文件 import bus from './Bus.js' export default { name: \"Demo01\", data(){ return{ msg : '我是demo01中的数据' } }, methods:{ sendMsgToDemo02(){ // 固定格式 bus.$emit('fromDemo02',this.msg) } }, components:{demo02} } ​ Demo02.vue 我是demo02: 我是传递过来的数据:插值表达式 msg // 导入Bus.js 公共数据文件 import bus from './Bus.js' export default { name: \"Demo02\", data(){ return{ msg : '' } }, created() { // 固定格式 data就是传递过来的数据 bus.$on('fromDemo02',data => { this.msg = data }) } } 导航守卫 导航守卫的主要作用就是为了拦截导航路由,使之可以跳转或者取消,有多种方式注册路由导航钩子 全局的 在 main.js中注册一个全局的路由导航钩子 /** * to : 路由将要跳转的路由的信息 * from : 路径跳转前的路径信息 * next : * next() : 放行 * next(false) : 返回原来的页面 * next('路径') : 改变路由跳转地址 跳转指定路由 */ router.beforeEach((to,from,next)=>{ }) 单个路由独享的 { path: '/login', name: 'login', component: Login, beforeEnter(to,from,next) { } } 组件级别的 export default { name: \"Login\", beforeRouteEnter(to, from, next) { console.log(\"准备进入登录\"); next(); }, beforeRouteUpdate(to,from,next){ console.log('路由发生改变,组件被复用时触发') }, beforeRouteLeave (to, from, next) { console.log(\"准备离开登录\"); next(); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-14 21:36:05 "},"vue/vue面试题.html":{"url":"vue/vue面试题.html","title":"Vue面试题","keywords":"","body":"1.MVVM中,MVVM分别代表什么?作用是什么2.简述什么是单页,以及单页的优缺点3.Vue项目中的src文件夹一般放置那些文件及文件夹4.简述vue的声明周期及钩子函数5.前后台分离,怎么解决跨域问题6.Vue-router的作用是什么7.Vue中父子组件之间如何传值是怎么实现的8.Vue如何传参9.Vuex怎么实现数据共享10.Vue的全家桶有哪些11.Vue的导航守卫是什么?有什么作用?12.Vuex的五大核心属性13.var let const的区别14.Vue中常用的指令15.Vue中的事件修饰符16.什么是js的冒泡事件17.什么是计算属性,如何理解18.import.export导入和导出1.MVVM中,MVVM分别代表什么?作用是什么 ​ MVVM是model-view-viewModel的简写,是MVC的改进版 ​ 为了分离model(模型)和view(视图),再由viewModel将v和m连接起来 ​ 当model(模型)发生改变时,通过MVVM框架自动更新view视图状态 ​ 当view(视图)发生改变时,通过MVVM框架自动更新model模型数据 2.简述什么是单页,以及单页的优缺点 ​ 总:项目中只有一个html页面,由多个组件构成 ​ 优点:速度快,用户体验好,修改内容不会刷新整个页面,因此,spa对服务器的压力也会变小;前后端分离;页面效果炫酷(比如切换页面时的专场动画) ​ 缺点:初次加载耗时长;提高页面复杂度;不利于seo;导航不可用,如果需要使用需要自行完成后退前进功能 3.Vue项目中的src文件夹一般放置那些文件及文件夹 ​ assets:静态资源目录 ​ components:功能组件 ​ views:页面组件 ​ store:vuex的数据 ​ router:路由文件 ​ App.vue:入口页面 ​ main.js:全局的配置文件 4.简述vue的声明周期及钩子函数 ​ vue的生命周期就是该vue实例从创建到销毁的过程 ​ beforeCreat:创建完成之前,数据未完成初始化 ​ created:创建完成后,数据已完成初始化,一般用于页面渲染 ​ beforeMount:双向绑定前 ​ mounted:双向绑定后 ​ beforeUpdate:更新前 ​ updated:更新后 ​ beforeDestroy:销毁前 ​ destroyed:销毁后 5.前后台分离,怎么解决跨域问题 ​ 1.jsonp:叫古老的方式,利用script标签可跨域的特性,缺点是只能发送get请求 ​ 2.nginx:配置代理服务器,使其可以访问目标服务器,然后再将目标服务器返回的数据返回到我们的客户端,可以发送各种请求 ​ 3.比较常用的cors,需要后端设置Access-control-Allow-Origin头,可以自行配置可跨域的地址,缺点是可能会发生两次请求 6.Vue-router的作用是什么 ​ vue-router是vue.js官方的路由管理器 ​ :完成组件之间的切换 ​ this.$route : 完成组件之间的传参 ​ this.$router.push():完成组件之间的跳转 7.Vue中父子组件之间如何传值是怎么实现的 ​ 1.父传子:在子组件中设置props属性用于接受父组件传递的数据 ​ 2.子传父:子组件触发自身的方法,使用$emit调用父类的监听的方法 ​ 3.非父子组件:需要设立公共的文件 8.Vue如何传参 ​ 1.query+path 传参: 获取值: this.$route.query.参数名 ​ 2.params+name 传参: 获取值: this.$route.params.参数名 ​ 3.路由传参(地址栏) 在路由组件的配置上添加 { path:'/path/:参数名' name: component: } 获取值: this.$route.params.参数名 9.Vuex怎么实现数据共享 ​ vue整合vuex,在main.js中以组件的方式导入store.js文件 ​ 在store.js文件的state区域保存数据,使之可以在任何位置可被访问 ​ 使用store.js文件中的mutations可以更新state区域的数据,通过读写完成数据的共享 10.Vue的全家桶有哪些 ​ Vue的两大核心: ​ 组件化:将一个整体应用,拆分成多个可复用的个体(组件) ​ 数据驱动:在修改数据的前提下,不操作dom,直接影响bom显示 ​ vue-router:路由,组件之间的切换 ​ vue-cli:构建vue单页应用的脚手架工具 ​ vuex:状态数据 ​ axios:vue官方推荐的发送http请求的工具包 11.Vue的导航守卫是什么?有什么作用? ​ vue-rouer提供的导航钩子,主要用来拦截导航,完成跳转或取消,有多种方式可以在路由导航发生时执行路由导航钩子 ​ 全局的: ​ router.beforeEach在全局注册一个before钩子 ​ 单个路由独享的: ​ 在路由配置中直接定义一个beforeEnter路由导航钩子 ​ 组件级别的: ​ beforeRouteEnter,beforeRouteUpate,beforeRouteLeave ​ 直接在路由组件中定义路由导航钩子 12.Vuex的五大核心属性 ​ Vuex是专门为vue.js应用设计的状态管理架构 ​ 1.state:基本数据 ​ 2.getters:从基本数据派生的数据 ​ 3.mutations:更改数据的提交方式,同步 ​ 4.actions:像一个装饰器,用来包裹mutations,使之可以异步 ​ 5.modules:模块化vuex 13.var let const的区别 ​ var是es3提供的创建变量的关键字,定义的变量为全局变量 ​ let是es6新增的定义变量的关键字,定义的变量是局部变量 ​ const定义的变量的常量 14.Vue中常用的指令 ​ v-if:当条件为true时,显示该元素 ​ v-show:修改页面元素的css样式完成显示或隐藏 ​ v-on:为标签添加事件 ​ v-model:双向绑定,用于数据和视图的同步 ​ v-bind:将数据绑定的标签的属性上 ​ v-for:遍历数组 15.Vue中的事件修饰符 ​ .stop:阻止冒泡 ​ .prevent:禁止默认事件 ​ .capture:捕获 ​ .once:只执行一次 ​ .self:只在自身触发 16.什么是js的冒泡事件 ​ 当触发页面中标签的事件时,会同时触发其所有父与子标签的事件,直到跟标签 17.什么是计算属性,如何理解 ​ 计算属性本质是一个有返回值的方法,在页面渲染时,可以将该方法当做一个属性使用,当data中的数据未发生改变时,计算属性直接读取缓存 18.import.export导入和导出 ​ 是es6中,module主要构成的两个命令 ​ export:用于导出模块中的变量的接口 ​ import:用于在一个模块中导入另一个含有export接口的接口 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"jwt/JWT.html":{"url":"jwt/JWT.html","title":"JWT","keywords":"","body":"JWT为什么使用jwt流程token包含的内容JWT详解使用JWT ​ 官网:https://jwt.io/ ​ JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；它是分布式服务权限控制的标准解决方案！ 为什么使用jwt ​ 在之前的单体项目中,用户登录后将信息存储到session中,从而判断当前用户是否登录限定请求资源,但现在是前后端分离,如果还是用session,后端服务由于要保证高可用使用了集群,此时便需要实现session之间的共享,使用jwt避免这些麻烦的操作 流程 ​ 用户请求登录服务后,请求成功颁发jwt凭证,也就是token,将token保存到客户端中,此后的每次请求客户端都会携带此凭证到独立的验证授权中心进行校验 token包含的内容 JWT的token包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型type，这里是JWT（type=jwt） 加密算法，自定义(rs256/base64/hs256) 我们会对头部进行base64加密（可解密），得到第一部分数据 Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息-userid,username（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64加密，得到第二部分数据 Signature：base64加密，签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret，盐）（不要泄漏，最好周期性更换），通过加密算法生 JWT详解 jwt的一个有规则的token 它有三部分组成：Header.payload.signature,每部分都是通过base64加密而成的 jwt每个部分都是可以解密的 JWT详解 base64编码原理 Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符如下： 这64个字符是各种字符编码（比如ASCII码）所使用字符的子集，并可打印。唯一有点特殊的是最后两个字符。 Base64本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。假设我们对Hello！进行Base64编码，按照ASCII表，其转换过程如下图所示： 可知Hello！的Base64编码结果为SGVsbG8h，原始字符串长度为6个字符串，编码后长度为8个字符，每3个原始字符经编码成4个字符。 但要注意，Base64编码是每3个原始字符编码成4个字符，如果原始字符串长度不能被3整除，怎么办？使用0来补充原始字符串。 以Hello！！为例，其转换过程为： Hello!! Base64编码的结果为 SGVsbG8hIQAA 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 AA 实际不带有效信息，所以需要特殊处理，以免解码错误。 标准Base64编码通常用 = 字符来替换最后的 A，即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。 如果Base64编码字符串不会相互拼接再传输，那么最后的 = 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 = 字符，再解码即可。 解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。 总结： 1、base64的编码/加密原理 答：原理：将键盘输入的字符用base64编码表示 过程：将键盘输入字符的ascii码值，转成的对应8位二进制，将该二进制6个一组拆分，并计算拆分之后的十进制值，找出十进制值在base64编码中对应的字母，即完成base64加密 成。用于验证整个数据完整和可靠性 使用 依赖 0.7.0 2.9.6 io.jsonwebtoken jjwt ${jjwt.version} joda-time joda-time ${joda-time.version} 工具类 import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import org.joda.time.DateTime; import javax.crypto.spec.SecretKeySpec; import javax.xml.bind.DatatypeConverter; import java.security.Key; public class JWTUtil { /** * 获取token中的参数 * * @param token * @return */ public static Claims parseToken(String token,String key) { if (\"\".equals(token)) { return null; } try { return Jwts.parser() .setSigningKey(DatatypeConverter.parseBase64Binary(key)) .parseClaimsJws(token).getBody(); } catch (Exception ex) { return null; } } /** * 生成token * * @param userId * @return */ public static String createToken(Integer userId,String key, int expireMinutes) { SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; long nowMillis = System.currentTimeMillis(); //生成签名密钥 byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(key); Key signingKey = new SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName()); //添加构成JWT的参数 JwtBuilder builder = Jwts.builder() // .setHeaderParam(\"type\", \"JWT\") // .setSubject(userId.toString()) .claim(\"userId\", userId) // 设置载荷信息 .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())// 设置超时时间 .signWith(signatureAlgorithm, signingKey); //生成JWT return builder.compact(); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 14:02:12 "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring","keywords":"","body":"Springspring使用事务自定义配置Spring ​ context包提供了IOC容器功能 ​ IOC就是一个大的Map集合,key就是name,value就是对象 XML方式 public class XmlTest { @Test public void demo(){ ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Object user = classPathXmlApplicationContext.getBean(\"user\"); System.out.println(user); } } 注解方式 // 使用注解方式的配置类 @Configuration public class SpringConfig { // 可以自定义name,默认是方法名 @Bean public User getUser(){ return new User(); } } public class AnnoTest { @Test public void demo(){ AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); User user = (User) app.getBean(\"getUser\"); System.out.println(user); // 根据类获取该类在容器中的name String[] beanNamesForType = app.getBeanNamesForType(User.class); // 获取容器中所有的name String[] names = app.getBeanDefinitionNames(); } } @ComponentScan ​ 该注解写在配置类用于扫描其他其他包中的组件@Controller @Service @Repository 这三个组件最顶层是@Component ​ 默认的name是类名首字母小写 ​ 通过该注解扫描得到的Bean和在配置类中使用@Bean注解得到的Bean是一个级别的 // 扫描时进行包含过滤,过滤类型默认为注解,classes的值则是最后包含的组件 // 需要将默认的过滤方式禁用 false // FilterType 常用类型还有自定义 也就是指定哪些类 ASSIGNABLE_TYPE // useDefaultFilters的作用是 是否开启扫描其他组件默认为true 包含时设置为false,排除某个类型时为true @Configuration @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}) },useDefaultFilters = false) // public class SpringConfig { } 主要属性 value：指定要扫描的package； includeFilters=Filter[]：指定只包含的组件 excludeFilters=Filter[]：指定需要排除的组件； useDefaultFilters=true/false：指定是否需要使用Spring默认的扫描规则：被@Component, @Repository, @Service, @Controller或者已经声明过@Component自定义注解标记的组件； 在过滤规则Filter中： FilterType：指定过滤规则，支持的过滤规则有 ANNOTATION：按照注解规则，过滤被指定注解标记的类； ASSIGNABLE_TYPE：按照给定的类型； ASPECTJ：按照ASPECTJ表达式； REGEX：按照正则表达式 CUSTOM：自定义规则； value：指定在该规则下过滤的表达式； 自定义一个扫描过滤类TypeFilter 过滤类: public class CustomTypeFilter implements TypeFilter { /** * 读取到当前正在扫描类的信息 * @param metadataReader * 可以获取到其他任何类的信息 * @param metadataReaderFactory * @return * @throws IOException */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { // 获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); // 获取当前正在扫描的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); // 获取当前类路径 Resource resource = metadataReader.getResource(); System.out.println(classMetadata.getClassName()); // 可以在此处进行判断,根据类信息进行过滤 return false; } } 配置类: @Configuration @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { // 将过滤类型改为CUSTOM自定义,classes的值为自定义的过滤类 @ComponentScan.Filter(type = FilterType.CUSTOM,classes ={CustomTypeFilter.class}) },useDefaultFilters = false) public class SpringConfig { } ​ @ComponentScans // (可以声明多个@ComponentScan) @ComponentScans({@ComponentScan(\"xyz.taoqz\"), @ComponentScan(value = \"xyz.taoqz.two\",includeFilters = { @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {CustomTypeFilter.class}) },useDefaultFilters = false) }) public class SpringConfig { } @Scope作用域 @Configuration public class SpringConfig { // 无论是使用@Bean还是其他组件的注解,默认都是单例的 @Bean /** * 更改作用域 * singleton: 单实例,IOC容器启动时会调用方法创建对象并放到IOC容器中,以后获取时拿的是同一个对象 * prototype: 多实例,IOC容器启动时并不会调用方法创建对象,而是每次使用时用方法创建对象 * request: 一个请求一个实例 * session: 同一个会话一个实例 */ @Scope(\"PROTOTYPE\") public User getUser(){ return new User(); } } @Lazy懒加载 ​ 懒加载:主要针对单例Bean在容器启动时创建对象,设置懒加载后,容器启动后不再创建对象,但是可以在容器中获取其beanname,在第一次使用时才会创建对象初始化 ​ 如何使用懒加载? ​ 在@Bean注解或者其他组件上添加@Lazy注解 ​ 代码示例: @Configuration public class SpringConfig { @Bean @Lazy public User getUser(){ System.out.println(\"向容器中添加对象\"); return new User(); } } public class LazyTest { @Test public void fun(){ AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); System.out.println(\"容器创建完成\"); app.getBean(\"getUser\"); } } console: 容器创建完成 向容器中添加对象 使用懒加载后,会先创建容器,然后在获取Bean时才会向容器中添加对象并获得 @Conditional条件注册Bean ​ @Conditional(Class [] value()) ​ 写在类上表示该类或者该配置类下所有Bean必须符合条件才会注册,和@Bean一起写在方法上表示该方法返回值能否注册 ​ 该注解的参数是一个Condition的实现类,实现其方法,可以判断Bean满足需求时进行注册 public class MyCondition implements Condition { /** * 判断条件可以使用的上下文(环境0 * @param context * 注解的信息 * @param metadata * @return */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 可以在此处进行逻辑判断 返回true时Bean实例才会注入到容器中 return false; } } @Import注册Bean ​ @Import(Class [] value()) : 参数时要注册的Bean的class数组 回顾注册Bean的几种常用的方式 ​ 1.在配置中使用@Bean的方式将方法的返回值注册到容器中,通常是使用第三方类库时使用使用组件加包扫描的方式,一般用于自定义 ​ 2.组件注解:@Component @Controller @Service @Repository ​ 包扫描:@ComponentScan(组件注解所在的包) ​ 此方法优先级高于Import方式使用@Import注解 ​ 3.使用@Import方式注册的Bean其name是类全路径(包名+类名) ​ 回顾使用其他方式时的name(没有指定名称的情况下) ​ @Bean : 方法名 ​ 组件 : 类首字母小写 ​ 4.使用FactoryBean 下方有解释 ImportSelector自定义注册Bean // 在配置类中添加 @Import(value = {MyImportSelector.class}) public class MyImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { // 返回需要注册到容器中的Bean的全类名数组 return new String[0]; } } ImportBeanDefinitionRegistrar手动注册Bean // 在配置类中添加 // @Import(value = {MyImportBeanDefinitionRegistrar.class}) public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { /** * 当前类的注解信息 * @param importingClassMetadata * BeanDefinition注册类 * 把所有需要添加到容器中的Bean加入 * @param registry */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // 该方法可以判断容器中是否有指定name的Bean registry.containsBeanDefinition(\"\"); // 使用该方式注册Bean时,需要手动给出Bean的信息 Spring提供了RootBeanDefinition类 // 调用注册Bean的方法手动将Bean的name 和 信息注册到容器中 // IDEA中双击Shift键 搜索DefaultListableBeanFactory 类 会调用该类中的registerBeanDefinition将Bean注册到容器中 RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Animal.class); registry.registerBeanDefinition(\"animal\",rootBeanDefinition); } } FactoryBean ​ 如果想创建一个工厂类,用来灵活的创建对象并且想要交由Spring管理,可以使用该类 ​ 需要注意的是getBean时获取的对象并不是Factory本身,而是其getObject()方法的返回值返回的具体类型 ​ 想要获取该类对象在getBean()中的beanname参数前加&,底层在获取对象时会先判断beanname是否以&开头 ​ 使用方式:实现改接口,并且重写方法,将该类注入到容器中 Object getObject() : 该方法则为实际返回的对象 Class getObjectType() : 对象的类型 boolean isSingleton() : 表示对象注入容器时是否单例 ​ Bean的声明周期 ​ 创建 : 构造方法 ​ 初始化 : 指定的初始化方法 ​ 销毁 : 指定的销毁方法 ​ 会在容器关闭或移除对象时执行 ​ 创建和初始化会在容器创建完成前 自定义初始化销毁方法 ​ xml方式 ​ 注解方式1 @Bean(initMethod = \"初始化方法名\",destroyMethod = \"销毁方法名\") public Person person(){ return new Person(); } ​ 注解方式2 ​ 属于JDK的注解 ​ @PostConstruct : 初始化方法 ​ @PreDestroy : 销毁方法 @Component public class Person { public Person() { System.out.println(\"创建Person\"); } // 对象创建并赋值后调用 @PostConstruct public void init(){ System.out.println(\"Person 初始化\"); } // 容器移除对象调用 @PreDestroy public void destory(){ System.out.println(\"Person销毁\"); } } ​ spring 提供的接口 ​ InitializingBean, DisposableBean : 实现该接口完成init和destroy ​ 注意:只有单实例在容器创建时才会执行Bean的创建和初始化,并添加到容器中 ​ 多实例只有在获取Bean时才会执行 BeanPostProcessor接口 ​ 实现该接口可以在对象创建完成后的初始化方法前后进行增强 ​ spring底层有很多实现该接口的类(处理器),功能包括bean的赋值,注入其他组件,生命周期注解功能等 @Value 赋值 ​ 1.普通赋值,直接在组件的成员变量上声明该注解并且赋值(字符串),同时支持springEL表达式完成计算 ​ 例如 @Value(\"#{1*3}\") 在获取时便可得到该表达式的结果 ​ 2.使用.properties文件+@PropertySource(文件名数组)注解 ​ @Value(\"${属性名在文件中的key}\") ​ 在配置类上声明@PropertySource(value = {\"文件名\"}) AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class); // 获取环境 ConfigurableEnvironment environment = app.getEnvironment(); // 获取所有配置文件 MutablePropertySources propertySources = environment.getPropertySources(); for (PropertySource propertySource : propertySources) { System.out.println(\"获取每一个配置文件名称\"+propertySource.getName()); System.out.println(\"获取每一个文件中的所有的属性及属性值\"+propertySource.getSource()); System.out.println(\"获取指定属性名称的属性值 没有则为null\"+propertySource.getProperty(\"name\")); } 关于自动装配 @Autowired ​ @Autowired默认根据变量名作为beanname获取,如果没有则根据类型查找,@Autowired本身不能根据beanname指定 获取容器中的实例对象,需要配合使用@Qualifier(beanname) ​ required属性 ​ 属性值为true表示注入的时候，容器中该bean必须存在，否则就会注入失败。 ​ 属性值为false：表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错 @Resource ​ jdk提供的@Resource(name = beanname)注解可以指定名称,默认根据变量名作为beanname获取,如果没有则根据类型查找,不支持required,不支持优先级 @Primary ​ 设置获取bean时的优先级,可以在类上添加,也可以配合@Bean使用 ​ 使用@Autowired注解进行依赖注入时便会使用声明该注解的实例,@Resource不会起作用 ​ 比如一个接口有两个实现类,都会被扫描进容器,但是在使用接口进行注入时会报错,如果给 其中一个实现类添加优先级,会解决该问题并且优先使用该实现类 ​ @Inject ​ 是Java JSR330的规范,和@Autowired功能类似,支持@Primary优先级,区别是没有required属性 javax.inject javax.inject 1 ​ 如果@Bean的方法名或者name相同于类首字母小写或者注解中的beanname会优先使用 @Bean产生的实例此效果三种注解相同 如果同时声明了@Qualifier(beanname1)+@Autowired和@Primary+@Bean(beanname2):会使用beanname1 注入顺序 **@Qualifier > 优先级 > 变量名(同名@Bean优先) > 类型** AOP ​ 面向切面编程(底层使用动态代理) ​ 在程序运行期间动态,在不修改源码的基础上，对已有方法进行增强。 ​ 使用aop需要的依赖 org.springframework spring-aspects 5.1.8.RELEASE ​ 相关术语: ​ Target(目标对象):被增强方法的所属对象 ​ Joinpoint(连接点):目标方法可增强的位置 ​ Pointcut(切入点):实际被增强的方法 ​ Advice(通知/增强):对切入点增强的位置及方法 ​ Aspect(切面):切入点的通知的结合() ​ Proxy(代理):一个类被AOP织入增强后,会产生一个结果代理类 相关注解: 注解 描述 @Aspect 把当前类声明成切面类 @Before 把当前方法看成是前置通知 @AfterReturning 把当前方法看成是返回通知,需要方法正常返回。 @AfterThrowing 把当前方法看成是异常通知,方法参数可以拿到 @After 把当前方法看成是后置(最终)通知,,无论是否出现异常都会执行 @Around 把当前方法看成是环绕通知 @Pointcut 定义方法声明该注解添加切入点表达式,可以直接引用该方法作为表达式,相当于提取 切入点表达式: //切入点表达式：execution后小括号中寻找要增强方法的表达式 // @Before(\"execution(public void com.czxy.demo03.*.save())\") //某个包下的所有类用* // @Before(\"execution(void com.czxy.demo03.*.save())\") //访问权限可以省略 // @Before(\"execution(* com.czxy.demo03.*.save())\") //任意返回值 // @Before(\"execution(* *.*.*.*.save())\") //任意包 // @Before(\"execution(* com..*.save())\") //当前包下的任意包 // @Before(\"execution(* com..*.*())\") //任意方法名称 // @Before(\"execution(* com..*.*(*))\") //任意方法参数必须有 // @Before(\"execution(* com..*.*(..))\") //任意方法任意参数均可 // @Before(\"execution(* *..*.*(..))\") //项目中所有方法 ​ 基本使用步骤: ​ 1.导入spring aop 的相关依赖 ​ 2.声明一个切面类 添加@Aspect @Component 注解 ​ 3.在切面类中编写增强方法,并添加相关通知注解以及所需切入点 ​ 4.在配置类中添加@EnableAspectJAutoProxy 注解开启切面 注意事项: ​ 关于@Around 注解的使用 ​ 声明该注解后方法会默认有一个JoinPoint/ProceedingJoinPoint形参 ​ 将joinpoint强转为proceedingJoinPoint,并调用其pjp.proceed();方法 ​ 在该方法调用前执行的就是前置通知,之后则是后置通知 ​ 可以使用ty{}catch()finally{}做出异常通知和最终通知的效果 @Around(\"execution(public void com.czxy.demo03.OrderDao.save())\") public void myAround(JoinPoint joinPoint,ProceedingJoinPoint proceedingJoinPoint) { //获取目标对象 Object target = joinPoint.getTarget(); System.out.println(target); //获取切点方法 Signature signature = joinPoint.getSignature(); System.out.println(signature); //将joinpoint强转为proceedingJoinPoint ProceedingJoinPoint pjp = (ProceedingJoinPoint)joinPoint; try { System.out.println(\"之前？\"); pjp.proceed(); System.out.println(\"之后？\"); } catch (Throwable throwable) { System.out.println(\"异常出现啦！\"); throwable.printStackTrace(); } finally { System.out.println(\"最终执行的！\"); } } ​ 关于@Pointcut的使用 //设置公共切点，可以方便其他增强使用，这里bf方法与ar方法使用了该公共切点 @Pointcut(需要提取的切入点的表达式) private void myPointcut(){ } @Before(\"切面类.myPointcut()\") // @AfterReturning(\"myPointcut()\") public void bf() { System.out.println(\"增强\"); } 切面类示例代码 //日志切面类 @Aspect public class LogAspects { @Pointcut(\"execution(public int com.enjoy.cap10.aop.Calculator.*(..))\") public void pointCut(){}; //@before代表在目标方法执行前切入, 并指定在哪个方法前切入 @Before(\"pointCut()\") public void logStart(JoinPoint joinPoint){ System.out.println(joinPoint.getSignature().getName()+\"除法运行....参数列表是:{\"+ Arrays.asList(joinPoint.getArgs())+\"}\"); } @After(\"pointCut()\") public void logEnd(JoinPoint joinPoint){ System.out.println(joinPoint.getSignature().getName()+\"除法结束......\"); } @AfterReturning(value=\"pointCut()\",returning=\"result\") public void logReturn(Object result){ System.out.println(\"除法正常返回......运行结果是:{\"+result+\"}\"); } // @AfterThrowing(value=\"pointCut()\",throwing=\"exception\") public void logException(Exception exception){ System.out.println(\"运行异常......异常信息是:{\"+exception+\"}\"); } @Around(\"pointCut()\") public Object Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{ System.out.println(\"@Arount:执行目标方法之前...\"); Object obj = proceedingJoinPoint.proceed();//相当于开始调div地 System.out.println(\"@Arount:执行目标方法之后...\"); return obj; } } 执行顺序 ​ @Around之前 > @Before > 切入点(目标方法) > @Around之后(如抛出异常不执行) > @After > @AfterThrowing(程序抛出异常) > @AfterReturning(成功返回,如抛出异常不执行) ​ 什么是声明式事务? ​ 以方法为单位,进行事务控制,抛出异常,事务回滚 ​ 最小的执行单位为方法,决定执行成败通过是否抛出异常来判断,抛出异常即执行失败 spring使用事务 ​ 导入相关依赖: mysql mysql-connector-java 5.1.47 com.alibaba druid 1.1.10 org.springframework spring-jdbc 5.1.8.RELEASE ​ 配置类 package xyz.taoqz.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; /** * @author :almostTao * @date :Created in 2019/9/7 15:13 */ @Configuration @ComponentScan(\"xyz.taoqz\") // 开启事务 配合@Transactional注解以及事务管理器使用 @EnableTransactionManagement public class SpringConfig { /** * 配置数据源 * @return */ @Bean public DataSource dataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUsername(\"root\"); druidDataSource.setPassword(\"123\"); druidDataSource.setUrl(\"jdbc:mysql:///spring_day08_shiwu\"); druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); return druidDataSource; } /** * 实现简单的增删改查 * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ return new JdbcTemplate(dataSource); } /** * 事务管理器 * @param dataSource * @return */ @Bean public DataSourceTransactionManager txManager(DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } } ​ dao依赖注入 @Autowired private JdbcTemplate jdbcTemplate; ​ @Transactional ​ 添加在方法上,表示该方法有事务效果 ​ 添加在类上,表示该类中所有方法都有事务 自定义配置 应该实现WebMvcConfigurer接口还是继承WebMvcConfigurerAdapter类,该类是接口的一个实现类.为了解决需要单独配置其 中一项而需要实现接口中的所有方法而产生,但在spring5之后该接口中的方法定义为default,可以选择重写方法,因此推荐使用实 现WebMvcConfigurer接口+@EnableWebMvc的方式 https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-config-enable ​ FactoryBean和BeanFactory的区别 ​ FactoryBean:将java实例注入到容器中 ​ BeanFactroy:从容器中获取实例化后的Bean Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"spring/SpringBoot.html":{"url":"spring/SpringBoot.html","title":"SpringBoot","keywords":"","body":"什么是SpringBoot?项目结构:创建webapp目录,以及使用jsp热部署webjars读取配置文件数据日期格式转换静态文件mysql驱动包 8.x 修改时区使用hikari连接池设置虚拟路径什么是SpringBoot? ​ 简化了Spring项目的搭建和开发过程,可以整合其他框架,简单,快速,快变 项目结构: ​ springboot项目启动后会自动扫描与其在同一目录下的文件夹 创建webapp目录,以及使用jsp ​ 需要添加依赖 javax.servlet jstl org.apache.tomcat.embed tomcat-embed-jasper provided ​ 创建webapp目录应该与Java和resources目录同级 ​ 标记为web目录:Modules --> 点击项目下的Web,将webapp路径添加到下图 热部署 ​ 需要的依赖: org.springframework.boot spring-boot-devtools ​ properties: #开启热部署 spring.devtools.restart.enabled=true #设置重启文件目录 spring.devtools.restart.additional-paths=src/main/java #页面不加载缓存，修改即时生效 spring.thymeleaf.cache=false ​ idea需要的配置: webjars ​ WebJars可以让大家 以Jar 包的形式来使用前端的各种框架、组件。 ​ WebJars 是将客户端（浏览器）资源（JavaScript，Css等）打成 Jar 包文件，以对资源进行统一依赖管理。WebJars 的 Jar 包部署在 Maven 中央仓库上,可以让我们对前端资源也以jar包的方式进行依赖管理 ​ 通过查看mvc的自动配置类可以看到前端资源配置的虚拟路径和映射路径 ​ 引入时,在src创建与pom文件中组件名称相同的空文件夹 webjars/artifactId/version ​ 例如 : src/webjars/jquery/3.3.1 ​ 官网:https://www.webjars.org/ ​ 所需依赖: org.webjars webjars-locator-core org.webjars jquery 3.3.1 ​ 测试访问路径:http://localhost:8080/webjars/jquery/3.3.1/jquery.js ​ 对应在jsp中引用: 读取配置文件数据 ​ @propertySource : 指定配置文件 ​ @ConfigurationProperties : 指定配置文件中属性的前缀 ​ @Value(\"${配置文件中的属性}\") 配置文件 application.properties server.port=8080 user.username=zzz @Component @ConfigurationProperties(prefix = \"user\") @PropertySource(value = \"classpath:application.properties\") public class User { private String username; public String getUsername() { return username; } public void setUsername(String username) { System.out.println(\"通过set方法赋值\"); this.username = username; } @RestController @RequestMapping(\"/hello\") public class HelloController { @Autowired private User user; @Value(\"user.username\") private String username; @GetMapping(\"/user\") public User getUser(){ return user; } @GetMapping(\"/username\") public String getUserName(){ return user.getUsername(); } } 日期格式转换 ​ 前台传递后台按照指定格式接收: ​ 方式一:在bean属性上添加注解 ​ @DateTimeFormat(pattern = \"\") ​ 方式二:在application.properties文件中添加 ​ spring.mvc.date-format=yyyy-MM-dd HH:mm:ss ​ 后台返回给前台json时的data自定义格式字符串: ​ 方式一:在bean属性上添加注解 ​ @JsonFormat(pattern=\"yyyy-MM-dd HH:mm:ss\",timezone=\"GMT+8\") ​ 方式二:在application.properties文件中添加 ​ spring.jackson.time-zone=GMT+8 ​ spring.jackson.date-format=yyyy-MM-dd HH:mm:ss 静态文件 ​ 阅读源码可以看到WebMvcAutoConfiguration 类中addResourceHandlers方法 去读ResourceProperties类中的属性 其中将默认的值赋值给了它,共有四个默认值,其优先级跟下图声明顺序一样 这几个文件夹都是在resources文件夹下的 classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ mvc添加该路径方便我们创建webapp目录 还可以添加webapp,在idea中添加该目录需要在project settings -- > models 选中项目的web 有两栏添加第一个提那家web.xml路径,第二个添加webapp路径,如果jsp访问不到 如下配置,别忘记添加依赖 自定义方式: ​ 使用配置文件: ​ 配置文件第一行代表添加一个静态资源文件夹路径,如果没有把默认的配置加上会覆盖默认的设置 ​ 同时使用自定义和默认的,用英文逗号隔开即可,前面的优先级高 ​ 使用java配置类: ​ 实现WebMvcConfigurer接口重写addResourceHandlers,可以达到相同效果 ​ 映射resources下的文件夹或文件以classpath:开头 classpath:/ 代表resources根目录 ​ 映射磁盘下的文件以file:开头 ,其中盘符写绝对路径,盘符后的 冒号 可写可不写 ​ 例如 : file:D:/temp/upload/ ​ file:D/temp/upload/ ​ 使用webapp目录,把js文件放在其根目录下,在webapp根目录和WEB-INF的jsp都可以从所在包直接引用 ​ 注意事项:这两种方式都会覆盖其默认配置,也就是说只配置了自己想要的路径,其默认的便会失效 ​ 关于前端引入可以在webjars中查看 ​ 参考博客 ​ https://www.jianshu.com/p/d40ee98b84b5 ​ https://www.cnblogs.com/sxdcgaq8080/p/7833400.html ​ 江南一点雨 mysql驱动包 8.x 修改时区 spring.datasource.url=jdbc:mysql://localhost:3306/study?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC 使用hikari连接池 导入该启动器,如果不配置其他连接池默认使用hikariCP作为连接池 org.springframework.boot spring-boot-starter-jdbc application.properties 关于该连接池的配置 #数据源配置 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/数据库?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC spring.datasource.username=账号 spring.datasource.password=密码 #连接池配置 #最小空闲连接数 spring.datasource.hikari.minimum-idle=5 #池中最大连接数,包括闲置和使用的连接 spring.datasource.hikari.maximum-pool-size=15 #自动提交从池中返回的连接 spring.datasource.hikari.auto-commit=true #连接允许在池中闲置的最长时间 spring.datasource.hikari.idle-timeout=30000 #连接池的用户定义名称，主要出现在日志记录 spring.datasource.hikari.pool-name=hikariCP #此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟 spring.datasource.hikari.max-lifetime=1800000 # 数据库连接超时时间,默认30秒，即30000 spring.datasource.hikari.connection-timeout=30000 spring.datasource.hikari.connection-test-query=SELECT 1 #打印sql日志 #mybatis.mapper-locations=classpath:mapper/*.xml #将数据转换为指定格式+时区返回 #spring.jackson.time-zone=GMT+8 #spring.jackson.date-format=yyyy-MM-dd #将接收的数据以指定格式存储 #spring.mvc.date-format=yyyy-MM-dd #开启热部署 spring.devtools.restart.enabled=true #设置重启文件目录 spring.devtools.restart.additional-paths=src/main/java #页面热部署 #spring.thymeleaf.cache=false 设置虚拟路径 添加配置类 @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { // 前面是访问路径 后面是文件实际存在的路径 registry.addResourceHandler(\"/z/**\").addResourceLocations(\"file:F://code/\"); } } 或者在配置文件中添加 #url访问的请求路径 spring.mvc.static-path-pattern=/zz/** #真实路径 spring.resources.static-locations=file:F://code/ Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-19 18:54:04 "},"spring/SpringMVC.html":{"url":"spring/SpringMVC.html","title":"SpringMVC","keywords":"","body":"1.SpringMVC是什么:2.视图解析器:3.参数绑定:3.1.注意事项(重要)3.2.@RequestParam3.3.数组绑定3.4.集合类型:4.多路径映射/请求方法限定/窄化路径:4.1多路径映射:4.2请求方法限定(也是该注解的一个参数)4.3窄化路径:5. @PathVaraible注解的使用:6.Controller方法返回值以及跳转方式:7.异常处理器:8.图片上传:9.JSON数据交互:10.拦截器:11.序列化12.@RequestBody注意事项1.SpringMVC是什么: ​ Spring web mvc是表现层的框架,它是Spring框架的一部分 ​ 执行流程:客户端发送请求,springMVC的前端控制器DispatcherServlet接收并分配请求到对应的Controller执行对应的 方法,方法会返回视图,DispatherServlet解析视图,返回客户端进行渲染 2.视图解析器: ​ 视图:简单理解为浏览器向用户展示的界面 ​ 为什么使用? ​ 浏览器想要展示页面需要有一个请求的地址,拿到路径,但路径通常会在一个文件夹中,而文件夹可能会有多层,所 以SpringMVC中的视图解析器,可以帮我们减少一些重复的代码,把绝对路径可以写成我们的逻辑路径 ​ 需要在配置类中添加:用户在返回视图时,会经过该解析器,帮我们拼接字符串 ​ 配置类继承WebMvcConfigurerAdapter,注意spring5后一律推荐使用实现WebMvcConfigurer接口 @Bean public InternalResourceViewResolver viewResolver(){ InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); // 这是视图的前缀 viewResolver.setPrefix(\"/\"); // 这是视图的后缀 viewResolver.setSuffix(\".jsp\"); return viewResolver; } // properties 方式配置 spring.mvc.view.prefix= spring.mvc.view.suffix= 3.参数绑定: 3.1.注意事项(重要) ​ 其中前台的name必须和属性值名称一致,使用set方法赋值 ​ 其中方法的参数类型如果是基本数据类型推荐使用包装类型,因为基本数据类型不能为null,如果请求中没有改参数,会抛异常 3.2.@RequestParam ​ 作用:当请求参数的名称与方法参数名称不一致时,可以使用该注解标记对应关系 ​ 该注解中的参数: ​ name = \"对应的在前台的name名称\":与方法中的参数名对应 ​ required:表示是否必须有该参数有两个值,,默认为false ​ defaultValue:表示如果前台没有传递该参数时的默认值 ​ 引用数据类型的映射(POJO): ​ 在方法参数声明一个对象变量,请求时如果name和对象中的属性值一致,会自动注入到该对象中 ​ 简单说就是在对象中又有其他对象: ​ 在前台传递参数时,参数名称为该对象的名称再点属性 ​ 例子: 两个javaBean @Data public class CartItem { private Item item; private Integer number; private Double price; } @Data public class Item { private String name; private Double price; } 前台要提交的表单 Controller层处理,及控制台输出 3.3.数组绑定 ​ 前台表单传递一个相同name的一组数据,在方法的参数中写一个数组类型进行赋值,其中数组的名称 也要和前台name的名称相同 ​ 示例: // 数据:[\"1\",\"2\"] @PostMapping(\"/deleteMore\") public ResponseEntity deleteMore(@RequestBody String[] ids){} ​ // 请求路径 http://localhost:8080/emp/demo?arr=1&arr=2 @GetMapping(\"/demo\") public void fun(String[] arr){System.out.println(Arrays.toString(arr));} 3.4.集合类型: ​ 如果在方法参数中直接写集合类型是赋值不了的,需要使用数组或者在Bean中添加一个集合属性进行赋 值,如果需要给指定索引赋值,在name中指定索引即可 ​ 例子:前台传递表单方式 在上面的基础之上CartItem类中添加了一个集合属性 ​ ​ 前台数据传递的方式以及后台打印结果 4.多路径映射/请求方法限定/窄化路径: 4.1多路径映射: ​ @RequestMapping:请求路径映射 ​ 常用的参数: ​ value:\"指定访问的路径\"可以多个{\"路径1\",\"路径2\"} ​ headers :指定请求头中的参数 **params** :你可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。也就是 请求时的不同参数,调用的方法也会不同 @RequestMapping(value = \"/hello.action\",params = {\"id=10\"}) public String fun(String id){ System.out.println(id); return \"index\"; } @RequestMapping(value = \"/hello.action\",params = {\"id=20\"}) public String fun2(String id){ System.out.println(id); return \"index\"; } 4.2请求方法限定(也是该注解的一个参数) ​ method:指定请求的类型,也可以是数组 ​ method = {RequestMethod.GET,RequestMethod.POST} 4.3窄化路径: ​ 在类上添加相当于设置请求的前缀 ​ 在方法上添加,设置方法对应的请求路径 5. @PathVaraible注解的使用: ​ @RequestMapping 注解可以同 @PathVaraible 注解一起使用，用来处理动态的 URI ​ 将 @PathVaraible注解写到方法的参数前,对应方法中的参数,可以将URL中的对应的位置的值赋值到变量中,还可以使用正则表达式 @RequestMapping(value = \"/fetch/{id}.action\", method = RequestMethod.GET) public String getDynamicUriValue(HttpServletRequest request, @PathVariable(\"id\") String id) { System.out.println(\"ID is \" + id); return \"index\"; } ​ 如果设置参数不是必须的,需要有对应的路径映射 // required 设置参数为非必须项 @GetMapping({\"/path/{id}\",\"/path\"}) public void fun(@PathVariable(required = false) Integer id){ System.out.println(id); } 6.Controller方法返回值以及跳转方式: ​ 返回值为ModelAndView:创建ModelAndView对象,或者在方法形参中给出,可以在构造方法中直接给(返回的页面,存在域中的名称,存在域中的数据),或者分别使用addObject(name,value),setViewName(地址),会经过视图解析器 ​ 返回值为String:在方法的形参上添加Model,使用addAttribute()存储数据,返回值写地址 ​ 还可以使用 return \"redirect:tao.jsp\"; ​ return \"forward:tao.jsp\"; ​ 这两种方法存储的域都是request(想要存储到别的域中,可以使用原生) ​ 返回值为void使用方式和BaseServlet时一样,并且不会经过SpringMVC中的视图解析器 ​ 想要重定向或请求转发,在字符串中分别拼接redirect:和forward:,MVC会帮我们解析返回值,并在底层调用不同的方法 7.异常处理器: ​ SpringMVC异常处理机制: ​ 系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由 异常处理器进行异常处理。springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。 具体代码实现: ​ 创建一个自己的异常类,继承Exception ​ 定义统一异常处理器类:实现HandlerExceptionResolver接口并交由spring管理,重写方法 ​ @Component public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) { //统一处理异常 CustomException customException = null; // 如果是自定义异常直接类型转换赋值,并显示错误信息 // 如果不是创建自定义异常,提示未知错误 if(ex instanceof CustomException){ customException = (CustomException) ex; } else { customException = new CustomException(\"系统错误，请与系统管理 员联系！\"); } //设置数据 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"message\", customException.getMessage()); modelAndView.setViewName(\"WEB-INF/error\"); return modelAndView; } } 8.图片上传: ​ 在写具体代码时,先了解一下表单的一个属性 ​ enctype:该属性有三个属性值 ​ application/x-www-form-urlencoded:默认值,请求方式为get时,会将表单中的数据以键值对的方式加到url后面中间用?分隔,为post时,浏览器把form数据封装到http body中，然后发送到服务器 ​ text/plain：表单以纯文本形式进行编码 ​ multipart/form-data：当上传的含有非文本数据时,设置为该属性值,将表单数据变成二进制数据进行上传,这时使用request是获取不到表单响应的值的 ​ 在了解这点后,看具体上传图片的代码: ​ 在配置类中添加文件上传解析器: ​ 需要导入commons-io和commons-fileupload依赖 ​ @Bean public CommonsMultipartResolver multipartResolver[1] (){ CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(); // 设置所有的上传文件的总大小 10M multipartResolver.setMaxInMemorySize(10*1024*1024); // 设置单个文件上传的大小 4M multipartResolver.setMaxUploadSize(4*1024*1024); multipartResolver.setDefaultEncoding(\"utf-8\"); return multipartResolver; } 注解方式: spring.servlet.multipart.max-file-size= 文件大小 spring.servlet.multipart.max-request-size= 请求大小 Controller中写方法接受表单数据,需要设置一个参数MultipartFile表示文件上传对象,其他参数可以正常获取 ​ 该类常用方法: 方法名 描述 String getOriginalFilename() 获得原始上传文件名 transferTo(File file) 将上传文件转换到一个指定的文件中 String getContentType() 获取文件MIME类型，如image/pjpeg、text/plain等 String getName() 获取表单中文件组件的名字 ​ 直接写一个数组(没试过) ​ 如果是多文件上传,可以写一个VO类,里面添加一个成员变量List MultipartFiles 9.JSON数据交互: ​ 需要导入的依赖: com.fasterxml.jackson.core jackson-databind 2.9.7 ​ 前端发送json格式的数据,如果对应的Controller方法中的对象或者变量名相同可以直接封装赋值 ​ 后台想要把数据返回到前台页面显示,需要在配置类上添加@EnableWebMvc开启配置 ​ 有两种方式: ​ 1.在类上添加@Controller在方法返回值前加@ResponseBody ​ 2.直接在类上添加@RestController,因为该注解包含上面两个注解 10.拦截器: ​ 自定义拦截器需要实现HandlerInterceptor接口重写其方法 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 afterCompletion方法是在JSP执行后执行 request或者response不能再跳转页面了 使用配置类配置拦截器: ​ 配置类继承WebMvcConfigurerAdapter ​ 重写方法: @Override public void addInterceptors(InterceptorRegistry registry) { // 添加拦截器 InterceptorRegistration interceptorRegistration1 = registry.addInterceptor(myInterceptor1); InterceptorRegistration interceptorRegistration2 = registry.addInterceptor(myInterceptor2); interceptorRegistration1.addPathPatterns(\"/**\"); interceptorRegistration2.addPathPatterns(\"/**\"); } ​ 多个拦截器执行流程: ​ 会先按顺序执行preHandle方法,在Controller方法执行完成并且在jsp视图执行前反顺序执行postHandle方法,然后 在返回视图,在返回视图完成后在反顺序执行afterCompletion方法 11.序列化 @JsonInclude注解的使用 有时前台获取数据时,数据中有为null或者\"\"空字符串的字段,为了解决不必要的麻烦,可以在实体类的字段上添加该注解 @JsonInclude(JsonInclude.Include.NON_NULL) // 字段的值为空时跳过序列化 @JsonInclude(JsonInclude.Include.NON_EMPTY)// 包含上面注解,同时字段值为空字符时跳过序列化 12.@RequestBody 配合post请求使用 该注解主要作用用于解析请求体中的数据 如果不添加该注解,那么获取形参的数据为null // 不添加注解 @PostMapping public void fun(String student){ System.out.println(student); } // 请求体中的数据 {\"sname\":\"taoqz\"} // 控制台输出 console : null // 添加注解 @PostMapping public void fun(@RequestBody String student){ System.out.println(student); } // 请求体中的数据 {\"sname\":\"taoqz\"} // 控制台输出 会将数据当做字符串解析赋值 console : {\"sname\":\"taoqz\"} ​ 传递对象 ​ 只需将参数设置为需要的对象,mvc会将请求中的数据自动封装到对象中,前提是请求体中的字段与实体类中的属性名称一致 @PostMapping public void fun(@RequestBody Student student){ System.out.println(student); } // 请求体中数据 { \"sname\":\"taoqz\", \"address\":\"北京\" } // 控制台输出 Student(sid=null, sname=taoqz, address=北京, teachers=null) ​ 结合@RequestParam使用 ​ @RequestBody注解只能使用一次,如果有特殊需要可以结合@RequestParam使用 @PostMapping(\"/test\") public void add(@RequestBody Student student, @RequestParam(\"arr\") String[] arr){ System.out.println(student); System.out.println(Arrays.toString(arr)); } // 请求路径 mvc会将路径中相同名称的参数封装到数组中 http://localhost:8080/test/zz?arr=1&arr=2 // 请求体 自动封装到对象中 { \"sname\": \"zs\", \"address\": \"江苏省南京市\" } // 控制台输出 student: Student(sid=null, sname=zs, address=江苏省南京市, teachers=null) arr : [1, 2] 注意事项 ​ 请求: http://localhost:8090/user?ids=1&ids=2 ​ 接收数组参数 @DeleteMapping public void fun(Integer[] ids){ System.out.println(Arrays.toString(ids)); } ​ 将参数转为集合 // 也可以使用请求: http://localhost:8090/user?ids=1,2 @DeleteMapping public void fun(@RequestParam List ids){ ids.forEach(System.out::println); } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"microservice/微服务概述.html":{"url":"microservice/微服务概述.html","title":"微服务阶段","keywords":"","body":"SpringCloudSpring Cloud Alibaba介绍主要功能组件maven坐标微服务的特点优点缺点SpringCloud SpringCloud是微服务的一种实现,属于Spring旗下的项目之一,集成了很多其他优秀的流行框架,由于其团队的可靠性以及功能的强大,SpringCloud成为最火的微服务的实现方式 ​ 其中SpringCloud又有两种解决方案 ​ Spring Cloud Netflix ​ 该项目进入维护期,意味着没有新功能的添加,只进行bug修复 ​ Spring Cloud Alibaba Spring Cloud Alibaba 介绍 ​ Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 主要功能 服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 组件 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 maven坐标 com.alibaba.cloud spring-cloud-alibaba-dependencies 2.1.0.RELEASE pom import 微服务的特点 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 独立：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 Docker部署服务 简单理解就是之前的每一个单体应用都可以称之为服务,举个例子,一个刚上线的小型商城项目,起初的用户量访问量很少,使用单体架构完全可以应对,但一旦用户访问量增多时,服务器或者数据库承受不了那么多的访问量,服务器会出现宕机,为了解决很多类似的情况,便有了微服务这种思想,将项目改造成微服务架构,针对访问量较多的模块可以让其占用更大的资源 优点 解决了复杂问题,可以将一个庞大的单体应用程序拆解成一套服务,虽然功能数量不变,但应用程序已经被拆解成可管理的块或者服务,每个服务提供相对单一的功能,更容易理解和维护 每个服务可以进行单独部署,并且可以根据该服务的所需来调配资源,避免资源浪费 缺点 使项目整体变得更加复杂,服务间的通信也变得麻烦 由于服务有自己独立的数据库,需要解决数据间的同步 测试会变得相对麻烦,一个服务或者模块会依赖其他的模块,进行相互调用,所以必须还要启动其依赖的服务 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 13:30:10 "},"microservice/netflix/Zuul.html":{"url":"microservice/netflix/Zuul.html","title":"Zuul","keywords":"","body":"Zuul什么是Zuul为什么使用依赖注解配置路径映射规则过滤器跨域其他Zuul 什么是Zuul Zuul是从设备和网站到Netflix流应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul旨在实现动态路由，监视，弹性和安全性。它还可以根据需要将请求路由到多个Amazon Auto Scaling组。 为什么使用 Netflix API流量的数量和多样性有时会导致生产问题迅速出现而没有警告。我们需要一个允许我们快速改变行为以对这些情况做出反应的系统。 Zuul使用了各种不同类型的过滤器，这使我们能够快速灵活地将功能应用于边缘服务。这些过滤器帮助我们执行以下功能： 身份验证和安全性-识别每个资源的身份验证要求，并拒绝不满足要求的请求。 见解和监控-在边缘跟踪有意义的数据和统计信息，以便为我们提供准确的生产视图。 动态路由-根据需要将请求动态路由到不同的后端群集。 压力测试-逐渐增加到群集的流量以评估性能。 减载-为每种类型的请求分配容量，并丢弃超出限制的请求。 静态响应处理-直接在边缘构建一些响应，而不是将其转发到内部集群 多区域弹性-在AWS区域之间路由请求，以多样化我们的ELB使用并将我们的优势拉近我们的成员 依赖 org.springframework.cloud spring-cloud-starter-netflix-zuul org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import 注解 @EnableZuulProxy // 开启网关功能 @EnableEurekaClient // 开启eureka客户端服务 配置 # 将服务注册到Eureka,并且拉取其他服务 eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:8083/eureka fetch-registry: true # 是否拉取其他服务,默认true instance: prefer-ip-address: true ip-address: 127.0.0.1 路径映射规则 指定url访问 zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 # 访问/user-service/**时会请求 http://127.0.0.1:8081/ url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 指定服务名 zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 # 使用Eureka,通过服务名访问,并且会利用Ribbon的负载均衡 service-id: user-service # 指定服务名称 简化 路由名称往往和服务名一样,因此可以简化成如下,或者直接选择不配置,也会默认根据此规则发送请求,路由名称对应服务名称 zuul: prefix: /api # 添加路由前缀,可选项 routes: user-service: /user-service/** # 这里是映射路径 过滤器 ​ 和之前在servlet时学的过滤器功能类似 ​ 自定义过滤器 ​ 自定义需要实现类ZuulFilter,以下是其最重要的四个方法 public abstract class ZuulFilter implements IZuulFilter{ abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter } shouldFilter：返回一个Boolean`值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 示例 import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import com.netflix.zuul.exception.ZuulException; import io.jsonwebtoken.Claims; import org.springframework.stereotype.Component; import xyz.taoqz.utils.JWTUtil; import javax.servlet.http.HttpServletRequest; /** * 鉴权 */ @Component public class JWTFilter extends ZuulFilter { @Override public String filterType() { return \"pre\"; } @Override public int filterOrder() { return 1; } @Override public boolean shouldFilter() { return true; } /** * 编写权限过滤的核心业务： * 主要任务：确认是否放行 * 根据URL确认是否放行 * 有些URL是需要登陆之后才能访问，有些URL不需要登陆就可以访问 * 如果需要登陆的URL，需要获取token，并且解析token，成功了，就放行，不成功，就拦截 */ @Override public Object run() throws ZuulException { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); if (request.getRequestURI().contains(\"/login\")){ return null; } String token = request.getHeader(\"authorization\"); // 结合了JWT使用 if (token != null && !(\"\").equals(token.trim())){ Claims example0102 = JWTUtil.parseToken(token.trim(), \"example0102\"); if (example0102 != null){ ctx.addZuulRequestHeader(\"authorization\",token); return null; } } // 拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); ctx.setResponseBody(\"{'msg':'校验失败'}\"); ctx.getResponse().setContentType(\"text/html;charset=utf-8\");// 不设置的话，中文乱码 return null; } } 跨域 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; /** 全局跨域配置类 */ @Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //放行哪些原始域 config.addAllowedOrigin(\"*\"); //是否发送Cookie信息 config.setAllowCredentials(true); //放行哪些原始域(请求方式) config.addAllowedMethod(\"OPTIONS\"); config.addAllowedMethod(\"HEAD\"); config.addAllowedMethod(\"GET\"); //get config.addAllowedMethod(\"PUT\"); //put config.addAllowedMethod(\"POST\"); //post config.addAllowedMethod(\"DELETE\"); //delete config.addAllowedMethod(\"PATCH\"); config.addAllowedHeader(\"*\"); //2.添加映射路径 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\"/**\", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); } } zuul: sensitive-headers: Access-Control-Allow-Origin ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken 其他 ​ 解決请求头丢失问题,zuul会默认过滤掉部分请求头 zuul: sensitive-headers: Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-01-15 13:53:08 "},"microservice/netflix/eureka/eureka.html":{"url":"microservice/netflix/eureka/eureka.html","title":"Eureka","keywords":"","body":"Eureka作用为什么要使用入门案例服务端客户端负载均衡高可用EurekaEureka ​ 服务发现与注册中心 ​ 由Netflix开发的服务发现框架,本身是一个基于REST的服务 ​ 主要组件 ​ Eureka Serve:服务端,提供服务注册和发现的功能 ​ Eureka Client:客户端,与Eureka Serve的交互,客户端启动后会自动注册到其启动时配置的地址的服务端 作用 ​ 对服务进行统一管理 ​ 提供服务的注册于发现,将所有的服务进行统一管理,不需要开发人员手动维护,需要使用哪个服务,直接在服务中心中获取就行 ​ 实现对服务的状态管理,如果某个服务下线,会有通知,专业术语是心跳,服务提供者会定期通过http方式向Eureka刷新自身的状态,同时Eureka会将所有提供者的地址发送给消费者,并定期更新 ​ 结合其他技术(Ribbon)实现了负载均衡 为什么要使用 ​ 微服务的基础还是服务,将一个单体应用拆分为微服务架构的应用,其中服务之间需要相互依赖,相互调用,但是服务被部署在不同的服务器上,如果服务一旦过多,那么会出现访问的地址(接口)难以进行管理,如果有集群,还需要自行实现负载均衡,并且其中有某个服务停掉也不会接到通知,为了解决等等之类的问题,便诞生了服务发现与注册中心 入门案例 ​ 分为服务端和客户端,引入Eureka都需要三步,添加依赖,配置,注解 ​ 首先都需要引入SpringCloud的依赖 ​ 该案例使用的SpringCloud的Hoxton.RELEASE版本,需要结合springboot2.2.x使用 org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import spring-milestones Spring Milestones https://repo.spring.io/milestone false 服务端 依赖 org.springframework.cloud spring-cloud-starter-netflix-eureka-server 配置 server: port: 8080 # 端口 spring: application: name: eureka-server # 应用名称，会在Eureka中显示 eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:${server.port}/eureka 注解 ​ 在启动类上添加 @EnableEurekaServer // 声明这个应用是一个EurekaServer 访问:http://127.0.0.1:8080 客户端 依赖 org.springframework.cloud spring-cloud-starter-netflix-eureka-client 配置 server: port: 8081 spring: datasource: url: jdbc:mysql://localhost:3306/mydb?useUnicode=true&characterEncoding=utf8 username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: user-service # 应用名称 eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:8080/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称(也就是根据主机名还是ip访问) ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注解 // 两者选其一 @EnableEurekaClient // 开启EurekaClient功能 @EnableDiscoveryClient // 开启Eureka客户端 客户端又分为生产者和消费者,生产者也就是服务提供者,需要将自身注册到服务中心即可,而消费者需要到服务中心调用对应的服务,服务中心存储的相当于服务名称=多个服务地址的键值对 使用DiscoveryClient类 // 必须导入org.springframework.cloud.client.discovery.DiscoveryClient @Autowired private DiscoveryClient discoveryClient; public void demo(){ // 根据服务名称,拿到所有已注册的服务实例,因为可能会有集群所以是个集合 List instances = discoveryClient.getInstances(\"user-service\"); // 拿到其中一个实例 ServiceInstance serviceInstance = instances.get(0); // host主机地址 String host = serviceInstance.getHost(); // port端口号 int port = serviceInstance.getPort(); String url = \"http://\"+host+\":\"+port+\"controller地址及参数\"; } 结合RestTemplate使用 @Configuration public class RestTemplateConfig { @Bean public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(); // 解决乱码 restTemplate.getMessageConverters().add(1,new StringHttpMessageConverter(Charset.forName(\"UTF-8\"))); return restTemplate; } } #修改Eureka服务实例的显示 eureka: instance: instance-id: ${spring.application.name}:${server.port} 负载均衡 ​ 首先负载均衡是在集群的基础上,集群就是将相同功能的代码部署到不同的服务器,而负载均衡则是将流量平均分发到集群的不同服务上,同时做集群的目的也就是为了负载均衡,其中负载均衡又有很多策略,也就是实现负载均衡的算法 ​ Eureka中集成了Ribbon负载均衡器,使用时只需要简单的配置即可 ​ 使用 ​ 在RestTemplate的配置方法上添加@LoadBalanced注解： ​ 添加该注解后,才可以使用服务名的方式访问 @Configuration public class RestTemplateConfig { @Bean // 开启负载均衡 @LoadBalanced public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(); // 解决乱码 restTemplate.getMessageConverters().add(1,new StringHttpMessageConverter(Charset.forName(\"UTF-8\"))); return restTemplate; } } ​ 修改调用方式,从host+port改为直接调用服务名称的方式 http://服务名称/controller方法的映射地址 String url = \"http://user-service/user/\"+id; ​ 默认使用的是轮询机制,注入RibbonLoadBalanceClient类进行测试 @RunWith(SpringRunner.class) @SpringBootTest(classes = 启动类.class) public class LoadBalanceTest { @Autowired RibbonLoadBalancerClient client; @Test public void test(){ for (int i = 0; i ​ 修改负载均衡的策略 ​ 查看IRule接口的实现类,可以找到其他实现负载均衡的策略 ​ 在客户端添加配置 # 根 user-service: # 服务名 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #策略 高可用Eureka 将多个EurekaServer相互注册为服务 启动多个EureakServe服务,进行相互注册,只需要将注册地址的ip互换 server: port: 10086 # 端口 spring: application: name: eureka-server # 应用名称，会在Eureka中显示 eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 客户端注册到Eureka服务集群 eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 EurekaServer集群只需注册在一台上即可共享 defaultZone: http://127.0.0.1:10086/eureka 服务续约 eureka: instance: lease-expiration-duration-in-seconds: 90 #超过90秒默认该服务宕机 lease-renewal-interval-in-seconds: 30 #每30秒发送一次心跳 当服务消费者启动时，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： eureka: client: registry-fetch-interval-seconds: 5 失效剔除和自我保护 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不便，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 在eureka的yml文件中配置 eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 重试机制 ​ CAP原则：CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得 Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能 user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖,测试 org.springframework.retry spring-retry Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-10 16:17:31 "},"microservice/netflix/Hystrix.html":{"url":"microservice/netflix/Hystrix.html","title":"Hystrix","keywords":"","body":"Hystrix使用环境依赖注解逻辑代码配置Hystrix ​ 熔断,在分布式系统中,高并发的环境下服务可能因为压力会出现宕机,而其他的服务可能会依赖该服务,并且导致级联的失败,但是在生产环境中应该避免让用户看到错误的情况,所以可以使用熔断来解决相关问题 ​ 类似生活中的保险丝,当出现漏电等情况,会将保险丝熔断,避免出现火灾 使用 ​ 在服务调用方进行操作 环境 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import spring-milestones Spring Milestones https://repo.spring.io/milestone false 依赖 org.springframework.cloud spring-cloud-starter-netflix-hystrix 注解 // 在启动类上添加 @EnableHystrix // 开启Hystrix熔断 逻辑代码 // 在需要熔断的方法上添加注解并指定熔断的回调函数 @HystrixCommand(fallbackMethod = \"queryUserByIdFallback\") public User queryUserById(Long id) { String url = \"http://user-service-tao/user/\" + id; User user = restTemplate.getForObject(url, User.class); return user; } // 熔断后的回调函数 参数及返回值一致 public User queryUserByIdFallback(Long id){ User user = new User(); user.setId(id); user.setName(\"用户信息查询出现异常！\"); return user; } 配置 ​ 其默认的触发熔断的时间为1s,所以当结合重试使用时,需要将熔断的时间设置的比重试的时间长一些,不然重试就没有了其意义 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-10 10:39:30 "},"microservice/netflix/Feign.html":{"url":"microservice/netflix/Feign.html","title":"Feign","keywords":"","body":"Feign入门使用依赖注解配置逻辑代码请求压缩Feign ​ 简化远程调用代码,支持SpringMVC注解,不需要拼接url地址,同时整合了负载均衡Ribbon以及服务熔断(Hystrix) 入门使用 服务调用者 依赖 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE org.springframework.cloud spring-cloud-starter-openfeign org.springframework.cloud spring-cloud-dependencies Hoxton.RELEASE pom import spring-milestones Spring Milestones https://repo.spring.io/milestone false 注解 // 启动类上添加 @EnableFeignClients // 开启Feign功能 配置 ​ 虽然Feign集成了Hystrix熔断,但默认是关闭的 feign: hystrix: enabled: true # 开启Feign的熔断功能 ​ 同样支持对Ribbon负载均衡的配置 #服务名 如果不写服务名是全局配置 ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 逻辑代码 // 创建接口 添加访问的服务名称以及熔断时进行处理的class类(接口的实现类) @FeignClient(value = \"user-service-tao\",fallback = UserFeignClientFallback.class) public interface UserFeignClient { @GetMapping(\"/user/{id}\") User queryUserById(@PathVariable(\"id\") Long id); } // 实现Feign的接口,重写回调函数 @Component public class UserFeignClientFallback implements UserFeignClient{ @Override public User queryUserById(Long id) { User user = new User(); user.setId(id); user.setName(\"用户查询出现异常！\"); return user; } } // 注入后接口并调用 @Autowired private UserFeignClient userFeignClient; public User queryUserById(Long id){ User user = userFeignClient.queryUserById(id); return user; } 请求压缩 ​ Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-12 08:19:22 "},"httptool/HttpClient.html":{"url":"httptool/HttpClient.html","title":"HttpClient","keywords":"","body":"HttpClient什么是HttpClient入门案例发起Get请求带参数的Get请求发起POST请求带参数POST请求SpringBoot整合HttpClientHttpClient 什么是HttpClient HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 特点： HttpClient别名：HttpComponents HttpClient可以发送get、post、put、delete、...等请求 入门案例 导入maven坐标 org.apache.httpcomponents httpclient 4.4 发起Get请求 1创建一个客户端 CloseableHttpClient 2创建一个get方法请求实例 HttpGet 3发送请求 execute 4获取响应的头信息 5获取响应的主题内容 6关闭响应对象 使用HttpClient发起Get请求的案例代码： public class DoGET { public static void main(String[] args) throws Exception { // 创建Httpclient对象,相当于打开了浏览器 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建HttpGet请求，相当于在浏览器输入地址 HttpGet httpGet = new HttpGet(\"http://www.baidu.com/\"); CloseableHttpResponse response = null; try { // 执行请求，相当于敲完地址后按下回车。获取响应 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应，获取数据 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { // 关闭资源 response.close(); } // 关闭浏览器 httpclient.close(); } } } 带参数的Get请求 1创建一个客户端 CloseableHttpClient 2 通过URIBuilder传递参数 3创建一个get方法请求实例 HttpGet 4发送请求 execute 5获取响应的头信息 6获取响应的主题内容 7关闭响应对象 访问网站的爬虫协议： public class DoGETParam { public static void main(String[] args) throws Exception { // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建URI对象，并且设置请求参数 URI uri = new URIBuilder(\"http://www.baidu.com/s\").setParameter(\"wd\", \"java\").build(); // 创建http GET请求 HttpGet httpGet = new HttpGet(uri); // HttpGet get = new HttpGet(\"http://www.baidu.com/s?wd=java\"); CloseableHttpResponse response = null; try { // 执行请求 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应数据 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { response.close(); } httpclient.close(); } } } 发起POST请求 /* * 演示：使用HttpClient发起POST请求 */ public class DoPOST { public static void main(String[] args) throws Exception { // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建http POST请求 HttpPost httpPost = new HttpPost(\"http://www.oschina.net/\"); // 把自己伪装成浏览器。否则开源中国会拦截访问 httpPost.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"); CloseableHttpResponse response = null; try { // 执行请求 response = httpclient.execute(httpPost); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应数据 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { response.close(); } // 关闭浏览器 httpclient.close(); } } } 带参数POST请求 /* * 演示：使用HttpClient发起带有参数的POST请求 */ public class DoPOSTParam { public static void main(String[] args) throws Exception { // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建http POST请求，访问开源中国 HttpPost httpPost = new HttpPost(\"http://www.oschina.net/search\"); // 根据开源中国的请求需要，设置post请求参数 List parameters = new ArrayList(0); parameters.add(new BasicNameValuePair(\"scope\", \"project\")); parameters.add(new BasicNameValuePair(\"q\", \"java\")); parameters.add(new BasicNameValuePair(\"fromerr\", \"8bDnUWwC\")); // 构造一个form表单式的实体 UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(parameters); // 将请求实体设置到httpPost对象中 httpPost.setEntity(formEntity); CloseableHttpResponse response = null; try { // 执行请求 response = httpclient.execute(httpPost); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 解析响应体 String content = EntityUtils.toString(response.getEntity(), \"UTF-8\"); System.out.println(content); } } finally { if (response != null) { response.close(); } // 关闭浏览器 httpclient.close(); } } } SpringBoot整合HttpClient SpringBoot官方并没有对HttpClient的启动器。所以我们需要自己完成配置，还好，我们刚才在测试案例中已经写过了。 不过，SpringBoot虽然没有提供启动器，但是却提供了一个统一的对Restful服务进行调用的模板类：RestTemplate，底层可以使用HttpClient来实现。有了这个我们就无需自己定义APIService了。 1、导入maven坐标 org.apache.httpcomponents httpclient 2、在application.properties添加如下配置: #The config for HttpClient http.maxTotal=300 http.defaultMaxPerRoute=50 http.connectTimeout=1000 http.connectionRequestTimeout=500 http.socketTimeout=5000 http.staleConnectionCheckEnabled=true 3、 创建HttpClientConfig类--类似util 在类中编写代码 /** * HttpClient的配置类 * */ @Configuration @ConfigurationProperties(prefix = \"http\", ignoreUnknownFields = true) public class HttpClientConfig { private Integer maxTotal;// 最大连接 private Integer defaultMaxPerRoute;// 每个host的最大连接 private Integer connectTimeout;// 连接超时时间 private Integer connectionRequestTimeout;// 请求超时时间 private Integer socketTimeout;// 响应超时时间 /** * HttpClient连接池 * @return */ @Bean public HttpClientConnectionManager httpClientConnectionManager() { PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(maxTotal); connectionManager.setDefaultMaxPerRoute(defaultMaxPerRoute); return connectionManager; } /** * 注册RequestConfig * @return */ @Bean public RequestConfig requestConfig() { return RequestConfig.custom().setConnectTimeout(connectTimeout) .setConnectionRequestTimeout(connectionRequestTimeout).setSocketTimeout(socketTimeout) .build(); } /** * 注册HttpClient * @param manager * @param config * @return */ @Bean public HttpClient httpClient(HttpClientConnectionManager manager, RequestConfig config) { return HttpClientBuilder.create().setConnectionManager(manager).setDefaultRequestConfig(config) .build(); } /** * 使用连接池管理连接 * @param httpClient * @return */ @Bean public ClientHttpRequestFactory requestFactory(HttpClient httpClient) { return new HttpComponentsClientHttpRequestFactory(httpClient); } /** * 使用HttpClient来初始化一个RestTemplate * @param requestFactory * @return */ @Bean public RestTemplate restTemplate(ClientHttpRequestFactory requestFactory) { RestTemplate template = new RestTemplate(requestFactory); List> list = template.getMessageConverters(); for (HttpMessageConverter mc : list) { if (mc instanceof StringHttpMessageConverter) { ((StringHttpMessageConverter) mc).setDefaultCharset(Charset.forName(\"UTF-8\")); } } return template; } public Integer getMaxTotal() { return maxTotal; } public void setMaxTotal(Integer maxTotal) { this.maxTotal = maxTotal; } public Integer getDefaultMaxPerRoute() { return defaultMaxPerRoute; } public void setDefaultMaxPerRoute(Integer defaultMaxPerRoute) { this.defaultMaxPerRoute = defaultMaxPerRoute; } public Integer getConnectTimeout() { return connectTimeout; } public void setConnectTimeout(Integer connectTimeout) { this.connectTimeout = connectTimeout; } public Integer getConnectionRequestTimeout() { return connectionRequestTimeout; } public void setConnectionRequestTimeout(Integer connectionRequestTimeout) { this.connectionRequestTimeout = connectionRequestTimeout; } public Integer getSocketTimeout() { return socketTimeout; } public void setSocketTimeout(Integer socketTimeout) { this.socketTimeout = socketTimeout; } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"httptool/RestTemplate.html":{"url":"httptool/RestTemplate.html","title":"RestTemplate","keywords":"","body":"RestTemplateRestTemplate是什么?使用所需依赖解决中文乱码问题访问中国天气出现乱码简单使用RestTemplate RestTemplate是什么? ​ 是一个可以在服务器之间相互调用,发送http请求的工具包,封装了其他有相同功能的工具包,使用更加简洁方便 使用 所需依赖 org.springframework.boot spring-boot-starter-web 解决中文乱码问题 @Configuration public class RestTemplateConfig { //第二种 不用配置类,可以直接在SpringBoot 启动类注册 @Bean public RestTemplate restTemplate() { // 默认的RestTemplate，底层是走JDK的URLConnection方式。 // 设置中文乱码问题方式一 RestTemplate restTemplate = new RestTemplate(); restTemplate.getMessageConverters().add(1,new StringHttpMessageConverter(Charset.forName(\"UTF-8\"))); // 设置中文乱码问题方式二 // restTemplate.getMessageConverters().set(1, // new StringHttpMessageConverter(StandardCharsets.UTF_8)); // 支持中文编码 return restTemplate; } } 访问中国天气出现乱码 请求接口: http://wthrcdn.etouch.cn/weather_mini?city=北京 增加依赖 org.apache.httpcomponents httpclient 4.4 修改配置类 //获得的返回数据是经过 GZIP 压缩过的, 而默认的URLConnection无法支持所以考虑创建使用httpClient的RestTemplate RestTemplate restTemplate = new RestTemplate( new HttpComponentsClientHttpRequestFactory()); // 使用HttpClient，支持GZIP restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); // 支持中文编码 简单使用 @RestController @RequestMapping(\"/rest\") public class RestTemplateController { @Autowired private RestTemplate restTemplate; private String urlPrefix = \"http://localhost:8080/\"; @GetMapping public ResponseEntity findAll(){ ResponseEntity forEntity = restTemplate.getForEntity(urlPrefix + \"brand\", BaseResult.class); return forEntity; } @GetMapping(\"/product\") public ResponseEntity findAllProduct(PageRequest pageRequest){ // 也可以直接将参数拼接在地址栏上 注意传递参数是 参数为null 会被拼接为字符串的问题 HashMap hashMap = new HashMap<>(); hashMap.put(\"pageNum\",pageRequest.getPageNum()); hashMap.put(\"pageSize\",pageRequest.getPageSize()); ResponseEntity forEntity = restTemplate.getForEntity(urlPrefix + \"product?pageNum={pageNum}&pageSize={pageSize}\",BaseResult.class,hashMap); return forEntity; } @PostMapping public ResponseEntity add(@RequestBody TbProduct tbProduct){ ResponseEntity forEntity = restTemplate.postForEntity(urlPrefix + \"product\",tbProduct, String.class); return ResponseEntity.ok(forEntity.getBody()); } @DeleteMapping(\"/{id}\") public ResponseEntity deleteById(@PathVariable Integer id){ restTemplate.delete(urlPrefix + \"product/\"+id); return ResponseEntity.ok(\"删除成功\"); } @PutMapping public ResponseEntity edit(@RequestBody TbProduct tbProduct){ restTemplate.put(urlPrefix + \"product\",tbProduct); return ResponseEntity.ok(\"修改成功\"); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-05 20:00:49 "},"mybatis/mybatis.html":{"url":"mybatis/mybatis.html","title":"Mybatis","keywords":"","body":"什么是Mybatis什么是ORM项目地址:什么是Mybatis Mybatis是一个持久层ORM框架。内部封装了jdbc，使开发更简洁，更高效。 Mybatis使开发者只需要关注sql语句本身，简化JDBC操作，不需要在关注加载驱动、创建连接、处理SQL语句等繁杂的过程。 Mybatis可以通过xml或注解完成ORM映射关系配置。 什么是ORM ORM的全称是Object Relational Mapping，即对象关系映射。 描述的是对象和表之间的映射。操作Java对象，通过映射关系，就可以自动操作数据库。 在ORM关系中，数据库表对应Java中的类，一条记录对应一个对象，一个属性对应一个列。 常见的ORM框架：Mybatis、Hibernate 项目地址: mybatis+mapper https://github.com/TaoQZ/mybatis-learning-example.git springboot+mybatis+mapper: https://github.com/TaoQZ/springboot-mybatis-example.git Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"mybatis/注意事项.html":{"url":"mybatis/注意事项.html","title":"注意事项","keywords":"","body":"注意事项@Id@Transient热部署注意事项 @Id ​ 一定不要忘了添加该注解,在使用通用mapper时,有很多方法会根据主键对数据进行操作 // 正确写法 // import javax.persistence.*; @Id // 对应列名 @Column(name = \"id\") // 自增id 在插入后可以通过getId()获取到插入后的id @GeneratedValue(generator = \"JDBC\") private Integer id; @Transient ​ 如果实体类中有属性不是表中字段,添加该注解避免出现不必要的异常 ​ Mybatis-3.2.5及以上版本必须添加 @Transient private String cids; 热部署 通用mapper不支持热部署 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"mybatis/mybatis-plus.html":{"url":"mybatis/mybatis-plus.html","title":"mybatis-plus","keywords":"","body":"简介依赖自动生成代码配置分页插件使用分页示例代码官方文档简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 依赖 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE org.springframework.boot spring-boot-starter-jdbc mysql mysql-connector-java 5.1.47 com.baomidou mybatis-plus-generator 3.2.0 org.freemarker freemarker 2.3.29 org.springframework.boot spring-boot-starter-test test org.projectlombok lombok true com.baomidou mybatis-plus-boot-starter 3.2.0 自动生成代码 // 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中 public class CodeGenerator { /** * * 读取控制台内容 * */ public static String scanner(String tip) { Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\" + tip + \"：\"); System.out.println(help.toString()); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) { return ipt; } } throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\"); } public static void main(String[] args) { // 代码生成器 AutoGenerator mpg = new AutoGenerator(); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"Tao\"); gc.setOpen(false); // gc.setIdType(IdType.NONE); // gc.setSwagger2(true); 实体属性 Swagger2 注解 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/数据库?useUnicode=true&useSSL=false&characterEncoding=utf8\"); // dsc.setSchemaName(\"public\"); dsc.setDriverName(\"com.mysql.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"密码\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(scanner(\"模块名\")); pc.setParent(\"父包\"); // pc.setService(\"%sService\"); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing } }; // 如果模板引擎是 freemarker String templatePath = \"/templates/mapper.xml.ftl\"; // 如果模板引擎是 velocity // String templatePath = \"/templates/mapper.xml.vm\"; // 自定义输出配置 List focList = new ArrayList<>(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName() + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; } }); /* cfg.setFileCreate(new IFileCreate() { @Override public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) { // 判断自定义文件夹是否需要创建 checkDir(\"调用默认方法创建的目录\"); return false; } }); */ cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); // 配置自定义输出模板 //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别 // templateConfig.setEntity(\"templates/entity2.java\"); // templateConfig.setService(); // templateConfig.setController(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); // strategy.setSuperEntityClass(\"com.baomidou.ant.common.BaseEntity\"); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); // 公共父类 // strategy.setSuperControllerClass(\"com.baomidou.ant.common.BaseController\"); // 写于父类中的公共字段 strategy.setSuperEntityColumns(\"id\"); strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\")); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(pc.getModuleName() + \"_\"); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); } } 配置分页插件 @Configuration public class MyBatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor(){ // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false // paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 // paginationInterceptor.setLimit(500); PaginationInterceptor page = new PaginationInterceptor(); //设置方言类型 page.setDialectType(\"mysql\"); return page; } 使用分页 @Test public void page(){ User user = new User(); // 分页查询加条件 所有字段为空正常查询 user.setAge(20); IPage page = iUserService.page(new Page(1, 3),new QueryWrapper(user)); page.getRecords().forEach(System.out::println); } 示例代码 ​ https://github.com/TaoQZ/mybatis-plus-learning-exam.git 官方文档 ​ https://mp.baomidou.com/ Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-16 17:31:43 "},"maven/maven.html":{"url":"maven/maven.html","title":"Maven","keywords":"","body":"Mavenmaven是什么?为什么使用maven?下载与配置配置环境变量:阿里镜像本地仓库远程仓库IDEA中配置maven入门使用坐标version后缀生命周期pom文件常用标签依赖的生命周期注意事项pom标签大全详解Maven maven是什么? Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 为什么使用maven? 在之前的项目中,每次都需要先导入很多jar包,并且出现依赖冲突没有直观显示,使用maven后不用在手动导入很多jar包, 只需要引入jar在仓库对应的坐标即可,大大减小了项目的体积 下载与配置 下载地址:https://maven.apache.org/download.cgi windows环境下选择二进制压缩包进行下载 配置环境变量: ​ 可以先在系统变量创建一个MAVEN_HOME指向maven安装路径,然后在path中添加此变量,并指向bin目 录%MAVEN_HOME%\\bin,这样做的目的是如果maven换了安装目录只需要更改MAVEN_HOME,而不需要更改path,避免出 现其他问题,配置好后使用mvn - v 命令查看版本 阿里镜像 主要的配置文件在conf文件夹中的settings.xml,其默认使用的是maven的中央仓库,为了解决国内下载速度慢的情况 找到mirrors标签添加 alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ maven安装后会有一个默认的仓库在c盘用户的文件夹.m2,更改其默认的仓库 本地仓库 在settings.xml中配置自定义本地仓库的位置 仓库所在磁盘路径 远程仓库 使用Nexus搭建maven私服 需要配置认证信息,在maven的settings.xml文件的serves节点添加 nexus-releases admin admin123 nexus-snapshots admin admin123 自动化部署,上传 命令 : mvn deploy nexus-releases Nexus Release Repository http://127.0.0.1:8081/repository/maven-releases/ nexus-snapshots Nexus Snapshot Repository http://127.0.0.1:8081/repository/maven-snapshots/ 配置代理仓库 修改url地址即可 nexus Nexus Repository http://127.0.0.1:8081/repository/maven-public/ true true nexus Nexus Plugin Repository http://127.0.0.1:8081/repository/maven-public/ true true IDEA中配置maven ​ 点击左上角File ---> other-settings ---> settings for new projects ​ 搜索maven ​ 设置创建新项目时的配置,更改本项目的配置在File ---> setting ---> 中搜索maven做同样的配置 解决IDEA中创建项目慢,因为默认使用的是远程创建 切换成使用本地的配置文件创建项目 入门使用 坐标 ​ 以下面的依赖作为示例解释坐标的概念 ​ 其实就是该jar(依赖)在仓库的位置 仓库所在磁盘位置\\org\\projectlombok\\lombok\\1.18.10 org.projectlombok 组名 lombok 模块名 1.18.10 版本号 version后缀 SNAPSHOT：快照版本,此jar包没有经过测试,很多bug RC：此jar包经过了充分测试，但是可能还有很多bug BETA：上线前的测试版本 RELEASE：正式版 生命周期 阶段 处理 描述 验证 validate 验证项目 验证项目是否正确且所有必须信息是可用的 编译 compile 执行编译 源代码编译在此阶段完成 测试 Test 测试 使用适当的单元测试框架（例如JUnit）运行测试。 包装 package 打包 创建JAR/WAR包如在 pom.xml 中定义提及的包 检查 verify 检查 对集成测试的结果进行检查，以保证质量达标 安装 install 安装 安装打包的项目到本地仓库，以供其他项目使用 部署 deploy 部署 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程 pom文件常用标签 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE jar 子模块 UTF-8 UTF-8 1.8 5.1.32 org.springframework.boot spring-boot-starter-web mysql mysql-connector-java ${mysql.version} tk.mybatis mapper 3.5.2 javax.persistence persistence-api 依赖的生命周期 compile : 编译范围,默认值 provided : 打包时需要,例如写servlet程序时需要依赖servlet-api进行编译,但是运行在tomcat容器中有相同的依赖会引起依赖冲突,此时需要添加此注解 runtime : 仅参与项目的运行阶段,例如mysql的驱动 test : 该依赖仅参与测试相关的内容,例如junit system : 使用的非maven仓库中依赖,引用的是本地文件系统的jar 注意事项 解决依赖下载不完全的问题 创建.bat文件,更改目录完毕后,双击运行 set REPOSITORY_PATH=指向maven仓库 rem 正在搜索... for /f \"delims=\" %%i in ('dir /b /s \"%REPOSITORY_PATH%\\*lastUpdated*\"') do ( del /s /q %%i ) rem 搜索完毕 pause install打包到本地仓库 将项目封装为工具类时,应该打包成为一个不可运行的jar,所以需要将下方插件依赖删除 org.springframework.boot spring-boot-maven-plugin pom标签大全详解 4.0.0 asia.banseon banseon-maven2 jar 1.0-SNAPSHOT banseon-maven http://www.baidu.com/banseon A maven project to study maven. jira http://jira.baidu.com/banseon Demo banseon@126.com banseon@126.com banseon@126.com http:/hi.baidu.com/banseon/demo/dev/ HELLO WORLD banseon banseon@126.com Project Manager Architect demo http://hi.baidu.com/banseon No -5 Apache 2 http://www.baidu.com/banseon/LICENSE-2.0.txt repo A business-friendly OSS license scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk http://svn.baidu.com/banseon demo http://www.baidu.com/banseon ...... ...... Windows XP Windows x86 5.1.2600 mavenVersion 2.0.3 /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ ...... ...... ...... ...... ...... ...... banseon-repository-proxy banseon-repository-proxy http://192.168.1.169:9999/repository/ default ...... org.apache.maven maven-artifact 3.8.1 jar test spring-core org.springframework true ...... banseon-maven2 banseon maven2 file://${basedir}/target/deploy banseon-maven2 Banseon-maven2 Snapshot Repository scp://svn.baidu.com/banseon:/usr/local/maven-snapshot banseon-site business api website scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web value。 --> Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-17 19:55:44 "},"mongodb/Mongo的安装与卸载.html":{"url":"mongodb/Mongo的安装与卸载.html","title":"Mongo的安装与卸载","keywords":"","body":"卸载:停止对应服务:卸载服务:卸载应用:安装:步骤:配置环境变量:卸载: 停止对应服务: ​ 使用管理员命令窗口 win+x+a ​ net stop 服务名 卸载服务: ​ mongod.exe --remove --serviceName \"mongo的服务名\" 卸载应用: ​ 在系统应用中进行卸载 安装: 步骤: 下载对应安装包 mongodb中文官网:https://www.mongodb.org.cn/tutorial/55.html 点击安装,选择自定义配置 3.选择安装目录 4.进行配置 配置环境变量: ​ 配置环境变量的目的:为了在电脑中任意位置都可以使用mongo(其他应用程序也是如此) ​ 系统变量和用户变量:系统变量针对当前系统有效,而用户变量只对当前用户有效 ​ 步骤: 此电脑 --> 右键 --> 属性 高级系统设置 --> 环境变量 系统变量 --> 新建 在系统变量Path的变量值中添加%mongo%\\bin; 指向mongo的bin目录 测试启动 打开命令行cmd 默认端口 27017 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"mongodb/Mongo介绍及命令行使用.html":{"url":"mongodb/Mongo介绍及命令行使用.html","title":"Mongo的介绍及命令行使用","keywords":"","body":"1. 简介2. Mongdb与MySQL的区别2.1 结构2.2 数据及存储方式2.3 优缺点2.4 使用场景3.数据类型3.1 数值类型3.2 数组类型3.3 日期类型3.4 ObjectId3.5 typeof 和$type3.6 null4.命令行启动4.1 启动服务4.2 运行mongodb4.3 基本操作5.使用5.1 基本概念5.2 添加insertOne(对象)insertMany(数组)insert(文档对象或数组)savesave和insert的区别5.3 删除deteleOnedeleteManyremove5.4 查询findfindOne5.5 更新updateOneupdateManyupdate结合参数使用6.常用操作符$set$unset$inc$exists$in$or$and$sort$skip $limit7.操作数组8. 整合springboot简单增删改查8.1 项目环境8.2 pom依赖8.3 代码1. 简介 ​ MongoDB是一个基于分布式文件存储的数据库,是非关系型数据库(NoSQL) ​ 分布式文件存储:在mongodb中也叫分片管理,将数据库中存储的数据分散在不同的机器上,减缓了数据库的压力,提高响应速度 2. Mongdb与MySQL的区别 2.1 结构 MySQL MongoDB 对应关系 database database 库 table collection 表;集合 row document 一行数据(记录);一个文档 column field 列;字段 2.2 数据及存储方式 SQL NoSQL 存储方式 存在特定结构表中 更加灵活和可扩展,简单说就是在集合中每个文档可以有不相同个数或类型 表/集合数据的关系 必须定义好表和字段结构后才能添加数据,虽然表结构定义后可更新,比较复杂 数据可以在任何时候任何地方添加，不需要先定义表 多表查询 可以使用JOIN表连接方式将多个关系数据表中的数据用一条简单的查询语句查询出来 大多非关系型数据库不支持(MongoDB 3.2后可以指定同一数据库中的集合以执行连接 ) 数据耦合性 不允许删除已经被使用的外部数据(外键),规范方式设置外键,也可手动维护 NoSQL中没有这种强耦合的概念，可以随时删除任何数据 2.3 优缺点 NoSQL SQL 优点 扩展简单,快速读写,成本低 是所有关系型数据库的通用语言(差别不大),移植性好,数据统计方便直观,事务处理,保持数据的一致性 缺点 不提供对SQL的支持,大部分非关系型数据不支持事务,现有 产品不够成熟(MongoDB4.0提供了事务的API) 扩展困难,读写慢(当数据量达到一定规模时),成本高(企业级的需要付费的) 2.4 使用场景 ​ 单从功能上讲,NoSQL几乎所有的功能,在关系型数据库上都能满足,所以选择NoSQL主要是和关系型数据库进 行结合使用,各取所长 ​ 比如说数据库中的表结构需要经常变化,增加字段,如果在一个百万级数据量的关系型数据库中新增字段会有很 多问题,而使用非关系型数据库极大提升扩展性,也可以作为缓存数据库,典型就是Redis 3.数据类型 ​ mongodb存储数据的格式为BSON,和JSON很像,是JSON的扩展 mongodb支持的所有的数据类型: Type Number Alias Notes Double 1 “double” String 2 “string” Object 3 “object” Array 4 “array” Binary data 5 “binData” Undefined 6 “undefined” Deprecated. ObjectId 7 “objectId” Boolean 8 “bool” Date 9 “date” Null 10 “null” Regular Expression 11 “regex” DBPointer 12 “dbPointer” Deprecated. JavaScript 13 “javascript” Symbol 14 “symbol” Deprecated. JavaScript (with scope) 15 “javascriptWithScope” 32-bit integer 16 “int” Timestamp 17 “timestamp” 64-bit integer 18 “long” Decimal128 19 “decimal” New in version 3.4. Min key -1 “minKey” Max key 127 “maxKey” ​ ​ JSON : 布尔、数字、字符串、数组和对象 ​ 没有日期类型,只有一种数字类型,无法区分浮点数和整数,也没法表示正则表达式或者函数 ​ BSON : 是一种类JSON的二进制形式的存储格式,有JSON没有的一些数据类型,如Date,BinData(二进制数据) 3.1 数值类型 ​ mongodb的数值类型默认使用64位浮点型数值,整型可以使用NumberInt(值)或者NumberLong (值) db.emp.insert({age:18}) db.emp.find({age:18}) // 如果有int类型会同时查询出来 { \"_id\" : ObjectId(\"5dca61c0f366526745ae2f13\"), \"age\" : 18.0 } ====================================== // NumberInt 插入 NumberLong 同理 db.emp.insert({age:NumberInt(18)}) // $type : 可以使用此命令查询对应的数据类型 // 可以使用上面表格中的Number 也可以使用 Alias db.emp.find({age:{$type:\"int\"}}) { \"_id\" : ObjectId(\"5dca62c9f366526745ae2f16\"), \"age\" : NumberInt(18) } 3.2 数组类型 ​ db.emp.insert({ _id:new ObjectId(), name:'taoqz', arr:[ '字符串', 100, new Date(\"2019-11-11\") ] }) db.emp.findOne({name:\"taoqz\"}) // 数组中支持不同的类型 { \"_id\" : ObjectId(\"5dca6971f366526745ae2f17\"), \"name\" : \"taoqz\", \"arr\" : [ \"字符串\", 100.0, ISODate(\"2019-11-11T00:00:00.000+0000\") ] } 3.3 日期类型 // 构建一个格林尼治时间 可以看到正好和我们的时间相差8小时，我们是+8时区，也就是时差相差8 new Date() new Date(\"1999-10-09T18:56:01\") // 真实时间是要比下面的时间大八个小时的 ISODate(\"2019-11-12T08:30:50.060Z\") // 此问题在Java中结合springboot时可以在对应的字段上添加下面注释 @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") 3.4 ObjectId ​ ObjectId使用12字节的存储空间，每个字节可以存储两个十六进制数字，所以一共可以存储24个十六进制数 字组成的字符串，在这24个字符串中，前8位表示时间戳，接下来6位是一个机器码，接下来4位表示进程id，最后 6位表示计数器 ​ 是文档的唯一标识,没有自增,如果不添加id会自动添加一个 \"_id\" : ObjectId(\"值\") db.emp.insert({_id:new ObjectId(),name:\"zz\"}) db.emp.findOne({name:\"zz\"}) { \"_id\" : ObjectId(\"5dca6eb4f366526745ae2f18\"), \"name\" : \"zz\" } 3.5 typeof 和$type ​ typeof 1 number typeof \"zz\" string ​ 每个数据类型对应一个数字，在MongoDB中可以使用$type操作符查看字段的数据类型 ​ $type:根据数据类型查找数据 {字段:{$type:数字}} {字段:{$type:\"数据类型\"}} 3.6 null ​ 用于表示空值或者不存在的字段 ,在查询的时候也可能会使用到 4.命令行启动 4.1 启动服务 ​ net start 服务名 (管理员cmd) 4.2 运行mongodb ​ mongo 4.3 基本操作 查看所有数据库 show dbs 查看所有集合 show tables | show collections 查看当前所在数据库 db 使用数据库 use db_name 删除数据库 db.dropDatabase() # 删除当前正在使用的数据库 使用集合 db.collection_name.find() # 查所有满足条件数据 db.collection_name.findOne() # 查满足条件的一条数据 db.collection_name.count() # 统计集合下面有多少数量的数据 删除集合 db.collection_name.drop() 创建数据库和集合 # 当你使用一个不存在的mongo数据库时,就自动创建了一个mongo数据库 # 同理当你往一个空集合里面插入了一条数据之后就自动创建了一个集合 查看当前数据库版本 db.version() 备份数据库 // 导出 如果没有设置账号密码 可以省略 mongodump --host IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件路径 // 导入 mongorestore --host --port -d 文件路径 5.使用 5.1 基本概念 ​ 数据库(database) ​ 集合(collection) ​ 文档(document) ​ 一个数据库由多个集合组成,一个集合中有许多文档,文档是最小的存储单位 5.2 添加 insertOne(对象) // 添加一条数据 db.emp.insertOne({name:\"张三\"}) // 返回的数据,也可以定义变量接收 { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"5dca9ef4f366526745ae2f1a\") } insertMany(数组) // 添加多条数据 db.emp.insertMany([{name:\"李四\"},{name:\"王五\"}]) { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"5dca9f91f366526745ae2f1c\"), ObjectId(\"5dca9f91f366526745ae2f1d\") ] } insert(文档对象或数组) // 添加一条或者多条 db.emp.insert({name:\"赵六\"}) WriteResult({ \"nInserted\" : 1 }) db.emp.insert([{name:\"田七\"},{name:\"吴八\"}]) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 2, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) // 查询所有 db.emp.find({}) { \"_id\" : ObjectId(\"5dca9f2bf366526745ae2f1b\"), \"name\" : \"张三\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9f91f366526745ae2f1c\"), \"name\" : \"李四\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9f91f366526745ae2f1d\"), \"name\" : \"王五\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dca9feef366526745ae2f1e\"), \"name\" : \"赵六\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa017f366526745ae2f1f\"), \"name\" : \"田七\" } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa017f366526745ae2f20\"), \"name\" : \"吴八\" } // 可以看到在插入时并没有指定id,确自动生成了一个_id // 在插入的时候如果已经存在了相同的id会报错 // 如果想要存在相同的id的时候不报错而是更新数据 请使用 save方法 ​ save // 当集合中没有此条数据,进行插入 db.emp.save({_id:\"1\",name:\"阿里\"}) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : \"1\" }) ----------------------------------------------------------------------------- // 有数据时会进行替换,而不是更新,更新会有专门针对字段更新的API db.emp.save({_id:\"1\",name:\"腾讯\",boss:\"马化腾\"}) // 一处匹配 一处修改 WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) ----------------------------------------------------------------------------- // 查询结果 { \"_id\" : \"1\", \"name\" : \"腾讯\", \"boss\" : \"马化腾\" } save和insert的区别 save和insert的区别 如果save没有指定id,直接插入 ​ 如果save指定了id,并且id已存在会替换已有的文档 5.3 删除 ​ // 插入两条数据 { \"_id\" : ObjectId(\"5dcaa5445feb59ece4310397\"), \"name\" : \"小王\", \"age\" : NumberInt(18) } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcaa5445feb59ece4310398\"), \"name\" : \"小红\", \"age\" : NumberInt(18) } deteleOne // 参数为空文档会集合中第一条文档 db.student.deleteOne({}) { \"acknowledged\" : true, \"deletedCount\" : 1.0 } // 两条命令效果一样 // $eq:== $gt:> $gte:>= $lt: deleteMany // 删除多条数据 // 如果传入空文档 会删除整个集合中的数据 db.student.deleteMany({}) { \"acknowledged\" : true, \"deletedCount\" : 2.0 } // 使用该命令会删除所有的匹配项 db.student.deleteMany({age:18}) { \"acknowledged\" : true, \"deletedCount\" : 2.0 } remove // 指定删除 会删除所有匹配项 db.student.remove({name:\"小王\"}) db.student.remove({age:18}) 5.4 查询 find // 查询所有 // 直接使用集合名称 db.student.find() // 指定集合名称 db.getCollection(\"student\").find({}) findOne // 只查询到第一个匹配到的 db.student.findOne({age:{$eq:18}}) // 会查询到所有匹配的 db.student.find({age:{$eq:18}}) 5.5 更新 ​ 数据 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } updateOne // 更新 db.books.updateOne({flag:1},{$set:{name:\"newName\"}}) { \"acknowledged\" : true, \"matchedCount\" : 1.0, \"modifiedCount\" : 1.0 } // 只更新了第一条 { \"_id\" : 1.0, \"name\" : \"newName\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } updateMany // 重新初始化数据后使用该命令会修改所有匹配项 db.books.updateMany({flag:1},{$set:{name:\"newName\"}}) update 和使用updateOne效果一样 结合参数使用 // 语法 db.collection.update( , , { upsert: , multi: , writeConcern: } ) query: 查询的条件 update: 可以配合操作符更新字段 upsert: 可选 当没有匹配项时,是否作为新的对象插入,默认false不插入 multi: 可选 默认false,只更新匹配的第一条记录,如果为true,将跟新所有匹配项 // 例如 可以弥补上面update时只更新一个匹配项 db.books.update({flag:1},{$set:{name:\"newName\"}},false,true) // 没有匹配项会添加 db.books.update({name:\"西游记\"},{name:\"西游记\"},true) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"红楼梦\", \"publisher\" : \"曹雪芹\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // ---------------------------------------------- { \"_id\" : ObjectId(\"5dcab070763517547f7d8d95\"), \"name\" : \"西游记\" } 6.常用操作符 $set ​ 在更新时可以一个或多个字段 ​ 如果更新的字段不存在会添加该字段 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } // 更新flag和view字段 但flag字段之前不存在 进行了添加 db.books.update({_id:1},{$set:{flag:11,view:100}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } $unset ​ 删除字段 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 1.0 } // 将flag字段删除,其中flag的值可以随意写不用匹配 db.books.update({_id:1},{$unset:{flag:11}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } $inc ​ 自增或自减 { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0 } // 将view字段自增10 db.books.update({_id:1},{$inc:{view:+10}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 10.0 } $exists ​ 匹配字段是否存在 // 格式 {字段:{$exists:boolean}} // 如果为true 匹配到所有有该字段的文档,包括null值 // false 则匹配没有该字段的文档 db.books.find({flag:{$exists:true}}) $in ​ 相当于mysql中的in ​ 是否在对应的范围 // 会匹配到对应字段在对应范围中的所有文档 db.books.find({_id:{$in:[1,3]}}) $or ​ 或者 ​ 格式:{ $or: [ { }, { }, ... , { } ] } { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"西游记\", \"publisher\" : \"吴承恩\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 0.0, \"flag\" : 0.0 } // ---------------------------------------------- { \"_id\" : 3.0, \"name\" : \"zz\" } // ---------------------------------------------- { \"_id\" : 4.0, \"name\" : \"qwe\", \"flag\" : null } // 查询名字水浒传或者view大于等于0或者拥有flag字段的文档 db.books.find({$or:[ {name:\"水浒传\"}, {view:{$gte:0}}, {flag:{$exists:true}} ]}) $and ​ 并且 ​ 格式:{ $and: [ { }, { } , ... , { } ] } { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } // ---------------------------------------------- { \"_id\" : 2.0, \"name\" : \"西游记\", \"publisher\" : \"吴承恩\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0 } // 查询view大于等于100 并且存在flag字段的文档 db.books.find({$and:[ {view:{$gte:100}}, {flag:{$exists:true}} ]}) { \"_id\" : 1.0, \"name\" : \"水浒传\", \"publisher\" : \"施耐庵\", \"tags\" : [ \"小说\", \"电视剧\" ], \"view\" : 100.0, \"flag\" : 11.0 } $sort ​ 排序 // 按照id 倒叙排序 // -1 从大到小 // 1 从小到大 db.books.find({}).sort({_id:-1}) $skip $limit ​ $skip 采用一个正整数，该整数指定要跳过的最大文档数。 ​ $limit 采用一个正整数，该整数指定要传递的最大文档数。 ​ 作用相当于mysql中的limit 两者可以结合使用 skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 7.操作数组 8. 整合springboot简单增删改查 8.1 项目环境 ​ mongodb: 4.0.9 ​ java:1.8 ​ springboot:2.2.0 ​ idea : 2019 ​ 使用了lombok简化实体类的代码 8.2 pom依赖 org.springframework.boot spring-boot-starter-parent 2.2.0.RELEASE org.springframework.boot spring-boot-starter-data-mongodb org.springframework.boot spring-boot-starter-web org.projectlombok lombok 1.18.8 8.3 代码 实体类 @Data @Document(collection = \"students\") public class Student { @Id private String id; private Integer sid; private String name; @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:dd\") @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:dd\",timezone = \"GMT+8\") private Date birthday; private String classId; private Classes classes; private String hobbies[]; } controller @RestController @CrossOrigin(\"*\") @RequestMapping(\"/student\") public class StudentController { @Autowired private StudentDao studentDao; /** * 查询所有 * @return */ @GetMapping public List fun() { return studentDao.findAll(); } /** * 添加 * @param student */ @PostMapping public void add(@RequestBody Student student) { studentDao.save(student); } /** * 修改 * @param student */ @PutMapping public void edit(@RequestBody Student student) { studentDao.update(student); } /** * 根据字段及值 进行删除 * @param filedName * @param value */ @DeleteMapping public void deleteByFiledName(@RequestParam(name = \"filedName\") String filedName, String value) { studentDao.deleteByFiledName(filedName, value); } } dao @Repository public class StudentDao { @Autowired private MongoTemplate mongoTemplate; /** * 查询所有 * @return */ public List findAll(){ List all = mongoTemplate.findAll(Student.class); for (Student student : all) { if (student.getClassId() != null){ // 拿到每个学生对应的班级id 创建ObjectId对象 ObjectId objectId = new ObjectId(student.getClassId()); // 根据班级id查询班级 Classes one = mongoTemplate.findOne(new Query(Criteria.where(\"id\").is(objectId)), Classes.class); // 将班级添加到学生对象中 student.setClasses(one); } } return all; } /** * 添加 * @param student */ public void save(Student student) { // 可以在笔记中看到两者的区别 mongoTemplate.insert(student); // mongoTemplate.save(student); } /** * 更新 * @param student */ public void update(Student student) { // 查询条件 根据id Query id = Query.query(Criteria.where(\"_id\").is(student.getId())); // 创建文档对象 Document document = new Document(); // 向文档中追加数据 更新哪个字段添加哪个字段 document.append(\"name\",student.getName()).append(\"birthday\",student.getBirthday()) .append(\"hobbies\",student.getHobbies()); // 根据id 根据文档对象进行更新 // 因为是根据ObjectId进行更新所以唯一 使用updateFirst 只更新第一条 mongoTemplate.updateFirst(id, Update.fromDocument(document),Student.class); // 更新所有能匹配的文档 // mongoTemplate.updateMulti(); } /** * 根据字段名称删除文档 * @param filedName 字段名称 * @param value 字段对应的值 */ public void deleteByFiledName(String filedName,String value){ Query query = Query.query(Criteria.where(filedName).is(value)); mongoTemplate.remove(query, Student.class); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-17 19:56:30 "},"swagger/SpringBoot整合Swagger2.html":{"url":"swagger/SpringBoot整合Swagger2.html","title":"Springboot整合Swagger2","keywords":"","body":"Swgger2依赖配置类示例代码其他主要注解Swgger2 ​ Swagger 是一个根据接口生成API文档,进行测试 ​ 这里主要是结合springboot方便测试使用 依赖 这里只列出springboot版本 以及swagger所需的依赖 org.springframework.boot spring-boot-starter-parent 2.2.0.RELEASE io.springfox springfox-swagger2 2.9.2 io.springfox springfox-swagger-ui 2.9.2 配置类 主要配置生成的API的title和开启Swagger接口文档 @Configuration //标记配置类 @EnableSwagger2 //开启在线接口文档 public class Swagger2Config { /** * 添加摘要信息(Docket) */ @Bean public Docket controllerApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(new ApiInfoBuilder() .title(\"接口测试\") .description(\"接口测试\") // .contact(new Contact(\"一只袜子\", null, null)) .version(\"版本号:1.0\") .build()) .select() .apis(RequestHandlerSelectors.basePackage(\"xyz.taoqz.controller\")) .paths(PathSelectors.any()) .build(); } } 示例代码 @Api(value = \"emp\") @RestController @CrossOrigin @RequestMapping(\"/emp\") public class EmpController { @Autowired private IEmpService iEmpService; @ApiOperation(value = \"根据id删除\",httpMethod = \"DELETE\") @DeleteMapping(\"/{id}\") public ResponseEntity deleteById(@PathVariable Integer id){ try { iEmpService.removeById(id); baseResult.setMsg(\"删除成功\"); baseResult.setStateCode(StateCode.SUCCESS); } catch (Exception e) { baseResult.setMsg(\"删除失败\"); baseResult.setStateCode(StateCode.FAIL); } return ResponseEntity.ok(baseResult); } } 生成后的api文档页面 访问接口: http://localhost:8080/swagger-ui.html 使用: 点击其中一个接口 Try it out 填写好参数后 Excute发送请求 推荐使用Idea中的插件RestServices,可以更加方便进行测试 其他主要注解 https://blog.csdn.net/xupeng874395012/article/details/68946676 https://blog.csdn.net/weixin_41846320/article/details/82970204 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"elementUI/ElementUI.html":{"url":"elementUI/ElementUI.html","title":"elementUI","keywords":"","body":"网站快速成型工具vue中使用安装与配置使用样例NavMenu导航菜单Table表格Pagination 分页Radio单选框Checkbox 多选框Tree 树形Tabs 标签页DatePicker 日期选择器Cascader级联选择器网站快速成型工具 ​ Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 vue中使用 安装与配置 // 安装 npm i element-ui // 配置 import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); 使用样例 NavMenu导航菜单 ​ default-active=\"2\" : 默认打开菜单的index ​ 设置为根据路由显示: ​ :default-active=\"$route.path\" ​ 同时在相同位置添加 :router=\"true\" 首页 xxx Table表格 ​ 获取当前行数据 { {scope.row} } Pagination 分页 Radio单选框 ​ 需要设置v-model绑定变量，选中意味着变量的值为相应 Radio label属性的值，label可以是String、Number或Boolean 禁用 Checkbox 多选框 ​ 注意 :label绑定对应id ​ value此时对应的应该是一个数字类型的数组 Tree 树形 // 数据格式 对应数据的字段名 defaultProps: { children: '', label: '' } // 获取值 // 全选 this.$refs.tree.getCheckedKeys()+'' // 半选 也就是父级 // this.$refs.tree.getHalfCheckedKeys() Tabs 标签页 ​ 标签 ​ js export default { name: 'home', data(){ return{ activename:'/home', tabs:[] } }, methods:{ // 点击选项卡后触发的方法 handleClick(tab, event) { // 跳转到对应选项卡的path this.$router.push(tab.name) }, // 添加选项卡 addTab(routeName,routePath){ // 如果是首页 不添加直接返回 if (routeName == 'home'){ return } // 设置标记 用来标记选项卡数组中是否已存在要添加的 // 如果存在 则选中该选项卡 let flag = true; this.tabs.forEach(ele => { if (ele.title == routeName){ flag = false; this.activename = ele.path } }) // 添加选项卡 // title 使用路由的名称 // path 使用路由的path if (flag){ this.tabs.push({ title: routeName, path: routePath }) // 将新添加的选项卡激活 this.activename = routePath } }, // 移除选项卡 removeTab(targetName){ this.tabs.forEach((ele,index) => { if (ele.path == targetName){ this.tabs.splice(index,1) } }) // 如果选项卡组中还有其他选项卡,将最后一个激活 否则跳转首页 if (this.tabs.length != 0){ this.activename = this.tabs[this.tabs.length-1].path this.$router.push(this.tabs[this.tabs.length-1].path) }else { this.$router.push('/home') } } }, // 监听路由 发生变化时添加选项卡 watch:{ '$route'(to,from){ this.addTab(to.name,to.path) } }, // 页面激活添加选项卡 mounted() { this.addTab(this.$route.name,this.$route.path) } } DatePicker 日期选择器 Cascader级联选择器 // 改变时触发的方法 data(){ return{ values:[], props:{ // 最后获取的是该value值 value:'', label:'', children:'' } } }, method:{ handleChange(value) { console.log(value); }, } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-16 21:13:33 "},"other/使用Google Cloud搭建ssr.html":{"url":"other/使用Google Cloud搭建ssr.html","title":"搭建SSR","keywords":"","body":"使用Google Cloud搭建ssr1.需要用到2.申请注册谷歌云3.创建实例4.创建防火墙规则5.开始搭建使用Google Cloud搭建ssr ​ 在youtube或者各种搜索引擎上已经有不少的视频和教程,写本文也是分享一下自己的经验:happy:。 ​ 谷歌云平台会赠送新用户300美金，免费使用一年，薅羊毛嘛:joy:。 1.需要用到 ​ 1.1.前置的科学上网工具 ​ 1.2.谷歌账号 ​ 1.3.支持外币支付的信用卡（ps.我申请的中国银行的万事达） ​ 这里放上我申请的信用卡链接:https://mp.weixin.qq.com/s/NXSM8C5mnq7I4NAlOOMlNw 2.申请注册谷歌云 ​ 2.1.地址:https://cloud.google.com/free/ ​ 2.2.其中的地区已经没有中国了选其他地区或国家,我选的香港,将自己的信用卡绑定后进入主页面 ​ 可以看到下图说明已经成功激活谷歌云了 3.创建实例 ​ 3.1.点击左上角菜单栏图标选中结算,去激活你的结算账号 ​ 3.2.选中Compute Engine ​ 3.3.创建实例详细信息 ​ 3.4.测试延迟 ​ 创建VM实例完成后,会有一个外部IP,复制该IP进行 ​ 测速:https://tools.ipip.net/traceroute.php ​ 延迟在50左右还行,100以下都能用,越小越好 4.创建防火墙规则 ​ 4.1选中菜单栏VPC网络点击防火墙规则 ​ 注意需要创建两个,下图中会有说明 5.开始搭建 ​ 5.1.在创建好的实例有一个SSH选择在浏览器窗口打开 ​ 依次输入以下命令 ​ 5.1.1. sudo -i 切换到root ​ 5.1.2. 安装SSR wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2>&1 | tee shadowsocksR.log ​ 5.1.3. ./shadowsocksR.sh 运行 ​ 5.2.回车运行后会看到下图,有解释说明 到此一个通过Google Cloud搭建的SSR就可以使用了:beers: Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"other/kaptcha验证码.html":{"url":"other/kaptcha验证码.html","title":"Kaptcha验证码","keywords":"","body":"Kaptcha结合springboot使用依赖配置类controllerKaptcha Kaptcha是一个高度可配置的生成验证码的工具 结合springboot使用 依赖 com.google.code.kaptcha kaptcha 2.3 配置类 @Configuration public class KaptchaConfig { @Bean public DefaultKaptcha getDefaultKaptcha(){ com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = new com.google.code.kaptcha.impl.DefaultKaptcha(); Properties properties = new Properties(); // 图片边框 properties.put(\"kaptcha.border\", \"no\"); properties.put(\"kaptcha.textproducer.font.color\", \"black\"); // 图片高宽 properties.put(\"kaptcha.image.width\", \"150\"); properties.put(\"kaptcha.image.height\", \"40\"); // 字体大小 properties.put(\"kaptcha.textproducer.font.size\", \"30\"); // 存在session中的key properties.put(\"kaptcha.session.key\", \"verifyCode\"); // 验证码长度 properties.put(\"kaptcha.textproducer.char.length\", \"5\"); // 文字间隔 properties.put(\"kaptcha.textproducer.char.space\", \"5\"); // 图片样式 properties.put(\"kaptcha.obscurificator.impl\", \"com.google.code.kaptcha.impl.FishEyeGimpy\"); Config config = new Config(properties); defaultKaptcha.setConfig(config); return defaultKaptcha; } } controller @Controller public class KaptchaController { @Autowired private DefaultKaptcha captchaProducer; @GetMapping(\"/kaptcha\") public void defaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { byte[] captchaOutputStream = null; ByteArrayOutputStream imgOutputStream = new ByteArrayOutputStream(); try { // 生产验证码字符串并保存到session中 String verifyCode = captchaProducer.createText(); System.out.println(verifyCode); httpServletRequest.getSession().setAttribute(\"verifyCode\", verifyCode); BufferedImage challenge = captchaProducer.createImage(verifyCode); ImageIO.write(challenge, \"jpg\", imgOutputStream); } catch (IllegalArgumentException e) { httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND); return; } captchaOutputStream = imgOutputStream.toByteArray(); httpServletResponse.setHeader(\"Cache-Control\", \"no-store\"); httpServletResponse.setHeader(\"Pragma\", \"no-cache\"); httpServletResponse.setDateHeader(\"Expires\", 0); httpServletResponse.setContentType(\"image/jpeg\"); ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream(); responseOutputStream.write(captchaOutputStream); responseOutputStream.flush(); responseOutputStream.close(); } } Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "},"other/阿里云域名.html":{"url":"other/阿里云域名.html","title":"阿里云域名","keywords":"","body":"阿里云购买域名注册并登陆阿里云挑选并购买域名进入控制台备案解析域名阿里云购买域名 ​ 想要搭建一个网站肯定少不了一个域名,分享一下自己在阿里云购买域名的经验 ​ 还有一个提供免费域名的网站,我没有购买成功,每次购买都会有未知错误,所以就没有后续了,哈哈 [ https://www.freenom.com/zh/index.html?lang=zh]: 注册并登陆阿里云 ​ 可以选择直接使用支付宝登陆 挑选并购买域名 进入控制台备案 ​ 购买成功后点击右上角进入控制台,在顶部搜索栏输入域名进入域名控制台. ​ 现在还不能使用我们的域名,需要我们进行备案,添加域名模板 ​ 注意事项: ​ 身份证照片:会控制大小,55k-1MB左右需要注意一下.如果手机像素太高,可以拍完后使用QQ截图 ​ 地址信息:最好和你的身份证上一致 ​ 邮箱:可能会让你验证一下,记不太清楚了 ​ 备案验证成功后进入左侧列表中的域名列表,点击解析 解析域名 ​ 解析域名就是将你的域名指向网站IP,方便记忆 ​ 进入解析设置页面后点击添加记录,其中每个选项都有解释,添加记录的旁边还有新手引导 ​ 更详细的解释有阿里提供的文档: [https://cloud.tencent.com/document/product/302/3468]: ​ 10分钟左右就可以通过域名访问你的网站了 Copyright © almostTao 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-04 21:52:08 "}}